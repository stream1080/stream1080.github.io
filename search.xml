<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>golang的堆和栈</title>
      <link href="/posts/54577.html"/>
      <url>/posts/54577.html</url>
      
        <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>在Go语言中，堆和栈是内存管理的两个重要概念，它们在存储和管理数据的方式上有很大的区别。以下是栈和堆之间的主要区别：</p><h2 id="1-内存分配方式"><a href="#1-内存分配方式" class="headerlink" title="1. 内存分配方式"></a>1. 内存分配方式</h2><h3 id="栈（Stack）："><a href="#栈（Stack）：" class="headerlink" title="栈（Stack）："></a>栈（Stack）：</h3><ul><li>栈内存是由编译器管理的，它以<strong>LIFO（后进先出）</strong>的方式分配和释放内存。</li><li>当函数被调用时，局部变量会被分配在栈上，函数调用完成后，这些局部变量会自动释放。</li><li>栈内存的大小是有限的，因此存储的数据通常较小。</li></ul><h3 id="堆（Heap）："><a href="#堆（Heap）：" class="headerlink" title="堆（Heap）："></a>堆（Heap）：</h3><ul><li>堆内存由运行时的垃圾回收器（GC）进行管理，内存的分配和释放是动态的，不是由编译器管理的。</li><li>堆内存用于存储较大或生命周期较长的数据，如通过new或make分配的对象（例如结构体或数组）。</li><li>堆内存的大小没有固定限制，但使用堆内存会产生垃圾回收的负担。</li></ul><h2 id="2-生命周期"><a href="#2-生命周期" class="headerlink" title="2. 生命周期"></a>2. 生命周期</h2><h3 id="栈上的变量："><a href="#栈上的变量：" class="headerlink" title="栈上的变量："></a>栈上的变量：</h3><ul><li>局部变量在栈上分配，函数调用结束后，这些变量会自动销毁。</li><li>它们的生命周期与函数调用的生命周期一致。</li><li>栈上的数据通常是短暂的，生命周期非常短。</li></ul><h3 id="堆上的变量："><a href="#堆上的变量：" class="headerlink" title="堆上的变量："></a>堆上的变量：</h3><ul><li>堆上的变量通常由垃圾回收器管理，只有当没有引用该对象时，GC才会回收这块内存。</li><li>它们的生命周期相对较长，通常由程序员通过指针或其他方式显式控制。</li></ul><h2 id="3-内存访问效率"><a href="#3-内存访问效率" class="headerlink" title="3. 内存访问效率"></a>3. 内存访问效率</h2><h3 id="栈："><a href="#栈：" class="headerlink" title="栈："></a>栈：</h3><ul><li>栈内存的分配和释放非常高效，因为栈是按顺序分配的，分配和释放仅仅是通过调整栈指针。</li><li>对栈内存的访问速度很快，几乎没有额外的开销。</li></ul><h3 id="堆："><a href="#堆：" class="headerlink" title="堆："></a>堆：</h3><ul><li>堆内存的分配和释放相对较慢，因为需要更多的管理工作，尤其是垃圾回收。</li><li>对堆内存的访问速度较慢，尤其是在频繁分配和释放内存时，可能会带来性能开销。</li></ul><h2 id="4-内存大小限制"><a href="#4-内存大小限制" class="headerlink" title="4. 内存大小限制"></a>4. 内存大小限制</h2><h3 id="栈：-1"><a href="#栈：-1" class="headerlink" title="栈："></a>栈：</h3><ul><li>栈的大小是有限的，通常在几个MB之间。如果栈上分配的内存过多（例如递归深度过大或局部变量过多），会导致栈溢出（stack overflow）。</li></ul><h3 id="堆：-1"><a href="#堆：-1" class="headerlink" title="堆："></a>堆：</h3><ul><li><p>堆的内存限制通常较大，理论上可以容纳较大规模的数据。</p><h2 id="5-数据类型"><a href="#5-数据类型" class="headerlink" title="5. 数据类型"></a>5. 数据类型</h2><h3 id="栈上的数据："><a href="#栈上的数据：" class="headerlink" title="栈上的数据："></a>栈上的数据：</h3></li><li><p>通常是值类型（例如int、float、bool、结构体等），即直接存储数据本身。</p><h3 id="堆上的数据："><a href="#堆上的数据：" class="headerlink" title="堆上的数据："></a>堆上的数据：</h3></li><li><p>通常是引用类型（例如指向结构体的指针、切片、映射、通道等），即存储的是数据的地址。</p><h2 id="6-垃圾回收"><a href="#6-垃圾回收" class="headerlink" title="6. 垃圾回收"></a>6. 垃圾回收</h2><h3 id="栈：-2"><a href="#栈：-2" class="headerlink" title="栈："></a>栈：</h3></li><li><p>栈内存不需要垃圾回收。栈帧会随着函数调用的结束而自动清理。</p><h3 id="堆：-2"><a href="#堆：-2" class="headerlink" title="堆："></a>堆：</h3></li><li><p>堆内存需要垃圾回收器的管理。当对象不再被引用时，GC会自动清理堆内存。</p><h2 id="7-指针和引用"><a href="#7-指针和引用" class="headerlink" title="7. 指针和引用"></a>7. 指针和引用</h2><h3 id="栈上的变量：-1"><a href="#栈上的变量：-1" class="headerlink" title="栈上的变量："></a>栈上的变量：</h3></li><li><p>变量直接存储值，没有指针的概念。</p><h2 id="堆上的变量：-1"><a href="#堆上的变量：-1" class="headerlink" title="堆上的变量："></a>堆上的变量：</h2></li><li><p>变量通常通过指针来引用，指针指向堆中的数据。这样可以确保在栈的作用域结束后，堆中的数据仍然可用。</p><h2 id="8-例子"><a href="#8-例子" class="headerlink" title="8. 例子"></a>8. 例子</h2><p>栈上的变量：</p></li></ul><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">var</span> a <span class="token builtin">int</span> <span class="token operator">=</span> <span class="token number">42</span>  <span class="token comment">// 变量 a 存储在栈上</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>堆上的变量：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">var</span> b <span class="token operator">*</span><span class="token builtin">int</span> <span class="token operator">=</span> <span class="token function">new</span><span class="token punctuation">(</span><span class="token builtin">int</span><span class="token punctuation">)</span>  <span class="token comment">// 变量 b 存储的是堆上数据的地址</span>    <span class="token operator">*</span>b <span class="token operator">=</span> <span class="token number">42</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token operator">*</span>b<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>栈：分配和释放效率高，生命周期短，适合存储小的、临时的局部数据。</li><li>堆：内存分配较慢，但适合存储较大的、生命周期较长的对象，依赖垃圾回收管理。</li></ul><p>理解堆和栈的区别，能够优化Go程序的内存使用，尤其是在处理大数据和复杂结构时，合理选择堆栈内存的使用可以显著提升程序的性能。</p>]]></content>
      
      
      <categories>
          
          <category> Golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 堆栈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>消息事务</title>
      <link href="/posts/34914.html"/>
      <url>/posts/34914.html</url>
      
        <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>面试的时候遇到一个<code>半消息</code>的问题，是<code>RocketMQ</code> 中通过消息实现分布式事务的功能。之前没有涉及过这部分知识，在这里做个记录、</p><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>分布式系统调用的特点为一个核心业务逻辑的执行，同时需要调用多个下游业务进行处理。因此，如何保证核心业务和多个下游业务的执行结果完全一致，是分布式事务需要解决的主要问题。</p><p>以电商交易场景为例，用户支付订单这一核心操作的同时会涉及到下游物流发货、积分变更、购物车状态清空等多个子系统的变更。当前业务的处理分支包括：</p><ul><li>主分支订单系统状态更新：由未支付变更为支付成功。</li><li>物流系统状态新增：新增待发货物流记录，创建订单物流记录。</li><li>积分系统状态变更：变更用户积分，更新用户积分表。</li><li>购物车系统状态变更：清空购物车，更新用户购物车记录。</li></ul><h2 id="传统XA事务方案：性能不足"><a href="#传统XA事务方案：性能不足" class="headerlink" title="传统XA事务方案：性能不足"></a>传统XA事务方案：性能不足</h2><p>为了保证上述四个分支的执行结果一致性，典型方案是基于XA协议的分布式事务系统来实现。将四个调用分支封装成包含四个独立事务分支的大事务。基于XA分布式事务的方案可以满足业务处理结果的正确性，但最大的缺点是多分支环境下资源锁定范围大，并发度低，随着下游分支的增加，系统性能会越来越差。</p><h2 id="基于普通消息方案：一致性保障困难"><a href="#基于普通消息方案：一致性保障困难" class="headerlink" title="基于普通消息方案：一致性保障困难"></a>基于普通消息方案：一致性保障困难</h2><p>将上述基于XA事务的方案进行简化，将订单系统变更作为本地事务，剩下的系统变更作为普通消息的下游来执行，事务分支简化成普通消息+订单表事务，充分利用消息异步化的能力缩短链路，提高并发度。<br>该方案中消息下游分支和订单系统变更的主分支很容易出现不一致的现象，例如：</p><ul><li>消息发送成功，订单没有执行成功，需要回滚整个事务。</li><li>订单执行成功，消息没有发送成功，需要额外补偿才能发现不一致。</li><li>消息发送超时未知，此时无法判断需要回滚订单还是提交订单变更。</li></ul><h2 id="事务消息处理流程"><a href="#事务消息处理流程" class="headerlink" title="事务消息处理流程"></a>事务消息处理流程</h2><p><img src="/img/1740103423753.jpg"></p><ol><li><p>生产者将消息发送至消息队列服务端。</p></li><li><p>消息队列将消息持久化成功之后，向生产者返回Ack确认消息已经发送成功，此时消息被标记为“暂不能投递”，这种状态下的消息即为半事务消息。</p></li><li><p>生产者开始执行本地事务逻辑。</p></li><li><p>生产者根据本地事务执行结果向服务端提交二次确认结果（Commit或是Rollback），服务端收到确认结果后处理逻辑如下：</p><ul><li>二次确认结果为Commit：服务端将半事务消息标记为可投递，并投递给消费者。</li><li>二次确认结果为Rollback：服务端将回滚事务，不会将半事务消息投递给消费者。</li></ul></li><li><p>在断网或者是生产者应用重启的特殊情况下，若服务端未收到发送者提交的二次确认结果，或服务端收到的二次确认结果为Unknown未知状态，经过固定时间后，服务端将对消息生产者即生产者集群中任一生产者实例发起消息回查。</p></li><li><p>生产者收到消息回查后，需要检查对应消息的本地事务执行的最终结果。</p></li><li><p>生产者根据检查到的本地事务的最终状态再次提交二次确认，服务端仍按照步骤4对半事务消息进行处理。</p></li></ol><h2 id="事务消息生命周期"><a href="#事务消息生命周期" class="headerlink" title="事务消息生命周期"></a>事务消息生命周期</h2><h3 id="1-初始化"><a href="#1-初始化" class="headerlink" title="1. 初始化"></a>1. 初始化</h3><p>半事务消息被生产者构建并完成初始化，待发送到服务端的状态。</p><h3 id="2-事务待提交"><a href="#2-事务待提交" class="headerlink" title="2. 事务待提交"></a>2. 事务待提交</h3><p>半事务消息被发送到服务端，和普通消息不同，并不会直接被服务端持久化，而是会被单独存储到事务存储系统中，等待第二阶段本地事务返回执行结果后再提交。此时消息对下游消费者不可见。</p><h3 id="3-消息回滚"><a href="#3-消息回滚" class="headerlink" title="3. 消息回滚"></a>3. 消息回滚</h3><p>第二阶段如果事务执行结果明确为回滚，服务端会将半事务消息回滚，该事务消息流程终止。</p><h3 id="4-提交待消费"><a href="#4-提交待消费" class="headerlink" title="4. 提交待消费"></a>4. 提交待消费</h3><p>第二阶段如果事务执行结果明确为提交，服务端会将半事务消息重新存储到普通存储系统中，此时消息对下游消费者可见，等待被消费者获取并消费。</p><h3 id="5-消费中"><a href="#5-消费中" class="headerlink" title="5. 消费中"></a>5. 消费中</h3><p>消息被消费者获取，并按照消费者本地的业务逻辑进行处理的过程。</p><p>此时服务端会等待消费者完成消费并提交消费结果，如果一定时间后没有收到消费者的响应，消息队列会对消息进行重试处理。</p><h3 id="6-消费提交"><a href="#6-消费提交" class="headerlink" title="6. 消费提交"></a>6. 消费提交</h3><p>消费者完成消费处理，并向服务端提交消费结果，服务端标记当前消息已经被处理（包括消费成功和失败）。</p><p>消息队列默认支持保留所有消息，此时消息数据并不会立即被删除，只是逻辑标记已消费。消息在保存时间到期或存储空间不足被删除前，消费者仍然可以回溯消息重新消费。</p><h3 id="7-消息删除"><a href="#7-消息删除" class="headerlink" title="7. 消息删除"></a>7. 消息删除</h3><p>消息队列按照消息保存机制滚动清理最早的消息数据，将消息从物理文件中删除</p><h2 id="使用限制"><a href="#使用限制" class="headerlink" title="使用限制"></a>使用限制</h2><h3 id="1-消息类型一致性"><a href="#1-消息类型一致性" class="headerlink" title="1. 消息类型一致性"></a>1. 消息类型一致性</h3><p>事务消息仅支持在MessageType为Transaction的主题内使用，即事务消息只能发送至类型为事务消息的主题中，发送的消息的类型必须和主题的类型一致。</p><h3 id="2-消费事务性"><a href="#2-消费事务性" class="headerlink" title="2. 消费事务性"></a>2. 消费事务性</h3><p>消息队列事务消息保证本地主分支事务和下游消息发送事务的一致性，但不保证消息消费结果和上游事务的一致性。因此需要下游业务分支自行保证消息正确处理，建议消费端做好消费重试，如果有短暂失败可以利用重试机制保证最终处理成功。</p><h3 id="3-中间状态可见性"><a href="#3-中间状态可见性" class="headerlink" title="3. 中间状态可见性"></a>3. 中间状态可见性</h3><p>消息队列事务消息为最终一致性，即在消息提交到下游消费端处理完成之前，下游分支和上游事务之间的状态会不一致。因此，事务消息仅适合接受异步执行的事务场景。</p><h3 id="3-事务超时机制"><a href="#3-事务超时机制" class="headerlink" title="3. 事务超时机制"></a>3. 事务超时机制</h3><p>消息队列事务消息的生命周期存在超时机制，即半事务消息被生产者发送服务端后，如果在指定时间内服务端无法确认提交或者回滚状态，则消息默认会被回滚。事务超时时间，请参见参数限制。</p><h3 id="4-不支持多个sendReceipt"><a href="#4-不支持多个sendReceipt" class="headerlink" title="4. 不支持多个sendReceipt"></a>4. 不支持多个sendReceipt</h3><p>事务消息在一个事务中仅允许一个sendReceipt，不支持多个sendReceipt。</p>]]></content>
      
      
      <categories>
          
          <category> 消息队列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 消息队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LLM大模型量化格式对比</title>
      <link href="/posts/55387.html"/>
      <url>/posts/55387.html</url>
      
        <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>随着人工智能技术的快速发展，大型语言模型（LLM）已在自然语言处理、语音识别、图像识别等多个领域取得了显著的成果。然而，LLM的广泛应用也面临着一些挑战，如模型体积大、计算资源消耗高等问题。为了解决这些问题，模型量化技术应运而生。本文将对三种主流的LLM量化方法——GPTQ、GGUF和AWQ进行深度解析和对比。</p><h2 id="一、GPTQ：GPT模型的训练后量化"><a href="#一、GPTQ：GPT模型的训练后量化" class="headerlink" title="一、GPTQ：GPT模型的训练后量化"></a>一、GPTQ：GPT模型的训练后量化</h2><p>GPTQ是一种针对GPT模型训练后的量化方法。它通过对模型权重进行量化，将浮点数转换为低精度的定点数，从而减小模型体积和提高计算效率。GPTQ的优点在于它不需要对模型进行重训练，可以直接在预训练好的模型上进行量化，因此实现起来相对简单。然而，由于GPTQ是在模型训练后进行的量化，因此可能会引入一些量化误差，对模型的性能产生一定的影响。</p><h2 id="二、GGUF：GPT生成的统一格式"><a href="#二、GGUF：GPT生成的统一格式" class="headerlink" title="二、GGUF：GPT生成的统一格式"></a>二、GGUF：GPT生成的统一格式</h2><p>GGUF是一种针对GPT生成结果的压缩方法。它将GPT生成的文本进行压缩，以减小生成结果的存储和传输开销。GGUF采用了特殊的编码方式，对文本中的冗余信息进行去除，同时保持生成结果的完整性和可读性。GGUF的优点在于它可以有效地减小生成结果的体积，提高传输和存储效率。然而，由于GGUF是对生成结果进行压缩，因此可能会对生成结果的质量产生一定的影响。</p><h2 id="三、AWQ：激活感知的权重量化"><a href="#三、AWQ：激活感知的权重量化" class="headerlink" title="三、AWQ：激活感知的权重量化"></a>三、AWQ：激活感知的权重量化</h2><p>AWQ是一种面向LLM低比特权重量化的硬件友好方法。它基于激活感知的权重量化策略，通过观察激活而不是权重来搜索保护显著权重的最佳通道缩放。AWQ的优点在于它能够保留更多的模型信息，同时实现高效的权重量化。由于AWQ不依赖于任何反向传播或重构，因此可以很好地保留LLMs在不同领域和模态中的泛化能力，而不会过度拟合校准集。AWQ在各种语言建模和特定领域基准上优于现有工作，并在面向指令调整的LMs上实现了出色的量化性能。</p><h2 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h2><p>通过对GPTQ、GGUF和AWQ三种LLM量化方法的深度解析和对比，我们可以看到它们各自的优势和适用场景。在实际应用中，我们可以根据具体需求和场景来选择合适的量化方法。例如，对于需要快速部署和降低资源消耗的场景，GPTQ可能是一个不错的选择；而对于需要减小生成结果体积的场景，GGUF可能更加适用；对于追求更高性能和泛化能力的场景，AWQ可能是一个更好的选择。</p><p>此外，在实际应用中，我们还可以结合多种量化方法来进行模型优化。例如，可以先使用GPTQ对模型进行训练后量化，然后使用GGUF对生成结果进行压缩，最后使用AWQ对模型进行进一步的权重量化。这样可以充分利用各种量化方法的优势，实现更加高效的模型优化。</p><p>总之，随着LLM的广泛应用，模型量化技术将成为提高模型效率和降低资源消耗的关键技术。通过对GPTQ、GGUF和AWQ等主流量化方法的深入理解和实践应用，我们可以更好地应对LLM在实际应用中面临的挑战和问题。</p>]]></content>
      
      
      <categories>
          
          <category> LLM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 量化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL与PostgreSQL的区别</title>
      <link href="/posts/24954.html"/>
      <url>/posts/24954.html</url>
      
        <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>MySQL 和 PostgreSQL 都是广泛使用的开源关系型数据库管理系统，但它们在架构、功能、性能和使用场景等方面有许多不同之处。以下是它们的主要区别：</p><h2 id="1-基本概念与架构"><a href="#1-基本概念与架构" class="headerlink" title="1. 基本概念与架构"></a>1. 基本概念与架构</h2><h3 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL:"></a>MySQL:</h3><ul><li><p>由 Oracle 维护（之前是 Sun Microsystems），是一个广泛使用的开源关系型数据库。</p></li><li><p>支持多种存储引擎（如 InnoDB、MyISAM、MEMORY 等），可以根据需求选择不同的存储引擎。</p></li><li><p>默认存储引擎是 InnoDB，支持事务、外键、行级锁等。</p><h3 id="PostgreSQL"><a href="#PostgreSQL" class="headerlink" title="PostgreSQL:"></a>PostgreSQL:</h3></li><li><p>被称为“对象关系型数据库”，最初由加州大学伯克利分校开发，现由 PostgreSQL Global Development Group 维护。</p></li><li><p>完全符合 ACID（原子性、一致性、隔离性、持久性）事务模型。</p></li><li><p>默认支持 MVCC（多版本并发控制）机制，适合高并发环境。</p></li><li><p>原生支持 JSON 和其他 NoSQL 特性。</p><h2 id="2-标准与兼容性"><a href="#2-标准与兼容性" class="headerlink" title="2. 标准与兼容性"></a>2. 标准与兼容性</h2><h3 id="MySQL-1"><a href="#MySQL-1" class="headerlink" title="MySQL:"></a>MySQL:</h3></li><li><p>与 SQL 标准兼容性较弱，尽管它不断改进，但在一些 SQL 语法的实现上可能与标准有所偏离。</p></li><li><p>对于复杂查询和嵌套查询的支持不如 PostgreSQL 强大。</p><h3 id="PostgreSQL-1"><a href="#PostgreSQL-1" class="headerlink" title="PostgreSQL:"></a>PostgreSQL:</h3></li><li><p>强调 SQL 标准的兼容性，支持 ANSI SQL 的大部分功能。</p></li><li><p>在复杂查询、子查询、递归查询、窗口函数等方面有更强的能力。</p><h2 id="3-扩展性与定制"><a href="#3-扩展性与定制" class="headerlink" title="3. 扩展性与定制"></a>3. 扩展性与定制</h2><h3 id="MySQL-2"><a href="#MySQL-2" class="headerlink" title="MySQL:"></a>MySQL:</h3></li><li><p>支持插件架构，可以扩展存储引擎。</p></li><li><p>没有类似于 PostgreSQL 的内建扩展系统。</p><h3 id="PostgreSQL-2"><a href="#PostgreSQL-2" class="headerlink" title="PostgreSQL:"></a>PostgreSQL:</h3></li><li><p>非常注重扩展性，用户可以通过自定义类型、函数、操作符和存储过程来扩展数据库功能。</p></li><li><p>提供了强大的扩展支持（例如 PostGIS：用于空间数据扩展，pg_partman：用于分区扩展）。</p><h2 id="4-性能与优化"><a href="#4-性能与优化" class="headerlink" title="4. 性能与优化"></a>4. 性能与优化</h2><h3 id="MySQL-3"><a href="#MySQL-3" class="headerlink" title="MySQL:"></a>MySQL:</h3></li><li><p>一般来说，MySQL 在读取操作较多、简单查询的场景下表现更好。</p></li><li><p>对于一些低复杂度的应用场景，MySQL 的性能可能优于 PostgreSQL，尤其是在较少的数据变更操作时。</p><h3 id="PostgreSQL-3"><a href="#PostgreSQL-3" class="headerlink" title="PostgreSQL:"></a>PostgreSQL:</h3></li><li><p>在复杂查询、大规模数据操作、多表联合查询和事务管理上表现更优，尤其是对数据一致性和完整性的需求更高时。</p></li><li><p>支持表分区、并行查询等优化特性，适合高并发、高负载的应用。</p><h2 id="5-事务支持"><a href="#5-事务支持" class="headerlink" title="5. 事务支持"></a>5. 事务支持</h2><h3 id="MySQL-4"><a href="#MySQL-4" class="headerlink" title="MySQL:"></a>MySQL:</h3></li><li><p>默认存储引擎 InnoDB 支持 ACID 事务，但 MySQL 早期版本对事务的支持并不如 PostgreSQL 强大。</p></li><li><p>不支持像 PostgreSQL 那样的多版本并发控制（MVCC）机制，可能会出现锁竞争的问题。</p><h3 id="PostgreSQL-4"><a href="#PostgreSQL-4" class="headerlink" title="PostgreSQL:"></a>PostgreSQL:</h3></li><li><p>PostgreSQL 完全支持 ACID 事务，使用 MVCC 来保证高并发的情况下数据一致性。</p></li><li><p>更加适用于需要高数据一致性和复杂事务的应用。</p><h2 id="6-JSON-支持"><a href="#6-JSON-支持" class="headerlink" title="6. JSON 支持"></a>6. JSON 支持</h2><h3 id="MySQL-5"><a href="#MySQL-5" class="headerlink" title="MySQL:"></a>MySQL:</h3></li><li><p>从 5.7 版本开始支持 JSON 数据类型，但其 JSON 功能相对基础，主要是存储和查询功能。</p></li><li><p>主要通过 JSON 类型和相关函数进行操作。</p><h3 id="PostgreSQL-5"><a href="#PostgreSQL-5" class="headerlink" title="PostgreSQL:"></a>PostgreSQL:</h3></li><li><p>提供更强大的 JSON 支持，特别是 JSONB（二进制 JSON 格式）类型，支持更高效的 JSON 存储和查询操作。</p></li><li><p>可以直接对 JSON 数据进行操作、索引以及其他 SQL 查询。</p><h2 id="7-复制与高可用性"><a href="#7-复制与高可用性" class="headerlink" title="7. 复制与高可用性"></a>7. 复制与高可用性</h2><h3 id="MySQL-6"><a href="#MySQL-6" class="headerlink" title="MySQL:"></a>MySQL:</h3></li><li><p>支持主从复制（Master-Slave）、主主复制（Master-Master）等架构。</p></li><li><p>Group Replication 和 MySQL Cluster 提供了较为基础的高可用性和扩展性方案。</p><h3 id="PostgreSQL-6"><a href="#PostgreSQL-6" class="headerlink" title="PostgreSQL:"></a>PostgreSQL:</h3></li><li><p>支持流复制（Streaming Replication），提供同步和异步复制模式。</p></li><li><p>可以通过 Patroni、PgBouncer 等工具实现高可用性和负载均衡。</p><h2 id="8-社区与生态系统"><a href="#8-社区与生态系统" class="headerlink" title="8. 社区与生态系统"></a>8. 社区与生态系统</h2><h3 id="MySQL-7"><a href="#MySQL-7" class="headerlink" title="MySQL:"></a>MySQL:</h3></li><li><p>拥有较大的社区和成熟的技术支持（尤其是企业版由 Oracle 提供支持）。</p></li><li><p>在一些 Web 开发框架（如 LAMP）中被广泛使用。</p><h3 id="PostgreSQL-7"><a href="#PostgreSQL-7" class="headerlink" title="PostgreSQL:"></a>PostgreSQL:</h3></li><li><p>社区活跃，开源许可证下提供支持，尤其在金融、政府、学术等行业有广泛应用。</p></li><li><p>更注重数据完整性、可扩展性和标准遵循。</p><h2 id="9-适用场景"><a href="#9-适用场景" class="headerlink" title="9. 适用场景"></a>9. 适用场景</h2><h3 id="MySQL-8"><a href="#MySQL-8" class="headerlink" title="MySQL:"></a>MySQL:</h3></li><li><p>更适用于小型到中型的应用，尤其是要求高性能读操作，且对事务和数据完整性的需求相对较低的场景。</p></li><li><p>比如：Web 应用、博客系统、在线商店等。</p><h3 id="PostgreSQL-8"><a href="#PostgreSQL-8" class="headerlink" title="PostgreSQL:"></a>PostgreSQL:</h3></li><li><p>适用于需要复杂查询、数据一致性和完整性的场景。特别适合数据分析、大数据应用、企业级应用、金融和政府系统等。</p></li><li><p>适用于高并发、高事务量的应用。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><table><thead><tr><th>特性</th><th>MySQL</th><th>PostgreSQL</th></tr></thead><tbody><tr><td>兼容性</td><td>SQL 标准支持较弱</td><td>强烈遵循 SQL 标准</td></tr><tr><td>存储引擎</td><td>多存储引擎支持（InnoDB、MyISAM 等）</td><td>默认支持 MVCC 机制，存储引擎固定</td></tr><tr><td>性能</td><td>适合高并发读操作，简单查询性能较好</td><td>在复杂查询、事务处理和大数据量处理上性能更优</td></tr><tr><td>JSON</td><td>支持    支持 JSON 数据类型，功能简单</td><td>强大的 JSON 和 JSONB 支持</td></tr><tr><td>扩展性</td><td>插件式存储引擎，扩展性一般</td><td>强大的扩展性，支持自定义类型和函数</td></tr><tr><td>高可用性</td><td>支持复制，基础高可用方案</td><td>支持流复制和更复杂的高可用架构</td></tr><tr><td>事务支持</td><td>支持 ACID 事务，但事务隔离性较弱</td><td>强大的事务支持和 MVCC，适合高并发环境</td></tr></tbody></table></li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
            <tag> PostgreSQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>defer关键字</title>
      <link href="/posts/41147.html"/>
      <url>/posts/41147.html</url>
      
        <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>在 Go 语言中，defer 是一个非常强大的关键字，它能够在函数执行结束后，按逆序执行注册的延迟操作。defer 在许多场景中都能提高代码的可读性与健壮性，尤其是在需要清理资源或处理结束逻辑的情况下。本文将详细介绍 defer 的使用原理、工作机制以及最佳实践。</p><h2 id="1-defer-的基本语法"><a href="#1-defer-的基本语法" class="headerlink" title="1. defer 的基本语法"></a>1. defer 的基本语法</h2><p>defer 用于延迟函数调用，语法如下：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">defer</span> <span class="token function">functionCall</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>被 defer 修饰的函数会在当前函数执行完毕后被调用，且按照逆序（LIFO，后进先出）顺序执行。</p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token string">"fmt"</span><span class="token keyword">func</span> <span class="token function">testDefer</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"Start of function"</span><span class="token punctuation">)</span>    <span class="token keyword">defer</span> fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"Deferred: First"</span><span class="token punctuation">)</span>    <span class="token keyword">defer</span> fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"Deferred: Second"</span><span class="token punctuation">)</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"End of function"</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token function">testDefer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">Start of <span class="token keyword">function</span>End of <span class="token keyword">function</span>Deferred: SecondDeferred: First<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>从输出中可以看到，defer 语句注册的延迟函数在 testDefer 函数结束时按逆序执行。</p><h2 id="2-defer-的实际应用"><a href="#2-defer-的实际应用" class="headerlink" title="2. defer 的实际应用"></a>2. defer 的实际应用</h2><h3 id="资源清理"><a href="#资源清理" class="headerlink" title="资源清理"></a>资源清理</h3><p>defer 最常见的应用场景之一是资源清理，尤其是在涉及文件操作、数据库连接、网络连接等场景时。通过 defer，我们可以保证在函数结束时自动关闭资源，无论函数是正常返回还是因为错误提前退出。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">go</span><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token punctuation">(</span>    <span class="token string">"fmt"</span>    <span class="token string">"os"</span><span class="token punctuation">)</span><span class="token keyword">func</span> <span class="token function">readFile</span><span class="token punctuation">(</span>fileName <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 打开文件</span>    file<span class="token punctuation">,</span> err <span class="token operator">:=</span> os<span class="token punctuation">.</span><span class="token function">Open</span><span class="token punctuation">(</span>fileName<span class="token punctuation">)</span>    <span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>        fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"Error opening file:"</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span>        <span class="token keyword">return</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 确保文件在函数结束时关闭</span>    <span class="token keyword">defer</span> file<span class="token punctuation">.</span><span class="token function">Close</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token comment">// 文件读取操作</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"Reading file..."</span><span class="token punctuation">)</span>    <span class="token comment">// 假设我们做了一些读取操作</span><span class="token punctuation">&#125;</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token function">readFile</span><span class="token punctuation">(</span><span class="token string">"example.txt"</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在这个例子中，defer file.Close() 确保了无论函数执行过程中发生什么错误，文件都能被正确关闭。</p><h3 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h3><p>defer 也可以与错误处理结合使用，确保在发生错误时，进行必要的清理工作。例如，在多个步骤中可能会发生错误时，我们可以通过 defer 来确保清理逻辑的执行。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token string">"fmt"</span><span class="token keyword">func</span> <span class="token function">process</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">error</span> <span class="token punctuation">&#123;</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"Processing step 1"</span><span class="token punctuation">)</span>    <span class="token comment">// 模拟某些操作，可能会返回错误</span>    err <span class="token operator">:=</span> fmt<span class="token punctuation">.</span><span class="token function">Errorf</span><span class="token punctuation">(</span><span class="token string">"an error occurred in step 2"</span><span class="token punctuation">)</span>    <span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> err    <span class="token punctuation">&#125;</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"Processing step 2"</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> <span class="token boolean">nil</span><span class="token punctuation">&#125;</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> err <span class="token operator">:=</span> <span class="token function">process</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>        fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"Error: %v\n"</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在这里，defer 可以用于记录日志，或者在发生错误时确保清理步骤得到执行。</p><h3 id="互斥锁的释放"><a href="#互斥锁的释放" class="headerlink" title="互斥锁的释放"></a>互斥锁的释放</h3><p>在并发编程中，defer 也常用于确保在函数结束时释放互斥锁（sync.Mutex）。这种方式可以避免忘记释放锁，导致死锁。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token punctuation">(</span>    <span class="token string">"fmt"</span>    <span class="token string">"sync"</span><span class="token punctuation">)</span><span class="token keyword">var</span> mu sync<span class="token punctuation">.</span>Mutex<span class="token keyword">func</span> <span class="token function">criticalSection</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    mu<span class="token punctuation">.</span><span class="token function">Lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">defer</span> mu<span class="token punctuation">.</span><span class="token function">Unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment">// 确保在函数结束时释放锁</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"Inside critical section"</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token function">criticalSection</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在此例中，defer mu.Unlock() 确保了在 criticalSection 函数结束时，无论是正常返回还是发生异常，互斥锁都将被释放。</p><h2 id="3-性能注意事项"><a href="#3-性能注意事项" class="headerlink" title="3. 性能注意事项"></a>3. 性能注意事项</h2><h3 id="4-1-延迟执行的开销"><a href="#4-1-延迟执行的开销" class="headerlink" title="4.1 延迟执行的开销"></a>4.1 延迟执行的开销</h3><p>虽然 defer 是非常方便的，但它也带来了一些性能开销。每次调用 defer 时，Go 会将延迟执行的函数及其参数（如果有）压入栈中，执行时会进行一些额外的内存分配和函数调用。这对于高性能要求非常严格的应用来说，可能会是一个瓶颈。</p><p>性能对比</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token string">"fmt"</span><span class="token keyword">import</span> <span class="token string">"time"</span><span class="token keyword">func</span> <span class="token function">withDefer</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">defer</span> fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"Deferred function"</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token keyword">func</span> <span class="token function">withoutDefer</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"Direct function call"</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    start <span class="token operator">:=</span> time<span class="token punctuation">.</span><span class="token function">Now</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">1000000</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">&#123;</span>        <span class="token function">withDefer</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"Time with defer:"</span><span class="token punctuation">,</span> time<span class="token punctuation">.</span><span class="token function">Since</span><span class="token punctuation">(</span>start<span class="token punctuation">)</span><span class="token punctuation">)</span>    start <span class="token operator">=</span> time<span class="token punctuation">.</span><span class="token function">Now</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">1000000</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">&#123;</span>        <span class="token function">withoutDefer</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"Time without defer:"</span><span class="token punctuation">,</span> time<span class="token punctuation">.</span><span class="token function">Since</span><span class="token punctuation">(</span>start<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>对于需要频繁调用的代码，defer 可能会导致一定的性能损失，尤其是需要反复执行大量操作时。如果性能至关重要，可能需要避免不必要的 defer 调用。</p><h2 id="4-使用场景"><a href="#4-使用场景" class="headerlink" title="4. 使用场景"></a>4. 使用场景</h2><p>通常情况下，defer 在资源管理、错误处理和清理操作中非常有用，因为这些操作通常不会频繁执行，不会成为性能瓶颈。而对于需要高性能的计算密集型任务，最好避免使用 defer。</p><h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h2><ul><li>defer 是 Go 语言中非常强大且灵活的一个特性，它通过确保在函数退出时执行指定的代码，简化了资源管理、错误处理等任务。</li><li>虽然 defer 带来了一定的性能开销，但在大多数应用场景下，其带来的可读性和代码健壮性优势是显而易见的。</li><li>在编写代码时，可以考虑使用 defer 来确保资源的正确释放和逻辑的简洁清晰，尤其是在涉及文件操作、锁管理、网络连接等需要清理的场景。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> defer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RabbitMQ与Kafka的区别</title>
      <link href="/posts/47252.html"/>
      <url>/posts/47252.html</url>
      
        <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>Kafka 和 RabbitMQ 都是常用的消息队列中间件，但它们的设计理念、架构、性能以及使用场景有所不同</p><h2 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1. 基本概念"></a>1. 基本概念</h2><h3 id="Kafka："><a href="#Kafka：" class="headerlink" title="Kafka："></a>Kafka：</h3><ul><li><p>Kafka 是一个分布式流平台，主要用于高吞吐量的数据流处理。它设计初衷是处理大规模的实时数据流，支持持久化消息、流处理和日志管理。</p></li><li><p>Kafka 采用的是 发布-订阅模式，并通过 分区（Partition） 机制来扩展吞吐量和可用性。</p><h3 id="RabbitMQ："><a href="#RabbitMQ：" class="headerlink" title="RabbitMQ："></a>RabbitMQ：</h3></li><li><p>RabbitMQ 是一个 AMQP（Advanced Message Queuing Protocol）协议的消息中间件，主要用于消息的可靠传递。它支持多种消息传递模型（如点对点、发布-订阅等）。</p></li><li><p>RabbitMQ 通常用于 任务队列 或 点对点 的消息传递，具有较高的可靠性和消息确认机制。</p><h2 id="2-架构和消息模型"><a href="#2-架构和消息模型" class="headerlink" title="2. 架构和消息模型"></a>2. 架构和消息模型</h2><h3 id="Kafka：-1"><a href="#Kafka：-1" class="headerlink" title="Kafka："></a>Kafka：</h3></li><li><p>Kafka 的核心概念包括 Producer（生产者）、Consumer（消费者）、Topic（主题）和 Partition（分区）。消息被发布到 Topic，并分布在多个 Partition 上，消费者可以订阅特定的 Topic，消费消息。</p></li><li><p>Kafka 设计成一个 日志系统，消息按顺序存储，并且持久化到磁盘。每个消费者都可以独立消费消息，消息可以重复消费。Kafka 支持 消费者组（Consumer Group），每个消费者组中的消费者负责消费不同的分区。</p></li><li><p>消息存储是顺序的，存储时间较长，允许回溯消费（消费者可以从任意位置开始读取消息）。</p><h3 id="RabbitMQ：-1"><a href="#RabbitMQ：-1" class="headerlink" title="RabbitMQ："></a>RabbitMQ：</h3></li><li><p>RabbitMQ 使用 AMQP 协议，支持 消息队列，它的消息传递模式主要有：点对点（Queue）和 发布-订阅（Exchange）。</p></li><li><p>RabbitMQ 的消息存储通常是 瞬时 的，并不长时间持久化。消息在消费者消费后会被删除，除非消费者显式地确认消息。<br>它依赖于 Exchange（交换机）来路由消息到 Queue（队列），支持多种路由策略（Direct, Fanout, Topic 等）。</p></li><li><p>RabbitMQ 的消息模式是 一次性消费的，不支持类似 Kafka 的消息回溯功能。</p><h2 id="3-性能和吞吐量"><a href="#3-性能和吞吐量" class="headerlink" title="3. 性能和吞吐量"></a>3. 性能和吞吐量</h2><h3 id="Kafka：-2"><a href="#Kafka：-2" class="headerlink" title="Kafka："></a>Kafka：</h3></li><li><p>Kafka 设计的目标是 高吞吐量，可以每秒处理大量消息。它通过顺序写入磁盘来提高性能，并且其分布式架构支持高效的水平扩展。</p></li><li><p>Kafka 在 写入速度 和 大规模并发消费 上表现非常好，适合处理高频繁的消息传递和数据流处理。</p></li><li><p>Kafka 的延迟较低，但通常相对于 RabbitMQ 处理单条消息的延迟较高。</p><h3 id="RabbitMQ：-2"><a href="#RabbitMQ：-2" class="headerlink" title="RabbitMQ："></a>RabbitMQ：</h3></li><li><p>RabbitMQ 的性能相对较低，特别是在处理高吞吐量的场景中，但它非常适合用作 任务队列 和对 消息可靠性 有较高要求的场景。</p></li><li><p>RabbitMQ 更侧重于消息的 可靠传递，每条消息的处理都保证被成功投递给消费者，支持 消息确认 和 重试机制。</p><h2 id="4-消息持久化"><a href="#4-消息持久化" class="headerlink" title="4. 消息持久化"></a>4. 消息持久化</h2><h3 id="Kafka：-3"><a href="#Kafka：-3" class="headerlink" title="Kafka："></a>Kafka：</h3></li><li><p>Kafka 是 持久化的，消息会存储在磁盘上，可以长时间保留。即使消费者消费了消息，消息仍然会存在一段时间，可以被其他消费者消费。</p></li><li><p>Kafka 允许设置消息的 过期时间（Retention Policy），如果消息在一定时间内没有被消费，它会被清除。</p><h3 id="RabbitMQ：-3"><a href="#RabbitMQ：-3" class="headerlink" title="RabbitMQ："></a>RabbitMQ：</h3></li><li><p>RabbitMQ 支持 消息持久化，但默认情况下，消息是 非持久的，即如果 RabbitMQ 服务崩溃，消息会丢失。为了保证消息持久性，需要设置队列和消息为持久化。</p></li><li><p>RabbitMQ 的消息持久化需要额外的磁盘 I/O 操作，影响性能。</p><h2 id="5-消息确认机制"><a href="#5-消息确认机制" class="headerlink" title="5. 消息确认机制"></a>5. 消息确认机制</h2><h3 id="Kafka：-4"><a href="#Kafka：-4" class="headerlink" title="Kafka："></a>Kafka：</h3></li><li><p>Kafka 不会在消息被消费者成功消费后进行确认，它依赖于消费者手动提交 offset（位移）。消费者可以决定从哪个 offset 开始消费，支持 重复消费。</p></li><li><p>Kafka 的设计偏向于日志记录和流处理，允许消费者按照任意顺序读取消息。</p><h3 id="RabbitMQ：-4"><a href="#RabbitMQ：-4" class="headerlink" title="RabbitMQ："></a>RabbitMQ：</h3></li><li><p>RabbitMQ 提供 消息确认（acknowledgment）机制，消费者消费完消息后需要显式确认（ack），以防消息丢失。如果消费者没有确认消息，RabbitMQ 会将其重新投递给其他消费者。</p></li><li><p>这种机制确保了消息的可靠性，适用于任务队列和要求高可靠性的场景。</p><h2 id="6-分布式和高可用性"><a href="#6-分布式和高可用性" class="headerlink" title="6. 分布式和高可用性"></a>6. 分布式和高可用性</h2><h3 id="Kafka：-5"><a href="#Kafka：-5" class="headerlink" title="Kafka："></a>Kafka：</h3></li><li><p>Kafka 是设计为 分布式系统，每个 Kafka 集群由多个 broker 组成，消息会被分布在不同的分区（partition）上，每个分区可以有多个副本。</p></li><li><p>Kafka 的 分区机制和 副本机制确保了系统的高可用性和容错性。</p><h3 id="RabbitMQ：-5"><a href="#RabbitMQ：-5" class="headerlink" title="RabbitMQ："></a>RabbitMQ：</h3></li><li><p>RabbitMQ 也支持分布式部署，通过 集群和 镜像队列机制来实现高可用性。镜像队列会在多个节点间复制队列的数据，以保证消息的可靠性。</p></li><li><p>虽然支持集群和高可用性，但相比 Kafka，RabbitMQ 的分布式特性相对较复杂，并且在高吞吐量场景下，扩展性较差。</p><h2 id="7-使用场景"><a href="#7-使用场景" class="headerlink" title="7. 使用场景"></a>7. 使用场景</h2><h3 id="Kafka：-6"><a href="#Kafka：-6" class="headerlink" title="Kafka："></a>Kafka：</h3></li><li><p>适用于 日志采集、数据流处理、实时分析、大数据应用等高吞吐量和高可扩展性的场景。</p></li><li><p>用于处理大量数据流和需要持久化的消息场景，比如 监控日志、事件流处理、实时数据处理、数据管道等。</p><h3 id="RabbitMQ：-6"><a href="#RabbitMQ：-6" class="headerlink" title="RabbitMQ："></a>RabbitMQ：</h3></li><li><p>适用于需要 高可靠性、任务队列和对消息 顺序性要求较高 的场景。通常用于 点对点消息传递、任务调度、分布式应用、请求-响应 等场景。</p></li><li><p>abbitMQ 更适合需要消息确认和重试机制的场景，比如 异步处理任务、工作队列等。</p><h2 id="8-总结对比"><a href="#8-总结对比" class="headerlink" title="8. 总结对比"></a>8. 总结对比</h2><table><thead><tr><th>特性</th><th>Kafka</th><th>RabbitMQ</th></tr></thead><tbody><tr><td>协议</td><td>自定义协议（基于 TCP）</td><td>AMQP（高级消息队列协议）</td></tr><tr><td>架构</td><td>分布式、高吞吐量、日志存储</td><td>集群模式、消息队列</td></tr><tr><td>消息模型</td><td>发布-订阅、顺序存储</td><td>点对点、发布-订阅、任务队列</td></tr><tr><td>性能</td><td>高吞吐量、低延迟（适合流式处理）</td><td>中等吞吐量，适合任务队列和消息确认</td></tr><tr><td>消息持久化</td><td>支持持久化，但偏向日志存储</td><td>支持持久化，消息消费后删除（默认）</td></tr><tr><td>消费确认</td><td>手动提交 offset，允许重复消费</td><td>消费者确认消息，保证消息可靠传递</td></tr><tr><td>分布式扩展性</td><td>强，支持分区、副本</td><td>支持集群和镜像队列，扩展性有限</td></tr><tr><td>使用场景</td><td>大数据流、实时数据处理、日志收集</td><td>任务队列、异步任务、分布式系统消息</td></tr></tbody></table><h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2></li><li><p>Kafka 适合高吞吐量、大规模数据流、实时分析和日志系统，具有较强的扩展性和高可用性。</p></li><li><p>RabbitMQ 适合低延迟、消息可靠传递、任务队列等场景，尤其在保证消息传递的可靠性和顺序性方面表现优异。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 消息队列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RabbitMQ </tag>
            
            <tag> Kafka </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ElasticSearch与MongoDB的区别</title>
      <link href="/posts/38842.html"/>
      <url>/posts/38842.html</url>
      
        <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>在面试中，经常被问到 Elasticsearch（ES） 和 MongoDB 的区别，现在总结一下，主要是从它们的功能、架构、使用场景等方面进行区分。以下是两者的主要区别：</p><h2 id="1-基本概念和用途"><a href="#1-基本概念和用途" class="headerlink" title="1. 基本概念和用途"></a>1. 基本概念和用途</h2><h3 id="Elasticsearch-ES-："><a href="#Elasticsearch-ES-：" class="headerlink" title="Elasticsearch (ES)："></a>Elasticsearch (ES)：</h3><ul><li><p>用途：Elasticsearch 是一个基于 Lucene 的分布式搜索引擎，主要用于 全文搜索、实时分析、日志管理、数据索引等场景。它能够高效地处理大量的数据并支持复杂的查询、分析和过滤。</p></li><li><p>核心功能：高效的 搜索和分析，尤其擅长处理大规模的文本数据，并且支持近实时（NRT）查询。</p><h3 id="MongoDB："><a href="#MongoDB：" class="headerlink" title="MongoDB："></a>MongoDB：</h3></li><li><p>用途：MongoDB 是一个 NoSQL 数据库，以 文档存储为基础，支持 JSON 风格的文档（BSON 格式）。它适用于 快速开发、灵活的数据模型，并且能够存储结构化和非结构化的数据。</p></li><li><p>核心功能：灵活的 文档存储，支持复杂的数据结构（如嵌套文档、数组等），具有横向扩展性，适用于快速增长的数据存储和处理。</p><h2 id="2-数据存储和结构"><a href="#2-数据存储和结构" class="headerlink" title="2. 数据存储和结构"></a>2. 数据存储和结构</h2><h3 id="Elasticsearch："><a href="#Elasticsearch：" class="headerlink" title="Elasticsearch："></a>Elasticsearch：</h3></li><li><p>数据存储：基于 倒排索引（Inverted Index），用于高效的文本检索。每条文档都有一个 索引，通过该索引快速查询特定字段的内容。</p></li><li><p>数据结构：存储数据的基本单位是 文档，文档通常是 JSON 格式。</p><h3 id="MongoDB：-1"><a href="#MongoDB：-1" class="headerlink" title="MongoDB："></a>MongoDB：</h3></li><li><p>数据存储：基于 BSON（Binary JSON）格式，数据存储为 文档。它支持复杂的数据结构，允许嵌套文档和数组，具有灵活的模式（Schema-less）。</p></li><li><p>数据结构：MongoDB 中的基本单位是 文档，文档类似于 JSON 对象。</p><h2 id="3-查询和检索"><a href="#3-查询和检索" class="headerlink" title="3. 查询和检索"></a>3. 查询和检索</h2><h3 id="Elasticsearch：-1"><a href="#Elasticsearch：-1" class="headerlink" title="Elasticsearch："></a>Elasticsearch：</h3></li><li><p>主要用于 全文搜索、关键词匹配、复杂的过滤和聚合。它提供了强大的 查询 DSL（Domain Specific Language），通过结构化和非结构化的查询，支持全文检索、模糊查询、范围查询等。</p></li><li><p>可以进行 复杂的分析，如聚合分析（Aggregation），支持实时数据检索。</p><h3 id="MongoDB：-2"><a href="#MongoDB：-2" class="headerlink" title="MongoDB："></a>MongoDB：</h3></li><li><p>主要支持 CRUD 操作（创建、读取、更新、删除）。查询方式较为灵活，支持索引、聚合框架等，但在 全文搜索、复杂查询和 实时分析 方面，MongoDB 不如 Elasticsearch 强大。</p></li><li><p>支持基于字段的 查询和过滤，也支持 聚合 操作（类似 SQL 的 GROUP BY，可以用于数据的复杂处理和统计分析）。</p><h2 id="4-可扩展性"><a href="#4-可扩展性" class="headerlink" title="4. 可扩展性"></a>4. 可扩展性</h2><h3 id="Elasticsearch：-2"><a href="#Elasticsearch：-2" class="headerlink" title="Elasticsearch："></a>Elasticsearch：</h3></li><li><p>天生是 分布式系统，支持 横向扩展（scaling out）。它通过 分片（Shard） 和 副本（Replica） 机制分布数据，并支持自动化的负载均衡和数据分布。</p></li><li><p>它的分布式架构使得 Elasticsearch 非常适合大规模的数据存储和快速搜索，尤其是在需要高吞吐量和低延迟的场景中。</p><h3 id="MongoDB：-3"><a href="#MongoDB：-3" class="headerlink" title="MongoDB："></a>MongoDB：</h3></li><li><p>也支持 横向扩展，采用分片技术来分配数据到多个节点。MongoDB 的 副本集（Replica Set） 机制提供了高可用性和数据冗余。</p></li><li><p>在大规模数据的 写入和存储 上也有良好的扩展能力。</p><h2 id="5-索引和性能"><a href="#5-索引和性能" class="headerlink" title="5. 索引和性能"></a>5. 索引和性能</h2><h3 id="Elasticsearch：-3"><a href="#Elasticsearch：-3" class="headerlink" title="Elasticsearch："></a>Elasticsearch：</h3></li><li><p>提供了非常强大的 索引机制，使得查询性能极为高效，尤其在进行复杂的文本检索时表现优秀。</p></li><li><p>由于 Elasticsearch 的核心是基于倒排索引的，所以在进行 全文检索 和 模糊匹配 时，性能非常好。</p><h3 id="MongoDB：-4"><a href="#MongoDB：-4" class="headerlink" title="MongoDB："></a>MongoDB：</h3></li><li><p>支持通过 索引 来提高查询性能，但是不如 Elasticsearch 在 全文搜索 上表现突出。MongoDB 支持 单字段索引、复合索引、地理空间索引等。</p></li><li><p>对于大规模数据存储和简单的查询来说，MongoDB 表现出色，但在需要复杂检索和大规模数据分析时，可能没有 Elasticsearch 快速。</p><h2 id="6-使用场景"><a href="#6-使用场景" class="headerlink" title="6. 使用场景"></a>6. 使用场景</h2><h3 id="Elasticsearch：-4"><a href="#Elasticsearch：-4" class="headerlink" title="Elasticsearch："></a>Elasticsearch：</h3></li><li><p>适用于 全文搜索、日志管理（如 ELK 堆栈：Elasticsearch, Logstash, Kibana）、实时数据分析、网站搜索引擎、数据索引和查询等。</p></li><li><p>常见的应用场景包括：日志聚合（如 ELK Stack）、电商网站的商品搜索、社交媒体的数据分析、全文检索服务等。</p><h3 id="MongoDB：-5"><a href="#MongoDB：-5" class="headerlink" title="MongoDB："></a>MongoDB：</h3></li><li><p>适用于 灵活的数据存储、快速开发、非结构化数据存储等。特别是在开发需要频繁变更数据模型的应用时，MongoDB 的 灵活性 是其一大优势。</p></li><li><p>常见的应用场景包括：内容管理系统（CMS）、用户数据存储、物联网数据存储、社交网络应用等。</p><h2 id="7-事务支持"><a href="#7-事务支持" class="headerlink" title="7. 事务支持"></a>7. 事务支持</h2><h3 id="Elasticsearch：-5"><a href="#Elasticsearch：-5" class="headerlink" title="Elasticsearch："></a>Elasticsearch：</h3></li><li><p>Elasticsearch 在分布式环境中 不完全支持事务，主要关注高吞吐量和搜索的速度。</p></li><li><p>在多文档操作时，不保证原子性和一致性。</p><h3 id="MongoDB：-6"><a href="#MongoDB：-6" class="headerlink" title="MongoDB："></a>MongoDB：</h3></li><li><p>支持 ACID 事务，在单个文档以及跨多个文档、集合的操作中，能够保证数据的原子性、一致性、隔离性和持久性。</p></li><li><p>自 MongoDB 4.0 版本起，MongoDB 增加了对多文档的事务支持。</p><h2 id="8-总结："><a href="#8-总结：" class="headerlink" title="8. 总结："></a>8. 总结：</h2><table><thead><tr><th>特性</th><th>Elasticsearch</th><th>MongoDB</th></tr></thead><tbody><tr><td>主要用途</td><td>实时全文搜索和分析</td><td>文档存储和管理</td></tr><tr><td>数据模型</td><td>JSON 文档，倒排索引</td><td>BSON 文档，灵活模式</td></tr><tr><td>查询语言</td><td>自定义查询 DSL，支持全文检索</td><td>基于 BSON 的查询，支持聚合</td></tr><tr><td>索引机制</td><td>强大的倒排索引</td><td>支持多种索引类型（单字段、复合、地理空间等）</td></tr><tr><td>分布式特性</td><td>天生分布式，支持分片和副本</td><td>分片和副本集，支持水平扩展</td></tr><tr><td>扩展性</td><td>高度扩展，适合大数据量搜索</td><td>横向扩展，适合海量数据存储</td></tr><tr><td>事务支持</td><td>不支持事务</td><td>支持 ACID 事务（从 4.0 版本起）</td></tr><tr><td>适用场景</td><td>搜索引擎、日志分析、实时数据处理</td><td>动态数据模型、快速开发、灵活存储</td></tr></tbody></table></li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ElasticSearch </tag>
            
            <tag> MongoDB </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>跳表实现</title>
      <link href="/posts/54160.html"/>
      <url>/posts/54160.html</url>
      
        <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>有这么一道比较有意思的面试题：“Redis 的有序集合底层为什么要用跳表”</p><h2 id="Redis-的有序集合"><a href="#Redis-的有序集合" class="headerlink" title="Redis 的有序集合"></a>Redis 的有序集合</h2><p>Redis 有个比较常用的数据结构叫有序集合(sorted set，简称 zset)，正如其名它是一个可以保证有序且元素唯一的集合，所以它经常用于排行榜等需要进行统计排列的场景。</p><p>因为设计者考虑到 Redis 数据存放于内存，为了节约宝贵的内存空间，在有序集合元素小于 64 字节且个数小于 128 的时候，会使用 ziplist，而这个阈值的默认值的设置就来自下面这两个配置项。</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">zset-max-ziplist-value <span class="token number">64</span>zset-max-ziplist-entries <span class="token number">128</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>一旦有序集合中的某个元素超出这两个其中的一个阈值它就会转为 skiplist（实际是 dict+skiplist，还会借用字典来提高获取指定元素的效率）。</p><p>也就是说，ZSet 有两种不同的实现，分别是 ziplist 和 skiplist，具体使用哪种结构进行存储的规则如下：</p><ul><li>当有序集合对象同时满足以下两个条件时，使用 ziplist： <ul><li>ZSet 保存的键值对数量少于 128 个；</li><li>每个元素的长度小于 64 字节。</li></ul></li><li>如果不满足上述两个条件，那么使用 skiplist</li></ul><h2 id="跳表"><a href="#跳表" class="headerlink" title="跳表"></a>跳表</h2><p>有序链表在添加、查询、删除的平均时间复杂都都是 O(n) 即线性增长，所以一旦节点数量达到一定体量后其性能表现就会非常差劲。而跳表我们完全可以理解为在原始链表基础上，建立多级索引，通过多级索引检索定位将增删改查的时间复杂度变为 O(log n) 。可能这里说的有些抽象，我们举个例子，以下图跳表为例，其原始链表存储按序存储 1-10，有 2 级索引，每级索引的索引个数都是基于下层元素个数的一半。<br><img src="/img/20241221225508.png"></p><h2 id="查询节点"><a href="#查询节点" class="headerlink" title="查询节点"></a>查询节点</h2><p>假如我们需要查询元素 6，其工作流程如下：</p><ul><li>从 2 级索引开始，先来到节点 4。</li><li>查看 4 的后继节点，是 8 的 2 级索引，这个值大于 6，说明 2 级索引后续的索引都是大于 6 的，没有再往后搜寻的必要</li><li>我们索引向下查找。来到 4 的 1 级索引，比对其后继节点为 6，查找结束。</li></ul><p>相较于原始有序链表需要 6 次，我们的跳表通过建立多级索引，我们只需两次就直接定位到了目标元素，其查寻的复杂度被直接优化为O(log n)。</p><h2 id="添加节点"><a href="#添加节点" class="headerlink" title="添加节点"></a>添加节点</h2><p>假如我们需要在这个有序集合中添加一个元素 7，那么我们就需要通过跳表找到小于元素 7 的最大值，也就是元素 6 的位置，将其插入到元素 6 的后面，让元素 6 的索引指向新插入的节点 7，其工作流程如下：</p><ul><li>从 2 级索引开始定位到了元素 4 的索引。</li><li>查看索引 4 的后继索引为 8，索引向下推进。</li><li>来到 1 级索引，发现索引 4 后继索引为 6，小于插入元素 7，指针推进到索引 6 位置。- 继续比较 6 的后继节点为索引 8，大于元素 7，索引继续向下。</li><li>最终我们来到 6 的原始节点，发现其后继节点为 7，指针没有继续向下的空间，自此我们可知元素 6 就是小于插入元素 7 的最大值，于是便将元素 7 插入。</li></ul><h2 id="索引高度"><a href="#索引高度" class="headerlink" title="索引高度"></a>索引高度</h2><p>理想情况是每一层索引是下一层元素个数的二分之一，所以假设元素个数为 n，那么对应 k 层索引的元素个数 r 计算公式为: r=n/2^k</p><p>而 Redis 又是内存数据库，我们假设元素最大个数是65536，我们把65536代入上述公式可知最大高度为 16。所以我们建议添加一个元素后为其建立的索引高度不超过 16。</p><p>因为我们要求尽可能保证每一个上级索引都是下级索引的一半，在实现高度生成算法时，我们可以这样设计：</p><ul><li>跳表的高度计算从原始链表开始，即默认情况下插入的元素的高度为 1，代表没有索引，只有元素节点。</li><li>设计一个为插入元素生成节点索引高度 level 的方法。</li><li>进行一次随机运算，随机数值范围为 0-1 之间。</li><li>如果随机数大于 0.5 则为当前元素添加一级索引，自此我们保证生成一级索引的概率为 50% ，这也就保证了 1 级索引理想情况下只有一半的元素会生成索引。</li><li>同理后续每次随机算法得到的值大于 0.5 时，我们的索引高度就加 1，这样就可以保证节点生成的 2 级索引概率为 25% ，3 级索引为 12.5% ……</li></ul><h2 id="删除节点"><a href="#删除节点" class="headerlink" title="删除节点"></a>删除节点</h2><p>假设我们这里要删除元素 10，我们必须定位到当前跳表各层元素小于 10 的最大值，索引执行步骤为：</p><ul><li>2 级索引 4 的后继节点为 8，指针推进。</li><li>索引 8 无后继节点，该层无要删除的元素，指针直接向下。</li><li>1 级索引 8 后继节点为 10，说明 1 级索引 8 在进行删除时需要将自己的指针和 1 级索引 10 断开联系，将 10 删除。</li><li>1 级索引完成定位后，指针向下，后继节点为 9，指针推进。</li><li>9 的后继节点为 10，同理需要让其指向 null，将 10 删除。</li></ul><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">public class SkipList &#123;    &#x2F;**     * 跳表索引最大高度为16     *&#x2F;    private static final int MAX_LEVEL &#x3D; 16;    &#x2F;**     * 每个节点添加一层索引高度的概率为二分之一     *&#x2F;    private static final float PROB &#x3D; 0.5 f;    &#x2F;**     * 默认情况下的高度为1，即只有自己一个节点     *&#x2F;    private int levelCount &#x3D; 1;    &#x2F;**     * 跳表最底层的节点，即头节点     *&#x2F;    private Node h &#x3D; new Node();    public SkipList() &#123;&#125;    public class Node &#123;        private int data &#x3D; -1;        &#x2F;**         *         *&#x2F;        private Node[] forwards &#x3D; new Node[MAX_LEVEL];        private int maxLevel &#x3D; 0;        @Override        public String toString() &#123;            return &quot;Node&#123;&quot; +                &quot;data&#x3D;&quot; + data +                &quot;, maxLevel&#x3D;&quot; + maxLevel +                &#39;&#125;&#39;;        &#125;    &#125;    public void add(int value) &#123;        &#x2F;&#x2F;随机生成高度        int level &#x3D; randomLevel();        Node newNode &#x3D; new Node();        newNode.data &#x3D; value;        newNode.maxLevel &#x3D; level;        &#x2F;&#x2F;创建一个node数组，用于记录小于当前value的最大值        Node[] maxOfMinArr &#x3D; new Node[level];        &#x2F;&#x2F;默认情况下指向头节点        for (int i &#x3D; 0; i &lt; level; i++) &#123;            maxOfMinArr[i] &#x3D; h;        &#125;        &#x2F;&#x2F;基于上述结果拿到当前节点的后继节点        Node p &#x3D; h;        for (int i &#x3D; level - 1; i &gt;&#x3D; 0; i--) &#123;            while (p.forwards[i] !&#x3D; null &amp;&amp; p.forwards[i].data &lt; value) &#123;                p &#x3D; p.forwards[i];            &#125;            maxOfMinArr[i] &#x3D; p;        &#125;        &#x2F;&#x2F;更新前驱节点的后继节点为当前节点newNode        for (int i &#x3D; 0; i &lt; level; i++) &#123;            newNode.forwards[i] &#x3D; maxOfMinArr[i].forwards[i];            maxOfMinArr[i].forwards[i] &#x3D; newNode;        &#125;        &#x2F;&#x2F;如果当前newNode高度大于跳表最高高度则更新levelCount        if (levelCount &lt; level) &#123;            levelCount &#x3D; level;        &#125;    &#125;    &#x2F;**     * 理论来讲，一级索引中元素个数应该占原始数据的 50%，二级索引中元素个数占 25%，三级索引12.5% ，一直到最顶层。     * 因为这里每一层的晋升概率是 50%。对于每一个新插入的节点，都需要调用 randomLevel 生成一个合理的层数。     * 该 randomLevel 方法会随机生成 1~MAX_LEVEL 之间的数，且 ：     * 50%的概率返回 1     * 25%的概率返回 2     *  12.5%的概率返回 3 ...     * @return     *&#x2F;    private int randomLevel() &#123;        int level &#x3D; 1;        while (Math.random() &gt; PROB &amp;&amp; level &lt; MAX_LEVEL) &#123;            ++level;        &#125;        return level;    &#125;    public Node get(int value) &#123;        Node p &#x3D; h;        &#x2F;&#x2F;找到小于value的最大值        for (int i &#x3D; levelCount - 1; i &gt;&#x3D; 0; i--) &#123;            while (p.forwards[i] !&#x3D; null &amp;&amp; p.forwards[i].data &lt; value) &#123;                p &#x3D; p.forwards[i];            &#125;        &#125;        &#x2F;&#x2F;如果p的前驱节点等于value则直接返回        if (p.forwards[0] !&#x3D; null &amp;&amp; p.forwards[0].data &#x3D;&#x3D; value) &#123;            return p.forwards[0];        &#125;        return null;    &#125;    &#x2F;**     * 删除     *     * @param value     *&#x2F;    public void delete(int value) &#123;        Node p &#x3D; h;        &#x2F;&#x2F;找到各级节点小于value的最大值        Node[] updateArr &#x3D; new Node[levelCount];        for (int i &#x3D; levelCount - 1; i &gt;&#x3D; 0; i--) &#123;            while (p.forwards[i] !&#x3D; null &amp;&amp; p.forwards[i].data &lt; value) &#123;                p &#x3D; p.forwards[i];            &#125;            updateArr[i] &#x3D; p;        &#125;        &#x2F;&#x2F;查看原始层节点前驱是否等于value，若等于则说明存在要删除的值        if (p.forwards[0] !&#x3D; null &amp;&amp; p.forwards[0].data &#x3D;&#x3D; value) &#123;            &#x2F;&#x2F;从最高级索引开始查看其前驱是否等于value，若等于则将当前节点指向value节点的后继节点            for (int i &#x3D; levelCount - 1; i &gt;&#x3D; 0; i--) &#123;                if (updateArr[i].forwards[i] !&#x3D; null &amp;&amp; updateArr[i].forwards[i].data &#x3D;&#x3D; value) &#123;                    updateArr[i].forwards[i] &#x3D; updateArr[i].forwards[i].forwards[i];                &#125;            &#125;        &#125;        &#x2F;&#x2F;从最高级开始查看是否有一级索引为空，若为空则层级减1        while (levelCount &gt; 1 &amp;&amp; h.forwards[levelCount - 1] &#x3D;&#x3D; null) &#123;            levelCount--;        &#125;    &#125;    public void printAll() &#123;        Node p &#x3D; h;        &#x2F;&#x2F;基于最底层的非索引层进行遍历，只要后继节点不为空，则速速出当前节点，并移动到后继节点        while (p.forwards[0] !&#x3D; null) &#123;            System.out.println(p.forwards[0]);            p &#x3D; p.forwards[0];        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用pytest对数据库进行校验</title>
      <link href="/posts/9468.html"/>
      <url>/posts/9468.html</url>
      
        <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><ul><li>业务中需要与其他方进行对接，对方提供数据</li><li>由于有异常的数据会对业务操作非常大的影响</li><li>需要将异常数据进行前置检查，未通过的数据不允许入库</li></ul><h2 id="pytest介绍"><a href="#pytest介绍" class="headerlink" title="pytest介绍"></a>pytest介绍</h2><ul><li><code>pytest</code> 是一个用于 <code>Python</code> 的测试框架,支持简单的单元测试和复杂的功能测试。它以其简单、易用、灵活的特点,受到了许<br>多开发者的青睐。</li><li><code>pytest</code> 框架可以轻松编写小型、可读的测试,并可以扩展支持应用程序和库的复杂功能测试</li><li><code>pytest</code> 官网：<a href="https://docs.pytest.org/en/8.2.x/">https://docs.pytest.org/en/8.2.x/</a></li></ul><h2 id="pytest特点"><a href="#pytest特点" class="headerlink" title="pytest特点"></a>pytest特点</h2><ol><li>简洁的语法:无需继承特定的测试类,只需使用简单的函数即可编写测试。</li><li>强大的断言:内置丰富的断言方法,提供详细的失败信息。</li><li>自动发现:自动发现测试文件和测试函数,无需显式地注册测试。</li><li>插件系统:丰富的插件生态系统,支持扩展和定制。</li></ol><h2 id="实践使用"><a href="#实践使用" class="headerlink" title="实践使用"></a>实践使用</h2><h3 id="1、安装引用"><a href="#1、安装引用" class="headerlink" title="1、安装引用"></a>1、安装引用</h3><p><code>requirements.txt</code> 文件</p><pre class="line-numbers language-none"><code class="language-none">psycopg2-binary&#x3D;&#x3D;2.9.9pytest&#x3D;&#x3D;8.2.1pytest-xdist&#x3D;&#x3D;3.6.1pytest-html&#x3D;&#x3D;4.1.1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">pip install -r requirements.txt -i https:&#x2F;&#x2F;pypi.tuna.tsinghua.edu.cn&#x2F;simple<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="2、建立数据库连接"><a href="#2、建立数据库连接" class="headerlink" title="2、建立数据库连接"></a>2、建立数据库连接</h3><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">import osimport pytestimport psycopg2pg_conf &#x3D; &#123;    &#39;host&#39;: os.getenv(&quot;PG_HOST&quot;, &#39;192.168.1.81&#39;) ,    &#39;port&#39;: os.getenv(&quot;PG_PORT&quot;, &#39;5432&#39;),    &#39;user&#39;: os.getenv(&quot;PG_USER&quot;, &#39;postgres&#39;),    &#39;password&#39;: os.getenv(&quot;PG_PASSWORD&quot;, &#39;postgres&#39;),    &#39;dbname&#39;: os.getenv(&quot;PG_DBNAME&quot;, &#39;postgres&#39;)&#125;@pytest.fixture(scope&#x3D;&quot;session&quot;)def db_conn():    conn &#x3D; psycopg2.connect(**pg_conf)    yield conn    conn.close()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3、编写测试用例"><a href="#3、编写测试用例" class="headerlink" title="3、编写测试用例"></a>3、编写测试用例</h3><p>可以建立一个tests的文件夹，专门存放测试用例的代码</p><pre class="line-numbers language-py" data-language="py"><code class="language-py">import pytestimport psycopg2class TestLicense():    def test_001(self, db_conn):        cur &#x3D; db_conn.cursor()        cur.execute(&quot;SELECT COUNT(*) FROM t_license_version&quot;)        count &#x3D; cur.fetchone()[0]        assert count &gt;&#x3D; 200, f&quot;assert &#123;count&#125; &gt;&#x3D; 200, 许可证数据量应大于 200&quot;        cur.close()        def test_002(self, db_conn):        cur &#x3D; db_conn.cursor()        cur.execute(&quot;SELECT COUNT(*) FROM t_license_version WHERE risk_level NOT IN (&#39;unknown&#39;,&#39;low&#39;,&#39;medium&#39;,&#39;high&#39;)&quot;)        count &#x3D; cur.fetchone()[0]        assert count &#x3D;&#x3D; 0, f&quot;assert &#123;count&#125; &#x3D;&#x3D; 0, 风险等级 risk_level 应包含 (&#39;unknown&#39;,&#39;low&#39;,&#39;medium&#39;,&#39;high&#39;)&quot;        cur.close()    def test_003(self, db_conn):        cur &#x3D; db_conn.cursor()        cur.execute(&quot;SELECT COUNT(*) FROM t_license_version WHERE conditions_use IS NULL&quot;)        count &#x3D; cur.fetchone()[0]        assert count &#x3D;&#x3D; 0, f&quot;assert &#123;count&#125; &#x3D;&#x3D; 0, 限制条件 conditions_use 不能为 NULL&quot;        cur.close()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4、运行测试"><a href="#4、运行测试" class="headerlink" title="4、运行测试"></a>4、运行测试</h3><pre class="line-numbers language-py" data-language="py"><code class="language-py">import pytestif __name__ &#x3D;&#x3D; &#39;__main__&#39;:    pytest.main([&#39;-n&#39;, &#39;auto&#39;, &#39;--html&#x3D;report.html&#39;, &#39;--self-contained-html&#39;])<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="5、运行测试"><a href="#5、运行测试" class="headerlink" title="5、运行测试"></a>5、运行测试</h3><pre class="line-numbers language-py" data-language="py"><code class="language-py">python main.py<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>运行完成后会在当前目录产生检测包括，是html格式的，可以在浏览器直接打开</p><h2 id="构建集成"><a href="#构建集成" class="headerlink" title="构建集成"></a>构建集成</h2><h3 id="1、docker运行"><a href="#1、docker运行" class="headerlink" title="1、docker运行"></a>1、docker运行</h3><ul><li>由于连接数据库需要在服务器上安装 <code>postgresql-client</code>，使用docker可以避开一些环境问题</li><li>方便集成到jk流水线上进行<code>CI/CD</code>实践</li></ul><h4 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h4><pre class="line-numbers language-docker" data-language="docker"><code class="language-docker"><span class="token instruction"><span class="token keyword">FROM</span> python:3.10-slim-buster</span><span class="token instruction"><span class="token keyword">WORKDIR</span> /app</span><span class="token instruction"><span class="token keyword">COPY</span> . /app</span><span class="token instruction"><span class="token keyword">RUN</span> echo <span class="token string">"deb https://mirrors.tuna.tsinghua.edu.cn/debian/ buster main non-free contrib"</span> > /etc/apt/sources.list &amp;&amp; <span class="token operator">\</span>    echo <span class="token string">"deb https://mirrors.tuna.tsinghua.edu.cn/debian/ buster-updates main non-free contrib"</span> >> /etc/apt/sources.list &amp;&amp; <span class="token operator">\</span>    echo <span class="token string">"deb https://mirrors.tuna.tsinghua.edu.cn/debian-security buster/updates main non-free contrib"</span> >> /etc/apt/sources.list &amp;&amp; <span class="token operator">\</span>    apt-get update &amp;&amp; <span class="token operator">\</span>    apt-get install -y postgresql-client &amp;&amp; <span class="token operator">\</span>    pip install --no-cache-dir -r requirements.txt -i https://pypi.tuna.tsinghua.edu.cn/simple</span><span class="token instruction"><span class="token keyword">CMD</span> [<span class="token string">"python3"</span>, <span class="token string">"main.py"</span>]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="构建使用"><a href="#构建使用" class="headerlink" title="构建使用"></a>构建使用</h4><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">docker build -t app-test:latest <span class="token builtin class-name">.</span>docker run --rm -it -e <span class="token assign-left variable">PG_HOST</span><span class="token operator">=</span><span class="token number">192.168</span>.1.81 -e <span class="token assign-left variable">PG_PORT</span><span class="token operator">=</span><span class="token number">5432</span> -e <span class="token assign-left variable">PG_USER</span><span class="token operator">=</span>postgres -e <span class="token assign-left variable">PG_PASSWORD</span><span class="token operator">=</span>xxxxxx -e <span class="token assign-left variable">PG_DBNAME</span><span class="token operator">=</span>postgres -v <span class="token variable"><span class="token variable">$(</span><span class="token builtin class-name">pwd</span><span class="token variable">)</span></span>:/app app-test:latest<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="2、增加-Makefile"><a href="#2、增加-Makefile" class="headerlink" title="2、增加 Makefile"></a>2、增加 <code>Makefile</code></h3><pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile">VENV_NAME<span class="token operator">?=</span>venvPYTHON<span class="token operator">=</span>python3VERSION<span class="token operator">?=</span>latestAPP_NAME<span class="token operator">=</span>app-test<span class="token symbol">dep</span><span class="token punctuation">:</span> venv<span class="token symbol">@pip install -r requirements.txt -i https</span><span class="token punctuation">:</span>//pypi.tuna.tsinghua.edu.cn/simple<span class="token symbol">venv</span><span class="token punctuation">:</span><span class="token variable">$</span><span class="token punctuation">&#123;</span>PYTHON<span class="token punctuation">&#125;</span> -m venv venvsource <span class="token variable">$</span><span class="token punctuation">(</span>VENV_NAME<span class="token punctuation">)</span>/bin/activate<span class="token symbol">test</span><span class="token punctuation">:</span> venv<span class="token variable">$</span><span class="token punctuation">&#123;</span>PYTHON<span class="token punctuation">&#125;</span> -m pytest<span class="token symbol">lint</span><span class="token punctuation">:</span> venv<span class="token variable">$</span><span class="token punctuation">&#123;</span>PYTHON<span class="token punctuation">&#125;</span> -m pylint<span class="token variable">$</span><span class="token punctuation">&#123;</span>PYTHON<span class="token punctuation">&#125;</span> -m mypy<span class="token symbol">run</span><span class="token punctuation">:</span> venv<span class="token variable">$</span><span class="token punctuation">&#123;</span>PYTHON<span class="token punctuation">&#125;</span> main.py<span class="token symbol">docker-build</span><span class="token punctuation">:</span><span class="token symbol">docker build -t <span class="token variable">$</span>&#123;APP_NAME&#125;</span><span class="token punctuation">:</span><span class="token variable">$</span><span class="token punctuation">&#123;</span>VERSION<span class="token punctuation">&#125;</span> .<span class="token symbol">docker-test</span><span class="token punctuation">:</span><span class="token symbol">docker run --rm -it -v <span class="token variable">$</span>(shell pwd)</span><span class="token punctuation">:</span>/app <span class="token variable">$</span><span class="token punctuation">&#123;</span>APP_NAME<span class="token punctuation">&#125;</span><span class="token punctuation">:</span><span class="token variable">$</span><span class="token punctuation">&#123;</span>VERSION<span class="token punctuation">&#125;</span><span class="token symbol">clean</span><span class="token punctuation">:</span><span class="token operator">@</span>find . -name <span class="token string">'*.pyc'</span> -delete<span class="token operator">@</span>find . -name <span class="token string">'__pycache__'</span> -type d <span class="token operator">|</span> xargs rm -fr<span class="token operator">@</span>find . -name <span class="token string">'.pytest_cache'</span> -type d <span class="token operator">|</span> xargs rm -fr<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>gin工程错误码翻译</title>
      <link href="/posts/40996.html"/>
      <url>/posts/40996.html</url>
      
        <content type="html"><![CDATA[<h2 id="一、背景"><a href="#一、背景" class="headerlink" title="一、背景"></a>一、背景</h2><ul><li>需要对请求参数的校验，防止用户的恶意请求。</li><li>需要对代码错误码进行翻译，返回中文</li><li>gin框架使用<code>github.com/go-playground/validator</code>进行参数校验，</li><li>在定义结构体时使用 <code>binding</code> 或 <code>validate</code>, <code>tag</code> 标识相关校验规则</li></ul><h2 id="二、安装"><a href="#二、安装" class="headerlink" title="二、安装"></a>二、安装</h2><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token comment"># 命令行安装</span>$ go get github.com/go-playground/validator/v10<span class="token comment"># 项目中引入</span><span class="token function">import</span> <span class="token string">"github.com/go-playground/validator/v10"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="三、样例"><a href="#三、样例" class="headerlink" title="三、样例"></a>三、样例</h2><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token punctuation">(</span>    <span class="token string">"fmt"</span>    <span class="token string">"net/http"</span>    <span class="token string">"github.com/gin-gonic/gin"</span><span class="token punctuation">)</span><span class="token keyword">type</span> RegisterRequest <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>    Username <span class="token builtin">string</span> <span class="token string">`json:"username" binding:"required"`</span>    Password <span class="token builtin">string</span> <span class="token string">`json:"password" binding:"required"`</span>    Nickname <span class="token builtin">string</span> <span class="token string">`json:"nickname" binding:"required"`</span>    Email    <span class="token builtin">string</span> <span class="token string">`json:"email" binding:"required,email"`</span>    Age      <span class="token builtin">uint8</span>  <span class="token string">`json:"age" binding:"gte=1,lte=120"`</span><span class="token punctuation">&#125;</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    router <span class="token operator">:=</span> gin<span class="token punctuation">.</span><span class="token function">Default</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    router<span class="token punctuation">.</span><span class="token function">POST</span><span class="token punctuation">(</span><span class="token string">"register"</span><span class="token punctuation">,</span> Register<span class="token punctuation">)</span>    router<span class="token punctuation">.</span><span class="token function">Run</span><span class="token punctuation">(</span><span class="token string">":8080"</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token keyword">func</span> <span class="token function">Register</span><span class="token punctuation">(</span>c <span class="token operator">*</span>gin<span class="token punctuation">.</span>Context<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">var</span> r RegisterRequest    err <span class="token operator">:=</span> c<span class="token punctuation">.</span><span class="token function">ShouldBindJSON</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>r<span class="token punctuation">)</span>    <span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>        c<span class="token punctuation">.</span><span class="token function">JSON</span><span class="token punctuation">(</span>http<span class="token punctuation">.</span>StatusOK<span class="token punctuation">,</span> gin<span class="token punctuation">.</span>H<span class="token punctuation">&#123;</span><span class="token string">"msg"</span><span class="token punctuation">:</span> err<span class="token punctuation">.</span><span class="token function">Error</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span>        <span class="token keyword">return</span>    <span class="token punctuation">&#125;</span>    c<span class="token punctuation">.</span><span class="token function">JSON</span><span class="token punctuation">(</span>http<span class="token punctuation">.</span>StatusOK<span class="token punctuation">,</span> <span class="token string">"success"</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="四、常见约束"><a href="#四、常见约束" class="headerlink" title="四、常见约束"></a>四、常见约束</h2><h3 id="字符串约束"><a href="#字符串约束" class="headerlink" title="字符串约束"></a>字符串约束</h3><ul><li><code>excludesall</code>：不包含参数中任意的 UNICODE 字符，例如excludesall=ab；</li><li><code>excludesrune</code>：不包含参数表示的 rune 字符，excludesrune=asong；</li><li><code>startswith</code>：以参数子串为前缀，例如startswith=hi；</li><li><code>endswith</code>：以参数子串为后缀，例如endswith=bye。</li><li><code>contains=</code>：包含参数子串，例如contains=email；</li><li><code>containsany</code>：包含参数中任意的 UNICODE 字符，例如containsany=ab；</li><li><code>containsrune</code>：包含参数表示的 rune 字符，例如`containsrune=asong；</li><li><code>excludes</code>：不包含参数子串，例如excludes=email；<h3 id="范围约束"><a href="#范围约束" class="headerlink" title="范围约束"></a>范围约束</h3>范围约束的字段类型分为三种：</li><li>对于数值，我们则可以约束其值</li><li>对于切片、数组和map，我们则可以约束其长度</li><li>对于字符串，我们则可以约束其长度</li></ul><h4 id="tag介绍："><a href="#tag介绍：" class="headerlink" title="tag介绍："></a>tag介绍：</h4><ul><li><code>ne</code>：不等于参数值，例如ne=5；</li><li><code>gt</code>：大于参数值，例如gt=5；</li><li><code>gte</code>：大于等于参数值，例如gte=50；</li><li><code>lt</code>：小于参数值，例如lt=50；</li><li><code>lte</code>：小于等于参数值，例如lte=50；</li><li><code>oneof</code>：只能是列举出的值其中一个，这些值必须是数值或字符串，以空格分隔，如果字符串中有空格，将字符串用单引号包围，例如oneof=male female。</li><li><code>eq</code>：等于参数值，注意与len不同。对于字符串，eq约束字符串本身的值，而len约束字符串长度。例如eq=10；</li><li><code>len</code>：等于参数值，例如len=10；</li><li><code>max</code>：小于等于参数值，例如max=10；</li><li><code>min</code>：大于等于参数值，例如min=10</li></ul><h4 id="Fields约束"><a href="#Fields约束" class="headerlink" title="Fields约束"></a><code>Fields</code>约束</h4><ul><li><code>eqfield</code>：定义字段间的相等约束，用于约束同一结构体中的字段。例如：eqfield=Password</li><li><code>eqcsfield</code>：约束统一结构体中字段等于另一个字段（相对），确认密码时可以使用，例如：eqfiel=ConfirmPassword</li><li><code>nefield</code>：用来约束两个字段是否相同，确认两种颜色是否一致时可以使用，例如：nefield=Color1</li><li><code>necsfield</code>：约束两个字段是否相同（相对）</li></ul><h3 id="常用约束"><a href="#常用约束" class="headerlink" title="常用约束"></a>常用约束</h3><ul><li><p><code>unique</code>：指定唯一性约束，不同类型处理不同：</p><ul><li>对于map，unique约束没有重复的值</li><li>对于数组和切片，unique没有重复的值</li><li>对于元素类型为结构体的碎片，unique约束结构体对象的某个字段不重复，使用unique=field指定字段名</li></ul></li><li><p><code>email</code>：使用email来限制字段必须是邮件形式，直接写eamil即可，无需加任何指定。</p></li><li><p><code>omitempty</code>：字段未设置，则忽略</p></li><li><p><code>-</code>：跳过该字段，不检验；</p></li><li><p><code>|</code>：使用多个约束，只需要满足其中一个，例如rgb|rgba；</p></li><li><p><code>required</code>：字段必须设置，不能为默认值；</p></li></ul><h2 id="实践使用"><a href="#实践使用" class="headerlink" title="实践使用"></a>实践使用</h2><h3 id="注册初始化"><a href="#注册初始化" class="headerlink" title="注册初始化"></a>注册初始化</h3><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">var</span> trans ut<span class="token punctuation">.</span>Translator<span class="token keyword">func</span> <span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">if</span> v<span class="token punctuation">,</span> ok <span class="token operator">:=</span> binding<span class="token punctuation">.</span>Validator<span class="token punctuation">.</span><span class="token function">Engine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token punctuation">(</span><span class="token operator">*</span>validator<span class="token punctuation">.</span>Validate<span class="token punctuation">)</span><span class="token punctuation">;</span> ok <span class="token punctuation">&#123;</span>v<span class="token punctuation">.</span><span class="token function">RegisterTagNameFunc</span><span class="token punctuation">(</span><span class="token keyword">func</span><span class="token punctuation">(</span>fld reflect<span class="token punctuation">.</span>StructField<span class="token punctuation">)</span> <span class="token builtin">string</span> <span class="token punctuation">&#123;</span><span class="token keyword">var</span> name <span class="token builtin">string</span><span class="token keyword">for</span> <span class="token boolean">_</span><span class="token punctuation">,</span> t <span class="token operator">:=</span> <span class="token keyword">range</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">string</span><span class="token punctuation">&#123;</span><span class="token string">"json"</span><span class="token punctuation">,</span> <span class="token string">"form"</span><span class="token punctuation">,</span> <span class="token string">"uri"</span><span class="token punctuation">,</span> <span class="token string">"query"</span><span class="token punctuation">&#125;</span> <span class="token punctuation">&#123;</span>name <span class="token operator">=</span> strings<span class="token punctuation">.</span><span class="token function">SplitN</span><span class="token punctuation">(</span>fld<span class="token punctuation">.</span>Tag<span class="token punctuation">.</span><span class="token function">Get</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">","</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token keyword">if</span> name <span class="token operator">!=</span> <span class="token string">""</span> <span class="token punctuation">&#123;</span><span class="token keyword">if</span> name <span class="token operator">==</span> <span class="token string">"-"</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> <span class="token string">""</span><span class="token punctuation">&#125;</span><span class="token keyword">return</span> name<span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">return</span> name<span class="token punctuation">&#125;</span><span class="token punctuation">)</span>trans<span class="token punctuation">,</span> <span class="token boolean">_</span> <span class="token operator">=</span> ut<span class="token punctuation">.</span><span class="token function">New</span><span class="token punctuation">(</span>zh<span class="token punctuation">.</span><span class="token function">New</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">GetTranslator</span><span class="token punctuation">(</span><span class="token string">"zh"</span><span class="token punctuation">)</span><span class="token boolean">_</span> <span class="token operator">=</span> zhTranslations<span class="token punctuation">.</span><span class="token function">RegisterDefaultTranslations</span><span class="token punctuation">(</span>v<span class="token punctuation">,</span> trans<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">func</span> <span class="token function">Translate</span><span class="token punctuation">(</span>err <span class="token builtin">error</span><span class="token punctuation">)</span> <span class="token builtin">string</span> <span class="token punctuation">&#123;</span><span class="token keyword">var</span> errs validator<span class="token punctuation">.</span>ValidationErrors<span class="token keyword">if</span> <span class="token operator">!</span>errors<span class="token punctuation">.</span><span class="token function">As</span><span class="token punctuation">(</span>err<span class="token punctuation">,</span> <span class="token operator">&amp;</span>errs<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> e<span class="token punctuation">.</span>InvalidArgs<span class="token punctuation">.</span><span class="token function">Error</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> errs<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">Translate</span><span class="token punctuation">(</span>trans<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="翻译校验"><a href="#翻译校验" class="headerlink" title="翻译校验"></a>翻译校验</h4><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">type</span> UsersRequest <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>    Username <span class="token builtin">string</span> <span class="token string">`json:"username" binding:"required"`</span>    Password <span class="token builtin">string</span> <span class="token string">`json:"password" binding:"required"`</span>    Nickname <span class="token builtin">string</span> <span class="token string">`json:"nickname" binding:"required"`</span>    Email    <span class="token builtin">string</span> <span class="token string">`json:"email" binding:"required,email"`</span>    Age      <span class="token builtin">uint8</span>  <span class="token string">`json:"age" binding:"gte=1,lte=120"`</span><span class="token punctuation">&#125;</span><span class="token keyword">func</span> <span class="token punctuation">(</span>u <span class="token operator">*</span>userController<span class="token punctuation">)</span> <span class="token function">Users</span><span class="token punctuation">(</span>c <span class="token operator">*</span>gin<span class="token punctuation">.</span>Context<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">var</span> req types<span class="token punctuation">.</span>UsersRequest<span class="token keyword">if</span> err <span class="token operator">:=</span> c<span class="token punctuation">.</span><span class="token function">ShouldBind</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>req<span class="token punctuation">)</span><span class="token punctuation">;</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>zap<span class="token punctuation">.</span><span class="token function">L</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Error</span><span class="token punctuation">(</span><span class="token string">"request param error"</span><span class="token punctuation">,</span> zap<span class="token punctuation">.</span><span class="token function">Error</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span><span class="token punctuation">)</span>response<span class="token punctuation">.</span><span class="token function">WithMsg</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> e<span class="token punctuation">.</span>InvalidArgs<span class="token punctuation">,</span> validation<span class="token punctuation">.</span><span class="token function">Translate</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">return</span><span class="token punctuation">&#125;</span>  <span class="token comment">// 注册逻辑...</span>response<span class="token punctuation">.</span><span class="token function">Success</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> <span class="token boolean">nil</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> gin </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软件许可证名称表</title>
      <link href="/posts/60294.html"/>
      <url>/posts/60294.html</url>
      
        <content type="html"><![CDATA[<h2 id="一、背景"><a href="#一、背景" class="headerlink" title="一、背景"></a>一、背景</h2><ul><li>许可证名称非常多，需要建立一个映射关系，将同类型的许可证名称统一映射为简称</li><li>在后续使用的时候，统一使用简称<h2 id="二、方案"><a href="#二、方案" class="headerlink" title="二、方案"></a>二、方案</h2></li><li>建立一个许可证映射关系表</li><li>引擎分析时对许可证名称根据映射关系进行映射，统一改为简称</li><li>组件库将组件许可证统一为许可证简称</li></ul><h2 id="三、代码实现"><a href="#三、代码实现" class="headerlink" title="三、代码实现"></a>三、代码实现</h2><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">import</span> <span class="token punctuation">(</span><span class="token boolean">_</span> <span class="token string">"embed"</span>    <span class="token string">"logs"</span><span class="token string">"gopkg.in/yaml.v3"</span><span class="token string">"strings"</span><span class="token punctuation">)</span><span class="token comment">//go:embed license.yaml</span><span class="token keyword">var</span> licAlias <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span><span class="token keyword">var</span> licAliasMap <span class="token operator">=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">]</span><span class="token builtin">string</span><span class="token punctuation">)</span><span class="token comment">// 初始化</span><span class="token keyword">func</span> <span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">var</span> licConfigMap <span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">string</span>err <span class="token operator">:=</span> yaml<span class="token punctuation">.</span><span class="token function">Unmarshal</span><span class="token punctuation">(</span>licAlias<span class="token punctuation">,</span> <span class="token operator">&amp;</span>licConfigMap<span class="token punctuation">)</span><span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>logs<span class="token punctuation">.</span><span class="token function">Error</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span><span class="token keyword">return</span><span class="token punctuation">&#125;</span><span class="token keyword">for</span> key<span class="token punctuation">,</span> value <span class="token operator">:=</span> <span class="token keyword">range</span> licConfigMap <span class="token punctuation">&#123;</span><span class="token keyword">for</span> <span class="token boolean">_</span><span class="token punctuation">,</span> name <span class="token operator">:=</span> <span class="token keyword">range</span> value <span class="token punctuation">&#123;</span>name <span class="token operator">=</span> strings<span class="token punctuation">.</span><span class="token function">ReplaceAll</span><span class="token punctuation">(</span>strings<span class="token punctuation">.</span><span class="token function">ToLower</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">" "</span><span class="token punctuation">,</span> <span class="token string">""</span><span class="token punctuation">)</span>licAliasMap<span class="token punctuation">[</span>name<span class="token punctuation">]</span> <span class="token operator">=</span> key<span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span>## 使用<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    licenseName <span class="token operator">:=</span> <span class="token string">"MIT License"</span>    licTmp <span class="token operator">:=</span> strings<span class="token punctuation">.</span><span class="token function">ReplaceAll</span><span class="token punctuation">(</span>strings<span class="token punctuation">.</span><span class="token function">ToLower</span><span class="token punctuation">(</span>licenseName<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">" "</span><span class="token punctuation">,</span> <span class="token string">""</span><span class="token punctuation">)</span>    licName<span class="token punctuation">,</span> ok <span class="token operator">:=</span> licAliasMap<span class="token punctuation">[</span>licTmp<span class="token punctuation">]</span>    <span class="token keyword">if</span> ok <span class="token punctuation">&#123;</span>        fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>licName<span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="四、映射表"><a href="#四、映射表" class="headerlink" title="四、映射表"></a>四、映射表</h2><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">MIT</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token string">'MIT License'</span>  <span class="token punctuation">-</span> <span class="token string">'Expat License'</span>  <span class="token punctuation">-</span> <span class="token string">'MIT'</span>  <span class="token punctuation">-</span> <span class="token string">'MIT/X11 License'</span>  <span class="token punctuation">-</span> <span class="token string">'X License'</span>  <span class="token punctuation">-</span> <span class="token string">'X11 License'</span>  <span class="token punctuation">-</span> <span class="token string">'MIT Expat License'</span>  <span class="token punctuation">-</span> <span class="token string">'The MIT License'</span><span class="token key atrule">GPL-3.0</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token string">'GNU General Public License v3.0'</span>  <span class="token punctuation">-</span> <span class="token string">'GPL v3'</span>  <span class="token punctuation">-</span> <span class="token string">'GPLv3'</span>  <span class="token punctuation">-</span> <span class="token string">'GNU GPLv3'</span>  <span class="token punctuation">-</span> <span class="token string">'GNU General Public License, Version 3.0'</span>  <span class="token punctuation">-</span> <span class="token string">'GNU General Public License version 3'</span>  <span class="token punctuation">-</span> <span class="token string">'>GNU General Public License (GPL), Version 3.0'</span><span class="token key atrule">BSD-3-Clause</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token string">'BSD 3-Clause License'</span>  <span class="token punctuation">-</span> <span class="token string">'Modified BSD License'</span>  <span class="token punctuation">-</span> <span class="token string">'A modified BSD License (BSD)'</span>  <span class="token punctuation">-</span> <span class="token string">'New BSD License'</span>  <span class="token punctuation">-</span> <span class="token string">'BSD New license'</span>  <span class="token punctuation">-</span> <span class="token string">'BSD 3-Clause "New"'</span>  <span class="token punctuation">-</span> <span class="token string">'The New BSD License'</span>  <span class="token punctuation">-</span> <span class="token string">'The (New) BSD License'</span>  <span class="token punctuation">-</span> <span class="token string">'BSD New'</span>  <span class="token punctuation">-</span> <span class="token string">'"Revised" License'</span>  <span class="token punctuation">-</span> <span class="token string">'BSD Revised License'</span>  <span class="token punctuation">-</span> <span class="token string">'Revised BSD License'</span>  <span class="token punctuation">-</span> <span class="token string">'BSD 3-Clause "New" or "Revised" License'</span>  <span class="token punctuation">-</span> <span class="token string">'BSD-3'</span>  <span class="token punctuation">-</span> <span class="token string">'BSD-3-Clause'</span>  <span class="token punctuation">-</span> <span class="token string">'3-Clause BSD License'</span><span class="token key atrule">LGPL-2.1</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token string">'LGPL 2.1'</span>  <span class="token punctuation">-</span> <span class="token string">'LGPL v2.1'</span>  <span class="token punctuation">-</span> <span class="token string">'GNU LGPLv2.1'</span>  <span class="token punctuation">-</span> <span class="token string">'Lesser GPL v2.1'</span>  <span class="token punctuation">-</span> <span class="token string">'GNU Lesser GPL 2.1'</span>  <span class="token punctuation">-</span> <span class="token string">'GNU Lesser General Public License v2.1'</span>  <span class="token punctuation">-</span> <span class="token string">'GNU Lesser General Public License version 2.1'</span>  <span class="token punctuation">-</span> <span class="token string">'GNU Lesser General Public License, version 2.1'</span><span class="token key atrule">MPL-2.0</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token string">'Mozilla Public License 2.0'</span>  <span class="token punctuation">-</span> <span class="token string">'MPL v2.0'</span>  <span class="token punctuation">-</span> <span class="token string">'Mozilla Public License, Version 2.0'</span>  <span class="token punctuation">-</span> <span class="token string">'Mozilla License 2.0'</span><span class="token key atrule">AGPL-3.0</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token string">'AGPLv3'</span>  <span class="token punctuation">-</span> <span class="token string">'GNU AGPLv3'</span>  <span class="token punctuation">-</span> <span class="token string">'Affero GPL3'</span>  <span class="token punctuation">-</span> <span class="token string">'Affero GPL v3.0'</span>  <span class="token punctuation">-</span> <span class="token string">'GNU Affero GPL 3.0'</span>  <span class="token punctuation">-</span> <span class="token string">'GNU Affero General Public License v3.0'</span>  <span class="token punctuation">-</span> <span class="token string">'GNU Affero General Public License version 3'</span><span class="token key atrule">CC-BY-4.0</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token string">'Creative Commons Attribution 4.0 International'</span>  <span class="token punctuation">-</span> <span class="token string">'Creative Commons Attribution 4.0 International (CC BY 4.0)'</span>  <span class="token punctuation">-</span> <span class="token string">'Creative Commons Attribution 4.0'</span>  <span class="token punctuation">-</span> <span class="token string">'CC BY 4.0'</span>  <span class="token punctuation">-</span> <span class="token string">'Creative Commons Attribution License 4.0'</span>  <span class="token punctuation">-</span> <span class="token string">'Creative Commons Attribution v4.0'</span>  <span class="token punctuation">-</span> <span class="token string">'CC Attribution 4.0'</span>  <span class="token punctuation">-</span> <span class="token string">'CC-BY v4.0'</span><span class="token key atrule">EPL-2.0</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token string">'Eclipse Public License - v 2.0'</span>  <span class="token punctuation">-</span> <span class="token string">'Eclipse Public License 2.0'</span>  <span class="token punctuation">-</span> <span class="token string">'Eclipse Public License v. 2.0'</span>  <span class="token punctuation">-</span> <span class="token string">'EPL v2.0'</span>  <span class="token punctuation">-</span> <span class="token string">'EPL 2.0'</span>  <span class="token punctuation">-</span> <span class="token string">'Eclipse Public License, Version 2.0'</span>  <span class="token punctuation">-</span> <span class="token string">'Eclipse License 2.0'</span>  <span class="token punctuation">-</span> <span class="token string">'Eclipse License v.2.0'</span><span class="token key atrule">CDDL-1.0</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token string">'Common Development and Distribution License 1.0'</span>  <span class="token punctuation">-</span> <span class="token string">'CDDL v1.0'</span>  <span class="token punctuation">-</span> <span class="token string">'Common Development and Distribution License, Version 1.0'</span>  <span class="token punctuation">-</span> <span class="token string">'Sun CDDL v1.0'</span><span class="token key atrule">Unlicense</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token string">'The Unlicense'</span>  <span class="token punctuation">-</span> <span class="token string">'Unlicensed'</span>  <span class="token punctuation">-</span> <span class="token string">'Public Domain'</span>  <span class="token punctuation">-</span> <span class="token string">'Unlicense'</span>  <span class="token punctuation">-</span> <span class="token string">'Unlicense.org'</span>  <span class="token punctuation">-</span> <span class="token string">'Unlicense License'</span><span class="token key atrule">GPL-2.0</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token string">'GNU General Public License v2.0'</span>  <span class="token punctuation">-</span> <span class="token string">'GPL v2'</span>  <span class="token punctuation">-</span> <span class="token string">'GNU GPLv2'</span>  <span class="token punctuation">-</span> <span class="token string">'GPL2 w/ CPE'</span>  <span class="token punctuation">-</span> <span class="token string">'GNU General Public License, version 2'</span>  <span class="token punctuation">-</span> <span class="token string">'GNU General Public License, Version 2.0'</span>  <span class="token punctuation">-</span> <span class="token string">'GNU General Public License version 2'</span>  <span class="token punctuation">-</span> <span class="token string">'GNU General Public License, version 2 (GPL2)'</span>  <span class="token punctuation">-</span> <span class="token string">'GNU General Public License, version 2, with the Classpath Exception'</span>  <span class="token punctuation">-</span> <span class="token string">'GNU General Public License (GPL), version 2, with the Classpath exception'</span>  <span class="token punctuation">-</span> <span class="token string">'GNU General Public License, version 2 (GPL2), with the classpath exception'</span><span class="token key atrule">LGPL-3.0</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token string">'LGPLv3.0'</span>  <span class="token punctuation">-</span> <span class="token string">'GNU LGPLv3'</span>  <span class="token punctuation">-</span> <span class="token string">'Lesser GPL v3.0'</span>  <span class="token punctuation">-</span> <span class="token string">'GNU Lesser GPL 3.0'</span>  <span class="token punctuation">-</span> <span class="token string">'GNU Lesser GPL, Version 3'</span>  <span class="token punctuation">-</span> <span class="token string">'GNU Lesser Public License version 3.0'</span>  <span class="token punctuation">-</span> <span class="token string">'GNU Lesser General Public License v3.0'</span>  <span class="token punctuation">-</span> <span class="token string">'GNU Lesser General Public License version 3'</span>  <span class="token punctuation">-</span> <span class="token string">'GNU Lesser General Public Licence, Version 3'</span>  <span class="token punctuation">-</span> <span class="token string">'GNU General Lesser Public License (LGPL) version 3.00'</span><span class="token key atrule">AGPL-1.0</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token string">'Affero General Public License v1.0'</span>  <span class="token punctuation">-</span> <span class="token string">'AGPL v1.0'</span>  <span class="token punctuation">-</span> <span class="token string">'AGPLv1.0'</span>  <span class="token punctuation">-</span> <span class="token string">'Affero GPL v1.0'</span>  <span class="token punctuation">-</span> <span class="token string">'AGPL-1.0'</span>  <span class="token punctuation">-</span> <span class="token string">'Affero General Public License version 1'</span><span class="token key atrule">Artistic-2.0</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token string">'Artistic License 2.0'</span>  <span class="token punctuation">-</span> <span class="token string">'Artistic v2.0'</span>  <span class="token punctuation">-</span> <span class="token string">'The Artistic License 2.0'</span>  <span class="token punctuation">-</span> <span class="token string">'Artistic License, Version 2.0'</span><span class="token key atrule">CC0-1.0</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token string">'Creative Commons Zero v1.0'</span>  <span class="token punctuation">-</span> <span class="token string">'CC0 v1.0'</span>  <span class="token punctuation">-</span> <span class="token string">'CC0 1.0 Universal'</span>  <span class="token punctuation">-</span> <span class="token string">'Creative Commons Zero v1.0 Universal'</span>  <span class="token punctuation">-</span> <span class="token string">'Creative Commons Zero 1.0 Universal'</span>  <span class="token punctuation">-</span> <span class="token string">'CC0 Public Domain Dedication'</span><span class="token key atrule">Apache-1.1</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token string">'Apache License 1.1'</span>  <span class="token punctuation">-</span> <span class="token string">'Apache Software License 1.1'</span>  <span class="token punctuation">-</span> <span class="token string">'Apache 1.1 License'</span>  <span class="token punctuation">-</span> <span class="token string">'Apache License Version 1.1'</span>  <span class="token punctuation">-</span> <span class="token string">'Apache 1.1'</span>  <span class="token punctuation">-</span> <span class="token string">'ASL 1.1'</span>  <span class="token punctuation">-</span> <span class="token string">'Apache License, Version 1.1'</span><span class="token key atrule">Apache-2.0</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token string">'ALv2'</span>  <span class="token punctuation">-</span> <span class="token string">'ASL2'</span>  <span class="token punctuation">-</span> <span class="token string">'ASLv2'</span>  <span class="token punctuation">-</span> <span class="token string">'ASL 2.0'</span>  <span class="token punctuation">-</span> <span class="token string">'Apache 2.0'</span>  <span class="token punctuation">-</span> <span class="token string">'Apache License 2.0'</span>  <span class="token punctuation">-</span> <span class="token string">'The Apache License 2.0'</span>  <span class="token punctuation">-</span> <span class="token string">'Apache License, version 2.0'</span>  <span class="token punctuation">-</span> <span class="token string">'The Apache Software License, Version 2.0'</span>  <span class="token punctuation">-</span> <span class="token string">'Apache License, Version 2.0, January 2004'</span><span class="token key atrule">BSD-2-Clause</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token string">'BSD 2-Clause'</span>  <span class="token punctuation">-</span> <span class="token string">'BSD-2-Clause'</span>  <span class="token punctuation">-</span> <span class="token string">'BSD 2 clause'</span>  <span class="token punctuation">-</span> <span class="token string">'FreeBSD License'</span>  <span class="token punctuation">-</span> <span class="token string">'BSD License 2.0'</span>  <span class="token punctuation">-</span> <span class="token string">'The Simplified BSD'</span>  <span class="token punctuation">-</span> <span class="token string">'2-Clause BSD License'</span>  <span class="token punctuation">-</span> <span class="token string">'BSD 2-Clause License'</span>  <span class="token punctuation">-</span> <span class="token string">'Simplified BSD License'</span>  <span class="token punctuation">-</span> <span class="token string">'BSD 2-Clause "Simplified" License'</span><span class="token key atrule">ISC</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token string">'ISC License'</span>  <span class="token punctuation">-</span> <span class="token string">'Internet Systems Consortium License'</span>  <span class="token punctuation">-</span> <span class="token string">'Internet Systems Consortium'</span><span class="token key atrule">EPL-1.0</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token string">'Eclipse Public License 1.0'</span>  <span class="token punctuation">-</span> <span class="token string">'EPL v1.0'</span>  <span class="token punctuation">-</span> <span class="token string">'EPL-1.0'</span>  <span class="token punctuation">-</span> <span class="token string">'Eclipse Public License, Version 1.0'</span>  <span class="token punctuation">-</span> <span class="token string">'Eclipse License 1.0'</span><span class="token key atrule">CC-BY-SA-4.0</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token string">'Creative Commons Attribution Share Alike 4.0 International'</span>  <span class="token punctuation">-</span> <span class="token string">'Creative Commons Attribution-ShareAlike 4.0'</span>  <span class="token punctuation">-</span> <span class="token string">'CC BY-SA 4.0'</span>  <span class="token punctuation">-</span> <span class="token string">'CC-BY-SA-4.0'</span>  <span class="token punctuation">-</span> <span class="token string">'Creative Commons Attribution-ShareAlike License 4.0'</span>  <span class="token punctuation">-</span> <span class="token string">'Creative Commons Attribution-ShareAlike v4.0'</span>  <span class="token punctuation">-</span> <span class="token string">'CC Attribution-ShareAlike 4.0'</span>  <span class="token punctuation">-</span> <span class="token string">'CC-BY-SA v4.0'</span><span class="token key atrule">Zlib</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token string">'zlib License'</span>  <span class="token punctuation">-</span> <span class="token string">'The zlib/libpng License'</span>  <span class="token punctuation">-</span> <span class="token string">'zlib/libpng License'</span><span class="token key atrule">WTFPL</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token string">'Do What The F*ck You Want To Public License'</span>  <span class="token punctuation">-</span> <span class="token string">'WTFPL v2'</span>  <span class="token punctuation">-</span> <span class="token string">'WTFPL Version 2'</span><span class="token key atrule">GPL-1.0</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token string">'GNU General Public License v1.0'</span>  <span class="token punctuation">-</span> <span class="token string">'GPL v1'</span>  <span class="token punctuation">-</span> <span class="token string">'GPLv1'</span>  <span class="token punctuation">-</span> <span class="token string">'GNU GPLv1'</span>  <span class="token punctuation">-</span> <span class="token string">'GNU General Public License, Version 1.0'</span>  <span class="token punctuation">-</span> <span class="token string">'GNU General Public License version 1'</span><span class="token key atrule">LGPL-2.0</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token string">'LGPL v2.0'</span>  <span class="token punctuation">-</span> <span class="token string">'LGPLv2.0'</span>  <span class="token punctuation">-</span> <span class="token string">'GNU LGPLv2.0'</span>  <span class="token punctuation">-</span> <span class="token string">'GNU Lesser GPL 2.0'</span>  <span class="token punctuation">-</span> <span class="token string">'Lesser GPL v2.0'</span>  <span class="token punctuation">-</span> <span class="token string">'GNU Lesser General Public License v2.0'</span>  <span class="token punctuation">-</span> <span class="token string">'GNU Lesser General Public License version 2'</span>  <span class="token punctuation">-</span> <span class="token string">'GNU Lesser General Public License Version 2.0'</span><span class="token key atrule">MPL-1.1</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token string">'Mozilla Public License 1.1'</span>  <span class="token punctuation">-</span> <span class="token string">'MPL v1.1'</span>  <span class="token punctuation">-</span> <span class="token string">'MPL 1.1'</span>  <span class="token punctuation">-</span> <span class="token string">'Mozilla Public License, Version 1.1'</span>  <span class="token punctuation">-</span> <span class="token string">'Mozilla License 1.1'</span><span class="token key atrule">CC-BY-SA-3.0</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token string">'Creative Commons Attribution Share Alike 3.0 Unported'</span>  <span class="token punctuation">-</span> <span class="token string">'Creative Commons Attribution-ShareAlike 3.0'</span>  <span class="token punctuation">-</span> <span class="token string">'Creative Commons Attribution-ShareAlike License 3.0'</span>  <span class="token punctuation">-</span> <span class="token string">'CC Attribution-ShareAlike 3.0'</span>  <span class="token punctuation">-</span> <span class="token string">'CC BY-SA 3.0'</span>  <span class="token punctuation">-</span> <span class="token string">'CC-BY-SA v3.0'</span><span class="token key atrule">CC-BY-NC-4.0</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token string">'Creative Commons Attribution Non Commercial 4.0 International'</span>  <span class="token punctuation">-</span> <span class="token string">'Creative Commons Attribution-NonCommercial License 4.0'</span>  <span class="token punctuation">-</span> <span class="token string">'Creative Commons Attribution-NonCommercial 4.0'</span>  <span class="token punctuation">-</span> <span class="token string">'Creative Commons Attribution-NonCommercial v4.0'</span>  <span class="token punctuation">-</span> <span class="token string">'CC Attribution-NonCommercial 4.0'</span>  <span class="token punctuation">-</span> <span class="token string">'CC BY-NC 4.0'</span>  <span class="token punctuation">-</span> <span class="token string">'CC-BY-NC v4.0'</span><span class="token key atrule">CC-BY-ND-4.0</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token string">'Creative Commons Attribution No Derivatives 4.0 International'</span>  <span class="token punctuation">-</span> <span class="token string">'Creative Commons Attribution-NoDerivatives License 4.0'</span>  <span class="token punctuation">-</span> <span class="token string">'Creative Commons Attribution-NoDerivatives 4.0'</span>  <span class="token punctuation">-</span> <span class="token string">'Creative Commons Attribution-NoDerivatives v4.0'</span>  <span class="token punctuation">-</span> <span class="token string">'CC Attribution-NoDerivatives 4.0'</span>  <span class="token punctuation">-</span> <span class="token string">'CC BY-ND 4.0'</span>  <span class="token punctuation">-</span> <span class="token string">'CC-BY-ND v4.0'</span><span class="token key atrule">CC-BY-NC-SA-4.0</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token string">'Creative Commons Attribution-NonCommercial-ShareAlike License 4.0'</span>  <span class="token punctuation">-</span> <span class="token string">'Creative Commons Attribution-NonCommercial-ShareAlike 4.0'</span>  <span class="token punctuation">-</span> <span class="token string">'Creative Commons Attribution-NonCommercial-ShareAlike v4.0'</span>  <span class="token punctuation">-</span> <span class="token string">'CC Attribution-NonCommercial-ShareAlike 4.0'</span>  <span class="token punctuation">-</span> <span class="token string">'CC BY-NC-SA 4.0'</span>  <span class="token punctuation">-</span> <span class="token string">'CC-BY-NC-SA v4.0'</span><span class="token key atrule">CC-BY-NC-ND-4.0</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token string">'Creative Commons Attribution-NonCommercial-NoDerivatives 4.0'</span>  <span class="token punctuation">-</span> <span class="token string">'Creative Commons Attribution-NonCommercial-NoDerivatives License 4.0'</span>  <span class="token punctuation">-</span> <span class="token string">'Creative Commons Attribution-NonCommercial-NoDerivatives v4.0'</span>  <span class="token punctuation">-</span> <span class="token string">'CC Attribution-NonCommercial-NoDerivatives 4.0'</span>  <span class="token punctuation">-</span> <span class="token string">'CC BY-NC-ND 4.0'</span>  <span class="token punctuation">-</span> <span class="token string">'CC-BY-NC-ND v4.0'</span><span class="token key atrule">OFL-1.1</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token string">'SIL Open Font License, Version 1.1'</span>  <span class="token punctuation">-</span> <span class="token string">'SIL Open Font License 1.1'</span>  <span class="token punctuation">-</span> <span class="token string">'SIL OFL v1.1'</span>  <span class="token punctuation">-</span> <span class="token string">'SIL OFL 1.1'</span>  <span class="token punctuation">-</span> <span class="token string">'OFL v1.1'</span><span class="token key atrule">ZPL-2.1</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token string">'Zope Public License, Version 2.1'</span>  <span class="token punctuation">-</span> <span class="token string">'Zope Public License 2.1'</span>  <span class="token punctuation">-</span> <span class="token string">'Zope License 2.1'</span>  <span class="token punctuation">-</span> <span class="token string">'ZPL v2.1'</span><span class="token key atrule">ECL-2.0</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token string">'Educational Community License, Version 2.0'</span>  <span class="token punctuation">-</span> <span class="token string">'Educational Community License v2.0'</span>  <span class="token punctuation">-</span> <span class="token string">'Educational Community License 2.0'</span>  <span class="token punctuation">-</span> <span class="token string">'ECL v2.0'</span><span class="token key atrule">BSD-4-Clause</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token string">'BSD 4-Clause License'</span>  <span class="token punctuation">-</span> <span class="token string">'original "BSD License"'</span>  <span class="token punctuation">-</span> <span class="token string">'Original BSD License'</span>  <span class="token punctuation">-</span> <span class="token string">'4-Clause BSD License'</span>  <span class="token punctuation">-</span> <span class="token string">'4-clause license'</span>  <span class="token punctuation">-</span> <span class="token string">'BSD License 4.0'</span>  <span class="token punctuation">-</span> <span class="token string">'BSD-4-Clause'</span><span class="token key atrule">MS-PL</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token string">'Microsoft Public License'</span>  <span class="token punctuation">-</span> <span class="token string">'Microsoft Public License (Ms-PL)'</span>  <span class="token punctuation">-</span> <span class="token string">'Microsoft Permissive License'</span><span class="token key atrule">MS-RL</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token string">'Microsoft Reciprocal License'</span>  <span class="token punctuation">-</span> <span class="token string">'Microsoft Reciprocal License (Ms-RL)'</span><span class="token key atrule">IPL-1.0</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token string">'IBM Public License v1.0'</span>  <span class="token punctuation">-</span> <span class="token string">'IBM Public License Version 1.0'</span><span class="token key atrule">CPL-1.0</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token string">'Common Public License 1.0'</span>  <span class="token punctuation">-</span> <span class="token string">'Common Public License version 1.0'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>postgre数据导入导出</title>
      <link href="/posts/4621.html"/>
      <url>/posts/4621.html</url>
      
        <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><ul><li>在软件交付过程中，出厂需要带上较大数据量的数据</li><li>数据量会比较大，需要一个初始导入的方案</li><li>需要在初次交付部署时进行导入</li><li>在后续维护过程中需要持续不断的导入新数据</li><li>对于数据来说，只需要增加，不需要修改，删除</li></ul><h2 id="全量导入方案"><a href="#全量导入方案" class="headerlink" title="全量导入方案"></a>全量导入方案</h2><h3 id="1、PG的备份恢复"><a href="#1、PG的备份恢复" class="headerlink" title="1、PG的备份恢复"></a>1、PG的备份恢复</h3><ul><li>计划使用pg备份恢复功能，对初次交付的sca进行数据导入</li><li>使用 <code>pg_dump</code> <code>pg_dumpall</code> <code>psql</code>等工具进行数据的备份和恢复</li><li>需要验证导入时间，相对来说应该是比较快的方式</li></ul><h4 id="备份"><a href="#备份" class="headerlink" title="备份"></a>备份</h4><pre class="line-numbers language-none"><code class="language-none">pg_dump -h postgresql-postgresql-ha-pgpool -p 5432 -U postgres -F t -f backup-prod.tar postgres<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="恢复"><a href="#恢复" class="headerlink" title="恢复"></a>恢复</h4><pre class="line-numbers language-none"><code class="language-none">pg_restore -h postgresql-postgresql-ha-pgpool -p 5432 -U postgres -d postgres backup-prod.tar<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="2、挂载-PG-的持久化目录"><a href="#2、挂载-PG-的持久化目录" class="headerlink" title="2、挂载 PG 的持久化目录"></a>2、挂载 PG 的持久化目录</h3><ul><li>将内部部署的知识库的pg数据库的持久文件，直接打入部署包</li><li>在创建数据库容器实例的时候，创建表结构</li><li>或者在容器创建时，直接挂载该目录</li></ul><h3 id="3、创建数据库实例时执行sql"><a href="#3、创建数据库实例时执行sql" class="headerlink" title="3、创建数据库实例时执行sql"></a>3、创建数据库实例时执行sql</h3><ul><li>在创建数据库实例的时候，挂在数据库sql文件到docker-entrypoint-initdb.d</li><li>启动数据库可能需要较长时间</li><li>需要执行数据导入sql，对于io要求较高</li><li>数据使用sql文本保存，体积较大</li></ul><h3 id="4、init容器导入数据"><a href="#4、init容器导入数据" class="headerlink" title="4、init容器导入数据"></a>4、init容器导入数据</h3><ul><li>容器启动前添加一个新的 init 容器来导入数据</li></ul><h2 id="增量导入"><a href="#增量导入" class="headerlink" title="增量导入"></a>增量导入</h2><h3 id="1、API导入流程"><a href="#1、API导入流程" class="headerlink" title="1、API导入流程"></a>1、API导入流程</h3><ul><li>通过api将数据进行上传，可以使用csv或者直接上传sql</li><li>发起导入，在后台进行sql执行</li><li>需要严格校验sql的安全性</li></ul><h3 id="2、数据文件要求"><a href="#2、数据文件要求" class="headerlink" title="2、数据文件要求"></a>2、数据文件要求</h3><ul><li>统一采用csv格式，使用zip压缩</li><li>csv文件名与数据库表名称一致</li><li>csv表格字段与数据库表字段名称一致，类型尽量一致</li></ul><h2 id="相关脚本"><a href="#相关脚本" class="headerlink" title="相关脚本"></a>相关脚本</h2><p>1、删除表</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token shebang important">#!/bin/bash</span><span class="token comment"># 数据库连接参数</span><span class="token assign-left variable">DB_HOST</span><span class="token operator">=</span><span class="token string">"192.168.1.1"</span><span class="token assign-left variable">DB_PORT</span><span class="token operator">=</span><span class="token string">"5432"</span><span class="token assign-left variable">DB_NAME</span><span class="token operator">=</span><span class="token string">"postgres"</span><span class="token assign-left variable">DB_USER</span><span class="token operator">=</span><span class="token string">"postgres"</span><span class="token assign-left variable">DB_PASSWORD</span><span class="token operator">=</span><span class="token string">"postgres"</span><span class="token comment"># 删除指定表数据的函数</span><span class="token function-name function">delete_table_data</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token assign-left variable">table_name</span><span class="token operator">=</span><span class="token variable">$1</span>    <span class="token builtin class-name">echo</span> <span class="token string">"psql -h <span class="token variable">$DB_HOST</span> -p <span class="token variable">$DB_PORT</span> -U <span class="token variable">$DB_USER</span> -d <span class="token variable">$DB_NAME</span> -c DELETE FROM <span class="token variable">$table_name</span>;"</span>    psql -h <span class="token string">"<span class="token variable">$DB_HOST</span>"</span> -p <span class="token string">"<span class="token variable">$DB_PORT</span>"</span> -U <span class="token string">"<span class="token variable">$DB_USER</span>"</span> -d <span class="token string">"<span class="token variable">$DB_NAME</span>"</span> -c <span class="token string">"DELETE FROM <span class="token variable">$table_name</span>;"</span><span class="token punctuation">&#125;</span><span class="token comment"># 删除所有表数据的函数</span><span class="token function-name function">delete_all_tables_data</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    delete_table_data <span class="token string">"t_xxx1"</span>    delete_table_data <span class="token string">"t_xxx2"</span>    delete_table_data <span class="token string">"t_xxx3"</span>    delete_table_data <span class="token string">"t_xxx4"</span>    delete_table_data <span class="token string">"t_xxx5"</span><span class="token punctuation">&#125;</span><span class="token comment"># 主函数</span><span class="token function-name function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token builtin class-name">echo</span> <span class="token string">"选择要删除数据的表："</span>  <span class="token builtin class-name">echo</span> <span class="token string">"  1. t_xxx1"</span>  <span class="token builtin class-name">echo</span> <span class="token string">"  2. t_xxx2"</span>  <span class="token builtin class-name">echo</span> <span class="token string">"  3. t_xxx3"</span>  <span class="token builtin class-name">echo</span> <span class="token string">"  4. t_xxx4"</span>  <span class="token builtin class-name">echo</span> <span class="token string">"  5. t_xxx5"</span>  <span class="token builtin class-name">echo</span> <span class="token string">"  6. 删除以上表数据"</span>  <span class="token builtin class-name">echo</span> <span class="token string">"  0. 退出"</span>  <span class="token builtin class-name">printf</span> <span class="token string">"<span class="token entity" title="\e">\e</span>[1;31m警告：数据删除无法恢复，请谨慎操作 <span class="token entity" title="\e">\e</span>[0m<span class="token entity" title="\n">\n</span>"</span>  <span class="token builtin class-name">read</span> -p <span class="token string">"请输入选项数字: "</span> choice  <span class="token keyword">case</span> <span class="token variable">$choice</span> <span class="token keyword">in</span>      <span class="token number">1</span><span class="token punctuation">)</span> delete_table_data <span class="token string">"t_xxx1"</span><span class="token punctuation">;</span><span class="token punctuation">;</span>      <span class="token number">2</span><span class="token punctuation">)</span> delete_table_data <span class="token string">"t_xxx2"</span><span class="token punctuation">;</span><span class="token punctuation">;</span>      <span class="token number">3</span><span class="token punctuation">)</span> delete_table_data <span class="token string">"t_xxx3"</span><span class="token punctuation">;</span><span class="token punctuation">;</span>      <span class="token number">4</span><span class="token punctuation">)</span> delete_table_data <span class="token string">"t_xxx4"</span><span class="token punctuation">;</span><span class="token punctuation">;</span>      <span class="token number">5</span><span class="token punctuation">)</span> delete_table_data <span class="token string">"t_xxx5"</span><span class="token punctuation">;</span><span class="token punctuation">;</span>      <span class="token number">6</span><span class="token punctuation">)</span> delete_all_tables_data<span class="token punctuation">;</span><span class="token punctuation">;</span>      <span class="token number">0</span><span class="token punctuation">)</span> <span class="token builtin class-name">exit</span><span class="token punctuation">;</span><span class="token punctuation">;</span>      *<span class="token punctuation">)</span> <span class="token builtin class-name">echo</span> <span class="token string">"无效选项"</span><span class="token punctuation">;</span><span class="token punctuation">;</span>  <span class="token keyword">esac</span><span class="token punctuation">&#125;</span>main<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>2、综合执行</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token shebang important">#!/bin/bash</span><span class="token keyword">function</span> <span class="token function-name function">dump</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token builtin class-name">echo</span> <span class="token string">"执行 ping 192.168.1.1："</span>    <span class="token function">ping</span> <span class="token number">192.168</span>.1.1<span class="token punctuation">&#125;</span><span class="token keyword">function</span> <span class="token function-name function">restore</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token builtin class-name">echo</span> <span class="token string">"执行 ls 命令："</span>    <span class="token function">ls</span><span class="token punctuation">&#125;</span><span class="token comment"># 显示选项菜单</span><span class="token builtin class-name">printf</span> <span class="token string">"<span class="token entity" title="\e">\e</span>[1;31m警告：请谨慎操作数据库 <span class="token entity" title="\e">\e</span>[0m<span class="token entity" title="\n">\n</span>"</span><span class="token builtin class-name">echo</span> <span class="token string">"请选择要执行的操作："</span><span class="token builtin class-name">echo</span> <span class="token string">"1. 执行备份"</span><span class="token builtin class-name">echo</span> <span class="token string">"2. 执行恢复"</span><span class="token builtin class-name">echo</span> <span class="token string">"0. 退出"</span><span class="token comment"># 读取用户输入的选项</span><span class="token builtin class-name">read</span> -p <span class="token string">"请输入选项编号： "</span> choice<span class="token comment"># 根据用户选择执行相应的函数</span><span class="token keyword">case</span> <span class="token variable">$choice</span> <span class="token keyword">in</span>    <span class="token number">1</span><span class="token punctuation">)</span>        dump  <span class="token comment"># 调用执行 ping 命令的函数</span>        <span class="token punctuation">;</span><span class="token punctuation">;</span>    <span class="token number">2</span><span class="token punctuation">)</span>        restore    <span class="token comment"># 调用执行 ls 命令的函数</span>        <span class="token punctuation">;</span><span class="token punctuation">;</span>    <span class="token number">0</span><span class="token punctuation">)</span>        <span class="token builtin class-name">exit</span>  <span class="token comment"># 退出</span>        <span class="token punctuation">;</span><span class="token punctuation">;</span>    *<span class="token punctuation">)</span>        <span class="token builtin class-name">echo</span> <span class="token string">"错误：无效的选项。"</span>        <span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token keyword">esac</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>3、备份</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token shebang important">#!/usr/bin/expect -f</span><span class="token builtin class-name">set</span> <span class="token function">timeout</span> <span class="token number">30</span><span class="token builtin class-name">set</span> <span class="token function">host</span> <span class="token string">"192.168.5.81"</span><span class="token builtin class-name">set</span> port <span class="token string">"31730"</span><span class="token builtin class-name">set</span> db <span class="token string">"postgres"</span><span class="token builtin class-name">set</span> username <span class="token string">"postgres"</span><span class="token builtin class-name">set</span> password <span class="token string">"UV3eYMvL03"</span><span class="token builtin class-name">set</span> tables <span class="token string">"-t t_comp_version -t t_comp_version_dep -t t_software_license -t t_vul_component -t t_vul_metadata"</span><span class="token builtin class-name">set</span> <span class="token function">file</span> <span class="token string">"backup-dev-test-0509.tar"</span>spawn pg_dump -U <span class="token variable">$username</span> -h <span class="token variable">$host</span> -p <span class="token variable">$port</span> -F t <span class="token variable">$tables</span> -f <span class="token variable">$file</span> -a <span class="token variable">$db</span><span class="token function">expect</span> <span class="token string">"password"</span>send <span class="token string">"<span class="token variable">$password</span><span class="token entity" title="\r">\r</span>"</span><span class="token function">expect</span> eof<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>4、恢复</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token shebang important">#!/usr/bin/expect -f</span><span class="token builtin class-name">set</span> <span class="token function">timeout</span> <span class="token number">30</span><span class="token builtin class-name">set</span> <span class="token function">host</span> <span class="token string">"192.168.1.1"</span><span class="token builtin class-name">set</span> port <span class="token string">"5432"</span><span class="token builtin class-name">set</span> db <span class="token string">"postgres"</span><span class="token builtin class-name">set</span> username <span class="token string">"postgres"</span><span class="token builtin class-name">set</span> password <span class="token string">"postgres"</span><span class="token builtin class-name">set</span> <span class="token function">file</span> <span class="token string">"backup.tar"</span>spawn pg_restore -h <span class="token variable">$host</span> -p <span class="token variable">$port</span> -U <span class="token variable">$username</span> -d <span class="token variable">$db</span> <span class="token variable">$file</span><span class="token function">expect</span> <span class="token string">"password"</span>send <span class="token string">"<span class="token variable">$password</span><span class="token entity" title="\r">\r</span>"</span><span class="token function">expect</span> eof<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> postgre </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>香港银行卡开户记录(汇丰+中银)</title>
      <link href="/posts/44516.html"/>
      <url>/posts/44516.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>之前一直想开一个离岸账户，由于我本人在杭州上班，需要去香港，时间和精力都不允许，就一直拖着没去。<br>后来看到一些中介在发年后可能会提高赴港开户的门槛，就了解了一下，虽然是谣言，但是还是得早点去开了，后面肯定会提高门槛的。<br>就计划趁着过年返杭的时候，去一趟，然后从深圳去杭州继续上班，主打一个特种兵低成本赴港开户。</p><h2 id="赴港前准备"><a href="#赴港前准备" class="headerlink" title="赴港前准备"></a>赴港前准备</h2><h3 id="材料"><a href="#材料" class="headerlink" title="材料"></a>材料</h3><ol><li>去香港前需要准备一些证件，我在过年前两周去出入境处办港澳通行证，工作人员说可能年前拿不到，具体要看审批。然后我想了一下，就选择了邮寄到老家，这样就算年后拿到也可以，<br>然后我办的是空证，办理的小姐姐建议我加办一个签注，不然我办签注的时候也需要重新走一趟流程，需要20天。我说可以，谢谢小姐姐提醒，这个我真不知道，我以为可以直接在机器上面签注就可以，原来第一次签注不能在机器上签。</li><li>然后还需要准备地址证明，我去招行线下打印了信用卡账单，保险起见，我还打印了电子账单</li><li>过关小票会在过关的时候提供。<br>办卡一般只需要上面三个就好了，但为了保险起见，我还在准备了一些其他的资料<ol><li>A股账户的对账单，和资产证明，资产证明主要是想开工银亚洲，说是可能需要资产证明</li><li>准备了 1.2w 港币，取港币的时候用的是工行的卡取的，结果异地卡在杭州取港币收手续费，真坑。我用工行取了一千，剩下的在中行取的，中行的服务好多了，没有费用，就是排队人比较多；另外工行其实也可以不用手续费的，但是需要打电话预约，不能app预约。app预约要收手续费。</li></ol></li></ol><h3 id="预约"><a href="#预约" class="headerlink" title="预约"></a>预约</h3><ol><li>我计划去网红网点，汇丰的葵芳分行和中银的下葵涌分行，汇丰可以提前30天预约，汇丰换了预约地址，不要去公众号预约，很可能没人理你。</li><li>由于我预约的时候还有8天，所以葵芳分行只有9点的号了，所以我准备9点顶门 walk in 去，加上预约的9点，双保险。</li><li>中银可以预约7天前的时间，公众号和网页都可以预约。我是蹲着12点放号去网页预约的，下葵涌分行太热门，我没抢到，选择附近的葵涌广场分行，预约了10:30。</li><li>另外我还预约了多个12-13点的工银亚洲作为备选，如果前面开户不顺利，就试试工银亚洲。</li><li>还有两个虚拟银行，众安银行和理慧银行，打算在银行排队的时候，连接wifi开。 </li><li>总体开户流程是，9点开汇丰，开完汇丰直接walk in 下葵涌的中银，如果这里不能 walk in 就选择预约过的葵涌广场进行开户。最后去工银亚洲。因为路途遥远，所以希望一次成功。</li><li>还有就是要提前下载需要的银行app，安卓可以去官网下载，中银有2个，其他都是一个。我在中行开户的时候，经理要看我的个人所得税app信息，这个我是没预料到的，然后我的app没更新，只能现场更新，更新完成后给经理看了，他看了一下我的受雇信息。</li></ol><h2 id="行程"><a href="#行程" class="headerlink" title="行程"></a>行程</h2><h3 id="过关"><a href="#过关" class="headerlink" title="过关"></a>过关</h3><ol><li><p>我是预定的2月19号周一的开户，所以18号到深圳，我定了罗湖口岸附近的一个青旅，一晚上30元。我是17号从广西那边过来的，广西到深圳的高速堵麻了，平时4个小时的车程，开了18个小时，</p></li><li><p>19号早上6点起来，洗漱收拾行李，罗湖口岸是6:30开始通关，我先在深圳吃个早茶，香港吃饭比较贵，所以不打算在香港吃。</p></li><li><p>吃完之后开始到罗湖通关，通关的时候，有点迷路，遇到了一个去香港出差的大哥，他让我跟着他，我们在地铁上聊了好一会，后来我先换乘了。地铁可以刷支付宝，高德地图直接导航到葵芳站。</p></li></ol><h3 id="汇丰开户"><a href="#汇丰开户" class="headerlink" title="汇丰开户"></a>汇丰开户</h3><ol><li>地铁站出来走几分钟就是汇丰葵芳分行了，我到哪里的时候是8:20，前面有几个人在排队了。</li></ol><ol start="2"><li><p>到9点准时开门，跟着队伍进去，告知预约了开户，然后扫二维码，经理领着我去一个招待室，然后按照他的指示开户。全程很流畅，就看了港澳通行证，身份证，通关小票。直接下卡了。下卡后经理说四周内要存100港币，不然会封卡。期间遇到2个小问题：</p><ul><li><p>在汇丰app填信息的时候，需要填地址信息，这个需要拼音或者英文，建议提前准备好，</p></li><li><p>另外我切换到浏览器查我的邮编的时候，汇丰app在后台被杀了，导致开户流程需要重新来，耽误了一些时间，但是还是很快，不到半小时就开好了。</p></li></ul></li><li><p>经理也没有推销啥的，问了我要不要开信用卡，我说没有考虑，他说就随便问一下，开户体验非常好</p></li><li><p>拿到卡我直接按照经理给的信封，里面装着实体卡和密码函，去旁边的ATM激活，存钱了，香港银行的ATM分为提款和存款两种，一定要看清楚，去错了可能会被吞卡。</p></li></ol><h3 id="中银开户"><a href="#中银开户" class="headerlink" title="中银开户"></a>中银开户</h3><ol><li><p>开完汇丰后，我立马按照计划去附近的中银下葵涌分行，到哪的时候表明来意，大堂经理给我去了一个号，是004号，</p></li><li><p>前面有两个小姐姐也是在开户，我是第三个，有一个号是没人来。在等待过程中，大堂经理要求扫码，在中银香港的app上面填写开户信息，我填完后，就等待叫号了，只有一个开户经理，我每个人大概半小时，前面两个小姐姐总共开了一个小时就到我了。</p></li><li><p>开户经理问了我是学生还是已经工作了，我说工作了，他要看我的个人所得税app的雇佣信息，这个我是没想到了，我的个税app太久没打开了，要更新，更新完成后给他看了，他问了我是在这家公司上班吗，我说是的，然后要了港澳通行证，身份证，过关小票和地址证明。也是当场下卡，给了一个信封和一张通知单。然后还帮我开通了Boc pay和转数快，类似国内的支付宝。</p></li><li><p>下卡后，经理让我按照指示去ATM激活，而且还说了一周之内会有一个服务评价给到我邮箱，希望我给好评，他说的他的服务质量是没问题的，如果有问题可以随时提出，我说好的。这个有点太直接了图片，跟国内不一样。</p></li></ol><h3 id="虚拟银行开户"><a href="#虚拟银行开户" class="headerlink" title="虚拟银行开户"></a>虚拟银行开户</h3><ol><li><p>在中银等待的过程中，我连接中银的wifi开通了两个虚拟银行，分别是众安银行和理慧银行，这两个没啥难度，按照app指示操作即可。</p></li><li><p>本来我还预约了工银亚洲的开户，前面开户这么顺利，就打算不开工银亚洲了。</p></li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>上午的开户流程非常顺畅，除了在中银那里排了一个小时的队伍，其他体验都非常不错，在排队过程中，我开了虚拟银行，时间上基本没有浪费，开完户才11点，剩下的时间准备在香港逛逛。感受一下这座城市。</p>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 开户 </tag>
            
            <tag> 香港 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TCP和UDP可以绑定相同的端口吗</title>
      <link href="/posts/20702.html"/>
      <url>/posts/20702.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>网络通信是一个复杂的过程，涉及到多个层次的协议和机制。在 OSI 模型中，传输层是负责端到端数据传输的层次，它提供了两种主要的传输协议：TCP（传输控制协议）和 UDP（用户数据报协议）。这两种协议虽然都运行在传输层，但它们的设计目标和工作方式存在显著差异。</p><h2 id="TCP-和-UDP-的基本特性"><a href="#TCP-和-UDP-的基本特性" class="headerlink" title="TCP 和 UDP 的基本特性"></a>TCP 和 UDP 的基本特性</h2><ul><li><p>TCP 是一种面向连接的、可靠的、基于字节流的传输协议。它通过三次握手建立连接，确保数据的有序传输，并通过四次挥手来终止连接。TCP 还提供了拥塞控制和流量控制机制，以确保网络资源的合理利用。</p></li><li><p>UDP 是一种无连接的、不可靠的、基于数据报的传输协议。它不保证数据的顺序或完整性，也不进行流量控制或拥塞控制。由于其简单的设计，UDP 提供了比 TCP 更低的延迟和更高的效率，适用于实时应用，如语音和视频通信。</p></li></ul><h2 id="端口的作用"><a href="#端口的作用" class="headerlink" title="端口的作用"></a>端口的作用</h2><p>在传输层，端口用于标识主机上的特定应用程序或服务。每个端口都是一个 16 位的数字，范围从 0 到 65535。其中，0 到 1023 是众所周知的端口，由 IANA（互联网号码分配局）管理，用于分配给常用的服务；1024 到 49151 是注册端口，用于分配给特定的应用程序或服务；49152 到 65535 是动态或私有端口，用于临时分配给客户端应用程序。</p><h2 id="TCP-和-UDP-共享端口"><a href="#TCP-和-UDP-共享端口" class="headerlink" title="TCP 和 UDP 共享端口"></a>TCP 和 UDP 共享端口</h2><p>尽管 TCP 和 UDP 都使用端口来标识应用程序，但它们可以同时使用同一个端口。这是因为传输层协议和端口号的组合构成了一个唯一的标识符，用于区分不同的数据流。当数据包到达主机时，操作系统会根据 IP 包头中的协议字段来确定数据包是 TCP 还是 UDP，然后根据端口号将数据包传递给相应的应用程序或服务。</p><h2 id="实际应用示例"><a href="#实际应用示例" class="headerlink" title="实际应用示例"></a>实际应用示例</h2><p>在实际应用中，TCP 和 UDP 同时使用相同端口的情况并不少见。例如，一个 Web 服务器可能同时提供 HTTP（基于 TCP）和 HTTP 流媒体（基于 UDP）服务，两者都使用端口 80。在这种情况下，TCP 和 UDP 数据包可以通过各自的协议栈独立处理，而不会发生冲突。</p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>综上所述，TCP 和 UDP 可以使用同一个端口，这是由它们在传输层的独立性和操作系统对数据包的处理机制决定的。这种能力使得网络通信更加灵活和高效，能够满足不同场景下的需求。无论是对于服务端还是客户端，理解 TCP 和 UDP 的工作原理以及它们如何共享资源，都是构建可靠和高性能网络应用的基础。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TCP </tag>
            
            <tag> UDP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GO 的 init 函数</title>
      <link href="/posts/45482.html"/>
      <url>/posts/45482.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><code>go</code> 语言中有一个非常神奇的函数 <code>init</code> ,它可以在所有程序执行开始前被执行，并且每个 <code>package</code> 下面可以存在多个 <code>init</code> 函数，我们一起来看看这个奇怪的 <code>init</code> 函数。</p><h2 id="init-特性"><a href="#init-特性" class="headerlink" title="init 特性"></a>init 特性</h2><ul><li><code>init</code> 函数在 <code>main</code> 函数之前执行，并且是自动执行；</li><li>每个 <code>package</code> 中可以存在多个 <code>init</code> 函数；</li><li>每个 <code>package</code> 中的源文件也可以存在多个 <code>init</code> 函数；</li><li><code>init</code> 函数没有输入参数，返回值，也没有声明，无法引用；</li><li>不同的 <code>package</code> 中的 <code>init</code> 函数按照包导入的依赖关系决定执行顺序；</li><li>无论包被导入多少次，<code>init</code> 函数只会执行一次。</li></ul><h2 id="init-的执行顺序"><a href="#init-的执行顺序" class="headerlink" title="init 的执行顺序"></a>init 的执行顺序</h2><p><img src="https://img-blog.csdnimg.cn/927295e04b5c4a3d82c9e4e798e67bfd.png" alt="初始化顺序"></p><p>这张图清晰反应了 <code>init</code> 函数的加载顺序：</p><ul><li>优先级最高的是 <code>package</code> 加载，先层层递归进行包加载</li><li>每个包中的加载顺序是：<code>const</code> -&gt; <code>var</code> -&gt; <code>init</code></li></ul><h2 id="变量的初始化顺序"><a href="#变量的初始化顺序" class="headerlink" title="变量的初始化顺序"></a>变量的初始化顺序</h2><p>针对变量的初始化顺序，<code>GO</code> 官方文档有一个例子</p><p><img src="https://img-blog.csdnimg.cn/4a7ef276e5e345fd93f752545a6023c9.png" alt="变量的初始化顺序"></p><ul><li>这个例子的初始化顺序：<code>d</code> -&gt; <code>b</code> -&gt; <code>c</code> -&gt; <code>a</code></li><li>变量的初始化顺序是按照出现的顺序进行先后加载的</li><li>如果某个变量需要依赖其他变量，则被依赖的变量先初始化</li></ul><h2 id="package-中多个-init-的执行顺序"><a href="#package-中多个-init-的执行顺序" class="headerlink" title="package 中多个 init 的执行顺序"></a>package 中多个 init 的执行顺序</h2><p><code>GO</code> 官方文档对这个有专门的说明</p><ul><li>如果当前包下有多个 <code>init</code> 函数，首先按照源文件名的字典序从前往后执行</li><li>若一个文件中出现多个 <code>init</code> 函数，则按照出现顺序从前往后进行执行</li></ul><h2 id="加载顺序总结"><a href="#加载顺序总结" class="headerlink" title="加载顺序总结"></a>加载顺序总结</h2><ul><li>从当前包开始，如果当前包 <code>import</code> 了多个依赖包，</li><li>先加载依赖包，层层递归初始化各个包，<ul><li>在每一个包中，按照源文件的字典序从前往后执行，<ul><li>每一个源文件中， 优先初始化常量，变量，最后是 <code>init</code> 函数，</li><li>当出现多个 <code>init</code> 函数时，则按照出现的顺序从前往后一次执行，</li></ul></li><li>每一个包都初始化完成后，递归返回</li></ul></li><li>初始化当前包。</li></ul><h2 id="init-的使用场景"><a href="#init-的使用场景" class="headerlink" title="init 的使用场景"></a>init 的使用场景</h2><ul><li>服务注册</li><li>数据库，缓存等中间件的初始化连接</li></ul><h2 id="init-注意事项"><a href="#init-注意事项" class="headerlink" title="init 注意事项"></a>init 注意事项</h2><ul><li>开发时尽量不要依赖 <code>init</code> 的顺序,</li><li>复杂的逻辑不要使用 <code>init</code> 函数，</li><li><code>init</code> 函数不能在代码中被显式调用，不能被引用,</li><li>导入包不要出现循环依赖,</li><li>导入包仅仅想使用这个包的 <code>init</code>，不使用其他方法，可以加上下划线<code>_</code> ,</li><li>例如：<code>import _ &quot;cumsuter_package&quot;</code>,</li><li><code>init</code> 不应依赖 main函数里面创建的变量，因为 <code>init</code> 先于 <code>main</code> 执行。</li></ul>]]></content>
      
      
      <categories>
          
          <category> go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>全链路追踪之Jaeger</title>
      <link href="/posts/412.html"/>
      <url>/posts/412.html</url>
      
        <content type="html"><![CDATA[<h2 id="Jaeger-概述"><a href="#Jaeger-概述" class="headerlink" title="Jaeger 概述"></a>Jaeger 概述</h2><p><img src="https://img-blog.csdnimg.cn/cc2c7cc101fe46a9bbe91c0fa03a58be.png" alt="在这里插入图片描述"><br><code>Jaeger</code> 是 <code>Uber</code> 开发并开源的一款分布式追踪系统，兼容 <code>OpenTracing API</code>，适用于以下下场景：</p><ul><li>分布式跟踪信息传递</li><li>分布式事务监控</li><li>问题分析</li><li>服务依赖性分析</li><li>性能优化</li></ul><h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><h3 id="高扩展性"><a href="#高扩展性" class="headerlink" title="高扩展性"></a>高扩展性</h3><p><code>Jaeger</code>后端的设计没有单点故障，可以根据业务需求进行扩展。</p><h3 id="原生支持-OpenTracing"><a href="#原生支持-OpenTracing" class="headerlink" title="原生支持 OpenTracing"></a>原生支持 OpenTracing</h3><p><code>Jaeger</code>后端，<code>Web UI</code>和工具库已完全设计为支持<code>OpenTracing</code>标准。</p><ul><li>通过跨度引用将迹线表示为有向无环图（不仅是树）；</li><li>支持强类型的跨度标签和结构化日志<code>baggage</code></li><li>支持通用的分布式上下文传播机制</li></ul><h3 id="多存储后端"><a href="#多存储后端" class="headerlink" title="多存储后端"></a>多存储后端</h3><ul><li><code>Jaeger</code>支持两个流行的开源<code>NoSQL</code>数据库作为跟踪存储后端：<code>Cassandra 3.4+</code>和<code>Elasticsearch 5.x / 6.x / 7.x</code>。</li><li><code>Jaeger</code>还附带了一个简单的内存存储区，用于测试设置。<h3 id="现代化的UI"><a href="#现代化的UI" class="headerlink" title="现代化的UI"></a>现代化的UI</h3></li><li><code>Jaeger Web UI</code>是使用流行的开源框架（如<code>React</code>）以<code>Javascript</code>实现的。</li><li><code>v1.0</code>中发布了几项性能改进，以允许<code>UI</code>有效处理大量数据，并显示具有成千上万个跨度的跟踪<br><img src="https://img-blog.csdnimg.cn/685450dce34346bab3482f68a8cd30f4.png" alt="在这里插入图片描述"></li></ul><h3 id="云原生部署"><a href="#云原生部署" class="headerlink" title="云原生部署"></a>云原生部署</h3><ul><li><code>Jaeger</code>后端作为<code>Docker</code>映像的集合进行分发。</li><li>这些二进制文件支持各种配置方法，包括命令行选项，环境变量和多种格式（<code>yaml，toml</code>等）的配置文件。</li><li><code>Kubernetes</code>模板和<code>Helm</code>图表有助于将其部署到<code>Kubernetes</code>集群。<h3 id="可观察性"><a href="#可观察性" class="headerlink" title="可观察性"></a>可观察性</h3></li><li>所有<code>Jaeger</code>后端组件都公开<code>Prometheus</code>指标（也支持其他指标后端）。</li><li>使用结构化日志库<code>zap</code>将日志写到标准输出。</li></ul><h2 id="系统架构"><a href="#系统架构" class="headerlink" title="系统架构"></a>系统架构</h2><p><img src="https://img-blog.csdnimg.cn/a9f43f2a0bef413cb0f32024818d45c0.png" alt="在这里插入图片描述"></p><ul><li><p><code>Jaeger Client</code> - 为不同语言实现了符合 <code>OpenTracing</code> 标准的 <code>SDK</code>。应用程序通过 <code>API</code> 写入数据，<code>client library</code> 把 <code>trace</code> 信息按照应用程序指定的采样策略传递给 <code>jaeger-agent</code>。</p></li><li><p><code>Agent</code> - 是一个监听在 <code>UDP</code> 端口上接收 <code>span</code> 数据的网络守护进程，它会将数据批量发送给 <code>collector</code>。它被设计成一个基础组件，推荐部署到所有的宿主机上。<code>Agent</code> 将 <code>client library</code> 和 <code>collector</code> 解耦，为 <code>client library</code> 屏蔽了路由和发现 <code>collector</code> 的细节。</p></li><li><p><code>Collector</code> - 接收 <code>jaeger-agent</code> 发送来的数据，然后将数据写入后端存储。<code>Collector</code> 被设计成无状态的组件，因此您可以同时运行任意数量的 <code>jaeger-collector</code>。</p></li><li><p><code>Data Store</code> - 后端存储被设计成一个可插拔的组件，支持将数据写入 <code>cassandra</code>、<code>elastic search</code>。</p></li><li><p><code>Query</code> - 接收查询请求，然后从后端存储系统中检索 <code>trace</code> 并通过 <code>UI</code> 进行展示。<code>Query</code> 是无状态的，您可以启动多个实例，把它们部署在 <code>nginx</code> 这样的负载均衡器后面。</p></li></ul><h2 id="采样速率"><a href="#采样速率" class="headerlink" title="采样速率"></a>采样速率</h2><p>如果所有的请求都开启 <code>Trace</code> 显然会带来比较大的压力，另外，大量的数据也会带来很大存储压力。为此，<code>jaeger</code> 支持设置采样速率，根据系统实际情况设置合适的采样频率。</p><p><code>Jaeger</code> 官方提供了多种采集策略，可以根据时间情况按需使用</p><ul><li><code>const</code> - 全量采集，采样率设置 <code>0</code>,<code>1</code> 分别对应打开和关闭</li><li><code>probabilistic</code>  - 概率采集，默认万份之一，<code>0~1</code>之间取值，</li><li><code>rateLimiting</code>  - 限速采集，每秒只能采集一定量的数据</li><li><code>remote</code>  - 一种动态采集策略，根据当前系统的访问量调节采集策略</li></ul>]]></content>
      
      
      <categories>
          
          <category> 分布式微服务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链路追踪 </tag>
            
            <tag> Jaeger </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>全链路追踪之OpenTracing</title>
      <link href="/posts/53102.html"/>
      <url>/posts/53102.html</url>
      
        <content type="html"><![CDATA[<h2 id="链路追踪"><a href="#链路追踪" class="headerlink" title="链路追踪"></a>链路追踪</h2><p>现在的大多数互联网服务，基本都是用复杂，大规模分布式集群来实现，微服务化，这些服务模块分布在不同的机器，不同的数据中心，由不同团队，语言开发而成。因此，需要工具帮助理解，分析这些系统、定位问题，做到追踪每一个请求的完整调用链路，收集性能数据，反馈到服务治理中，链路追踪系统应运而生。</p><h2 id="OpenTracing-协议"><a href="#OpenTracing-协议" class="headerlink" title="OpenTracing 协议"></a>OpenTracing 协议</h2><p><a href="http://opentracing.io/">OpenTracing</a>是分布式跟踪系统，当我们把系统拆成服务化，分布式系统的时候，查询一个问题，很可能需要多个登录多台机器。</p><p><code>OpenTracing</code>通过提供平台无关、厂商无关的<code>API</code>，使得开发人员能够方便的添加（或更换）追踪系统的实现。<code>OpenTracing</code>正在为全球的分布式追踪，提供统一的概念和数据标准。</p><h3 id="Trace"><a href="#Trace" class="headerlink" title="Trace"></a>Trace</h3><ul><li><code>OpenTracing</code>中的<code>Trace</code>（调用链）通过归属于此调用链的Span来隐性的定义。</li><li>一条<code>Trace</code>（调用链）可以被认为是一个由多个<code>Span</code>组成的有向无环图（DAG图），<h3 id="Span"><a href="#Span" class="headerlink" title="Span"></a>Span</h3></li><li><code>Span</code>可以被翻译为跨度，可以被理解为一次方法调用, 一个程序块的调用, 或者一次<code>RPC</code>/数据库访问</li><li>只要是一个具有完整时间周期的程序访问，都可以被认为是一个<code>span</code></li><li><code> Span</code>与<code>Span</code>的关系被命名为<code>References</code>。</li></ul><p>以下是由<code>8</code>个<code>Span</code>组成的<code>Trace</code></p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">单个Trace中，span间的因果关系        <span class="token punctuation">[</span>Span A<span class="token punctuation">]</span>  ←←←<span class="token punctuation">(</span>the root span<span class="token punctuation">)</span>            <span class="token operator">|</span>     +------+------+     <span class="token operator">|</span>             <span class="token operator">|</span> <span class="token punctuation">[</span>Span B<span class="token punctuation">]</span>      <span class="token punctuation">[</span>Span C<span class="token punctuation">]</span> ←←←<span class="token punctuation">(</span>Span C 是 Span A 的孩子节点, ChildOf<span class="token punctuation">)</span>     <span class="token operator">|</span>             <span class="token operator">|</span> <span class="token punctuation">[</span>Span D<span class="token punctuation">]</span>      +---+-------+               <span class="token operator">|</span>           <span class="token operator">|</span>           <span class="token punctuation">[</span>Span E<span class="token punctuation">]</span>    <span class="token punctuation">[</span>Span F<span class="token punctuation">]</span> <span class="token operator">>></span><span class="token operator">></span> <span class="token punctuation">[</span>Span G<span class="token punctuation">]</span> <span class="token operator">>></span><span class="token operator">></span> <span class="token punctuation">[</span>Span H<span class="token punctuation">]</span>                                       ↑                                       ↑                                       ↑                         <span class="token punctuation">(</span>Span G 在 Span F 后被调用, FollowsFrom<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>基于时间轴的时序图</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">单个Trace中，span间的时间关系––<span class="token operator">|</span>–––––––<span class="token operator">|</span>–––––––<span class="token operator">|</span>–––––––<span class="token operator">|</span>–––––––<span class="token operator">|</span>–––––––<span class="token operator">|</span>–––––––<span class="token operator">|</span>–––––––<span class="token operator">|</span>–<span class="token operator">></span> <span class="token function">time</span> <span class="token punctuation">[</span>Span A···················································<span class="token punctuation">]</span>   <span class="token punctuation">[</span>Span B··············································<span class="token punctuation">]</span>      <span class="token punctuation">[</span>Span D··········································<span class="token punctuation">]</span>    <span class="token punctuation">[</span>Span C········································<span class="token punctuation">]</span>         <span class="token punctuation">[</span>Span E·······<span class="token punctuation">]</span>        <span class="token punctuation">[</span>Span F··<span class="token punctuation">]</span> <span class="token punctuation">[</span>Span G··<span class="token punctuation">]</span> <span class="token punctuation">[</span>Span H··<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="span-的结构"><a href="#span-的结构" class="headerlink" title="span 的结构"></a>span 的结构</h3><p><strong>Span</strong></p><ul><li><code>An operation name</code>，操作名称</li><li><code>A start timestamp</code>，起始时间</li><li><code>A finish timestamp</code>，结束时间</li><li><code>Span Tag</code>，一组键值对构成的<code>Span</code>标签集合。键值对中，键必须为<code>string</code>，值可以是字符串，布尔，或者数字类型。</li><li><code>Span Log</code>，一组<code>span</code>的日志集合。<ul><li>每次<code>log</code>操作包含一个键值对，以及一个时间戳。</li><li>键值对中，键必须为<code>string</code>，值可以是任意类型。</li><li>不是所有的支持<code>OpenTracing</code>的<code>Tracer</code>,都需要支持所有的值类型。</li></ul></li><li><code>SpanContext</code>，<code>Span</code>上下文对象</li><li><code>References</code>(<code>Span</code> 间关系)，相关的零个或者多个<code>Span</code>（<code>Span</code>间通过<code>SpanContext</code>建立这种关系）</li></ul><p><strong>SpanContext</strong></p><ul><li>任何一个<code>OpenTracing</code>的实现，都需要将当前调用链的状态（例如：<code>trace</code>和<code>spanId</code>），依赖一个独特的<code>Span</code>去跨进程边界传输</li><li><code>Baggage Items</code>，<code>Trace</code>的随行数据，是一个键值对集合，它存在于<code>trace</code>中，也需要跨进程边界传输</li></ul><h3 id="span-的关系"><a href="#span-的关系" class="headerlink" title="span 的关系"></a>span 的关系</h3><p>一个<code>Span</code>可以与一个或者多个<code>SpanContexts</code>存在因果关系。<code>OpenTracing</code>目前定义了两种关系，这两种关系明确的给出了两个父子关系的<code>Span</code>的因果模型。 </p><ul><li><code>ChildOf</code>（父子）,</li><li> <code>FollowsFrom</code>（跟随）。</li></ul><h4 id="ChildOf"><a href="#ChildOf" class="headerlink" title="ChildOf"></a><strong>ChildOf</strong></h4><p>一个<code>span</code>可能是一个父级<code>span</code>的孩子，即<code>ChildOf</code>关系。在<code>ChildOf</code>引用关系下，父级<code>span</code>某种程度上取决于子<code>span</code>。下面这些情况会构成<code>ChildOf</code>关系：</p><ul><li>一个<code>RPC</code>调用的服务端的<code>span</code>，和<code>RPC</code>服务客户端的<code>span</code>构成<code>ChildOf</code>关系</li><li>一个数据库<code>insert</code>操作的<code>span</code>，和<code>ORM</code>的<code>save</code>方法的<code>span</code>构成<code>ChildOf</code>关系</li><li>很多<code>span</code>可以并行工作（或者分布式工作）都可能是一个父级的<code>span</code>的子项，他会合并所有子<code>span</code>的执行结果，并在指定期限内返回</li></ul><p><code>ChildOf</code>关系的父子节点关系的时序图。</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token punctuation">[</span>-Parent Span---------<span class="token punctuation">]</span>     <span class="token punctuation">[</span>-Child Span----<span class="token punctuation">]</span><span class="token punctuation">[</span>-Parent Span--------------<span class="token punctuation">]</span>     <span class="token punctuation">[</span>-Child Span A----<span class="token punctuation">]</span>      <span class="token punctuation">[</span>-Child Span B----<span class="token punctuation">]</span>    <span class="token punctuation">[</span>-Child Span C----<span class="token punctuation">]</span>     <span class="token punctuation">[</span>-Child Span D---------------<span class="token punctuation">]</span>     <span class="token punctuation">[</span>-Child Span E----<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="FollowsFrom"><a href="#FollowsFrom" class="headerlink" title="FollowsFrom"></a>FollowsFrom</h4><p>一些父级节点不以任何方式依赖他们子节点的执行结果，这种情况下，我们说这些子<code>span</code>和父<code>span</code>之间是<code>FollowsFrom</code>的因果关系。<code>FollowsFrom</code>关系可以被分为很多不同的子类型.</p><p><code>FollowFrom</code>关系的父子节点关系的时序图。</p><pre class="line-numbers language-none"><code class="language-none">[-Parent Span-]  [-Child Span-][-Parent Span--] [-Child Span-][-Parent Span-]            [-Child Span-]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 分布式微服务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链路追踪 </tag>
            
            <tag> OpenTracing </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis 事务</title>
      <link href="/posts/19427.html"/>
      <url>/posts/19427.html</url>
      
        <content type="html"><![CDATA[<h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><p>事务是一组逻辑操作。事务是一个单独的隔离操作：事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。事务是一个原子操作，事务中的命令要么全部被执行，要么全部都不执行。</p><h2 id="四大特性"><a href="#四大特性" class="headerlink" title="四大特性"></a>四大特性</h2><p>事务通常具有以下四大特性，原子性（<code>Atomicity</code>）、一致性（<code>Consistency</code>）、隔离性（<code>Isolation</code>）、持久性（<code>Durability</code>）。</p><ul><li><code>原子性</code>：是指事务是一个不可分割的工作单位，事务中的操作要么都发生，要么都不发生。</li><li><code>一致性</code>：事务前后数据的完整性必须保持一致。</li><li><code>隔离性</code>：多个事务并发执行时，一个事务的执行不应影响其他事务的执行。</li><li><code>持久性</code>：是指一个事务一旦被提交，它对数据库中数据的改变就是永久性的，接下来即使数据库发生故障也不应该对其有任何影响。</li></ul><p><code>Redis</code>的事务总是具有<code>ACID</code>中的一致性和隔离性，其他特性是不支持的。当服务器运行在<code>AOF</code>持久化模式下，并且<code>appendfsync</code>选项的值为<code>always</code>时，事务也具有持久性。</p><h2 id="Redis事务"><a href="#Redis事务" class="headerlink" title="Redis事务"></a>Redis事务</h2><p><code>Redis</code> 事务的本质是<code>MULTI</code>、<code>EXEC</code>、<code>WATCH</code>等一组命令的集合。事务支持一次执行多个命令，一个事务中所有命令都会被序列化。在事务执行过程，会按照顺序串行化执行队列中的命令，其他客户端提交的命令请求不会插入到事务执行命令序列中。总的来说：</p><blockquote><p>redis事务就是一次性、顺序性、排他性的执行一个队列中的一系列命令。</p></blockquote><h2 id="Redis事务的三个阶段"><a href="#Redis事务的三个阶段" class="headerlink" title="Redis事务的三个阶段"></a>Redis事务的三个阶段</h2><ul><li>事务开始 <code>MULTI</code></li><li>命令入队</li><li>事务执行 <code>EXEC</code></li></ul><p>事务执行过程中，如果服务端收到有<code>EXEC</code>、<code>DISCARD</code>、<code>WATCH</code>、<code>MULTI</code>之外的请求，将会把请求放入队列中排队</p><h2 id="Redis事务相关命令"><a href="#Redis事务相关命令" class="headerlink" title="Redis事务相关命令"></a>Redis事务相关命令</h2><p><code>Redis</code>事务功能是通过<code>MULTI</code>、<code>EXEC</code>、<code>DISCARD</code>和 <code>WATCH</code> 四个原语实现的，<code>Redis</code>会将一个事务中的所有命令序列化，然后按顺序执行。</p><ol><li><code>Redis</code> 不支持回滚，<code>Redis 在事务失败时不进行回滚，而是继续执行余下的命令</code>， 这是 <code>Redis</code> 的内部可以保持简单且快速的原因。</li><li>如果在一个事务中的命令出现错误，那么所有的命令都不会执行；</li><li>如果在一个事务中出现运行错误，那么正确的命令会被执行。<h3 id="WATCH"><a href="#WATCH" class="headerlink" title="WATCH"></a><code>WATCH</code></h3>这是一个乐观锁，可以为 <code>Redis</code> 事务提供（<code>CAS</code>）行为。可以监控一个或多个键，如果在事务执行之前，被监视的key被其他命令修改（或删除），则事务被打断（类似乐观锁），之后的事务就不会执行，监控一直持续到<code>EXEC</code>命令。<h3 id="MULTI"><a href="#MULTI" class="headerlink" title="MULTI"></a><code>MULTI</code></h3>用于开启一个事务（标记一个事务块的开始），它总是返回<code>OK</code>。<code>MULTI</code>执行之后，客户端可以继续向服务器发送任意多条命令，这些命令不会立即被执行，而是被放到一个队列中，当<code>EXEC</code>命令被调用时，所有队列中的命令才会被执行。<h3 id="EXEC"><a href="#EXEC" class="headerlink" title="EXEC"></a><code>EXEC</code></h3>执行所有事务块内的命令。返回事务块内所有命令的返回值，按命令执行的先后顺序排列。当操作被打断时，返回空值 <code>nil</code>。（一旦执行<code>exec</code>后，之前加的监控锁<code>watch</code>都会被取消掉）<h3 id="DISCARD"><a href="#DISCARD" class="headerlink" title="DISCARD"></a><code>DISCARD</code></h3>通过调用<code>DISCARD</code>，客户端可以清空事务队列，并放弃执行事务， 并且客户端会从事务状态中退出。<h3 id="UNWATCH"><a href="#UNWATCH" class="headerlink" title="UNWATCH"></a><code>UNWATCH</code></h3>可以取消<code>watch</code>对所有<code>key</code>的监控。</li></ol><h2 id="隔离性"><a href="#隔离性" class="headerlink" title="隔离性"></a>隔离性</h2><p><code>Redis</code> 是单进程程序，并且它保证在执行事务时，不会对事务进行中断，事务可以运行直到执行完所有事务队列中的命令为止。因此，<code>Redis</code> 的事务是总是带有隔离性的。</p><h2 id="没有隔离级别"><a href="#没有隔离级别" class="headerlink" title="没有隔离级别"></a>没有隔离级别</h2><p><code>Redis</code>事务没有隔离级别的概念，批量操作在发送 <code>EXEC</code> 命令前被放入队列缓存，并不会被实际执行，也就不存在事务内的查询要看到事务里的更新，事务外查询不能看到。</p><h2 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h2><p>单条命令是原子性执行的，但事务不保证原子性，且没有回滚。事务中任意命令执行失败，其余的命令仍会被执行。</p><h2 id="Redis事务其他实现"><a href="#Redis事务其他实现" class="headerlink" title="Redis事务其他实现"></a>Redis事务其他实现</h2><p>基于<code>Lua</code>脚本，<code>Redis</code>可以保证脚本内的命令一次性、按顺序地执行，其同时也不提供事务运行错误的回滚，执行过程中如果部分命令运行错误，剩下的命令还是会继续运行完</p>]]></content>
      
      
      <categories>
          
          <category> 缓存 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 事务 </tag>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>http 库的服务端实现</title>
      <link href="/posts/23490.html"/>
      <url>/posts/23490.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><a href="https://blog.csdn.net/upstream480/article/details/128354324">net/http 库的客户端实现(上)</a></p><p><a href="https://blog.csdn.net/upstream480/article/details/128429174">net/http 库的客户端实现(下)</a></p><p>net/http 库的服务端实现</p><p>上两篇文章介绍了 http 客户端的实现，这篇文章看一下服务端的实现</p><h2 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h2><p>使用 <code>net/http</code> 库可以快速搭建<code>HTTP</code>服务，<code>HTTP</code>服务端主要包含两部分：</p><ul><li><p>注册处理器：<code>net/http.HandleFunc</code>函数用于注册处理器</p></li><li><p>监听端口：<code>net/http.ListenAndServe</code>用于处理请求</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token punctuation">(</span>  <span class="token string">"fmt"</span>  <span class="token string">"net/http"</span><span class="token punctuation">)</span><span class="token keyword">func</span> <span class="token function">hello</span><span class="token punctuation">(</span>w http<span class="token punctuation">.</span>ResponseWriter<span class="token punctuation">,</span> r <span class="token operator">*</span>http<span class="token punctuation">.</span>Request<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  fmt<span class="token punctuation">.</span><span class="token function">Fprintln</span><span class="token punctuation">(</span>w<span class="token punctuation">,</span> <span class="token string">"Hello World"</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  http<span class="token punctuation">.</span><span class="token function">HandleFunc</span><span class="token punctuation">(</span><span class="token string">"/hello"</span><span class="token punctuation">,</span> hello<span class="token punctuation">)</span>  http<span class="token punctuation">.</span><span class="token function">ListenAndServe</span><span class="token punctuation">(</span><span class="token string">":8080"</span><span class="token punctuation">,</span> <span class="token boolean">nil</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="注册处理器"><a href="#注册处理器" class="headerlink" title="注册处理器"></a>注册处理器</h2><p>直接调用<code>net/http.HandleFunc</code>可以注册路由和处理函数：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">HandleFunc</span><span class="token punctuation">(</span>pattern <span class="token builtin">string</span><span class="token punctuation">,</span> handler <span class="token keyword">func</span><span class="token punctuation">(</span>ResponseWriter<span class="token punctuation">,</span> <span class="token operator">*</span>Request<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>DefaultServeMux<span class="token punctuation">.</span><span class="token function">HandleFunc</span><span class="token punctuation">(</span>pattern<span class="token punctuation">,</span> handler<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>我们调用<code>http.HandleFunc(&quot;/hello&quot;, hello)</code>注册路径处理函数，这里将路径<code>/hello</code>的处理函数设置为<code>hello</code>。处理函数的类型必须是：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token punctuation">(</span>http<span class="token punctuation">.</span>ResponseWriter<span class="token punctuation">,</span> <span class="token operator">*</span>http<span class="token punctuation">.</span>Request<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>它调用<code>HTTP</code>服务起的<code>DefaultServeMux</code>处理请求，<code>DefaultServeMux</code>本质是<code>ServeMux</code>：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">type</span> ServeMux <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>    mu    sync<span class="token punctuation">.</span>RWMutex  <span class="token comment">// 读写锁，保证并发安全，注册处理器时会加写锁做保护</span>    m     <span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">]</span>muxEntry <span class="token comment">// 路由规则，一个string对应一个mux实体，这里的string就是注册的路由表达式</span>    es    <span class="token punctuation">[</span><span class="token punctuation">]</span>muxEntry <span class="token comment">// slice of entries sorted from longest to shortest.</span>    hosts <span class="token builtin">bool</span>       <span class="token comment">// whether any patterns contain hostnames</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><code>**mu**</code>：需要加读写锁保证并发安全，注册处理器时会加写锁保证写<code>map</code>的数据正确性，这个<code>map</code>就是<code>pattern</code>和<code>handler</code>；</p></li><li><p><code>**m**</code>：存储路由规则，<code>key</code>就是<code>pattern</code>，<code>value</code>是<code>muEntry</code>实体，<code>muEntry</code>实体中包含：<code>pattern</code>和<code>handler</code></p></li><li><p><code>**es**</code>：存储的也是<code>muxEntry</code>实体，因为我们使用<code>map</code>存储路由和<code>handler</code>的对应关系，所以只能索引静态路由，并不支持<code>[path_param]</code>，所以这块的作用是当在<code>map</code>中没有找到匹配的路由时，会遍历这个切片进行前缀匹配，这个切片按照路由长度进行排序；</p></li><li><p><code>**hosts**</code>：这个也是用来应对特殊<code>case</code>，如果我们注册的路由没有以<code>/</code>开始，那么就认为我们注册的路由包含<code>host</code>，所以路由匹配时需要加上<code>host</code>；</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token punctuation">(</span>mux <span class="token operator">*</span>ServeMux<span class="token punctuation">)</span> <span class="token function">Handle</span><span class="token punctuation">(</span>pattern <span class="token builtin">string</span><span class="token punctuation">,</span> handler Handler<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token comment">// 加锁，保证并发安全</span>mux<span class="token punctuation">.</span>mu<span class="token punctuation">.</span><span class="token function">Lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">defer</span> mux<span class="token punctuation">.</span>mu<span class="token punctuation">.</span><span class="token function">Unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">if</span> pattern <span class="token operator">==</span> <span class="token string">""</span> <span class="token punctuation">&#123;</span><span class="token function">panic</span><span class="token punctuation">(</span><span class="token string">"http: invalid pattern"</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token keyword">if</span> handler <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span><span class="token function">panic</span><span class="token punctuation">(</span><span class="token string">"http: nil handler"</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token keyword">if</span> <span class="token boolean">_</span><span class="token punctuation">,</span> exist <span class="token operator">:=</span> mux<span class="token punctuation">.</span>m<span class="token punctuation">[</span>pattern<span class="token punctuation">]</span><span class="token punctuation">;</span> exist <span class="token punctuation">&#123;</span><span class="token function">panic</span><span class="token punctuation">(</span><span class="token string">"http: multiple registrations for "</span> <span class="token operator">+</span> pattern<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token keyword">if</span> mux<span class="token punctuation">.</span>m <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>mux<span class="token punctuation">.</span>m <span class="token operator">=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">]</span>muxEntry<span class="token punctuation">)</span><span class="token punctuation">&#125;</span>e <span class="token operator">:=</span> muxEntry<span class="token punctuation">&#123;</span>h<span class="token punctuation">:</span> handler<span class="token punctuation">,</span> pattern<span class="token punctuation">:</span> pattern<span class="token punctuation">&#125;</span><span class="token comment">// map存储路由和处理函数的映射</span>mux<span class="token punctuation">.</span>m<span class="token punctuation">[</span>pattern<span class="token punctuation">]</span> <span class="token operator">=</span> e<span class="token comment">// 如果路由最后加了`/`放入到切片后在路由匹配时做前缀匹配</span><span class="token keyword">if</span> pattern<span class="token punctuation">[</span><span class="token function">len</span><span class="token punctuation">(</span>pattern<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'/'</span> <span class="token punctuation">&#123;</span>mux<span class="token punctuation">.</span>es <span class="token operator">=</span> <span class="token function">appendSorted</span><span class="token punctuation">(</span>mux<span class="token punctuation">.</span>es<span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token comment">// 如果路由第一位不是/,则认为注册的路由加上了host，所以在路由匹配时使用host+path进行匹配；</span><span class="token keyword">if</span> pattern<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token string">'/'</span> <span class="token punctuation">&#123;</span>mux<span class="token punctuation">.</span>hosts <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h2 id="监听端口"><a href="#监听端口" class="headerlink" title="监听端口"></a>监听端口</h2><p>net/http库提供了ListenAndServe()用来监听TCP连接并处理请求：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">ListenAndServe</span><span class="token punctuation">(</span>addr <span class="token builtin">string</span><span class="token punctuation">,</span> handler Handler<span class="token punctuation">)</span> <span class="token builtin">error</span> <span class="token punctuation">&#123;</span>    server <span class="token operator">:=</span> <span class="token operator">&amp;</span>Server<span class="token punctuation">&#123;</span>Addr<span class="token punctuation">:</span> addr<span class="token punctuation">,</span> Handler<span class="token punctuation">:</span> handler<span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> server<span class="token punctuation">.</span><span class="token function">ListenAndServe</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>在这里初始化Server结构，然后调用ListenAndServe：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token punctuation">(</span>srv <span class="token operator">*</span>Server<span class="token punctuation">)</span> <span class="token function">ListenAndServe</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">error</span> <span class="token punctuation">&#123;</span><span class="token keyword">if</span> srv<span class="token punctuation">.</span><span class="token function">shuttingDown</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> ErrServerClosed<span class="token punctuation">&#125;</span>addr <span class="token operator">:=</span> srv<span class="token punctuation">.</span>Addr<span class="token keyword">if</span> addr <span class="token operator">==</span> <span class="token string">""</span> <span class="token punctuation">&#123;</span>addr <span class="token operator">=</span> <span class="token string">":http"</span><span class="token punctuation">&#125;</span><span class="token comment">// 调用 net 进行 tcp 连接</span>ln<span class="token punctuation">,</span> err <span class="token operator">:=</span> net<span class="token punctuation">.</span><span class="token function">Listen</span><span class="token punctuation">(</span><span class="token string">"tcp"</span><span class="token punctuation">,</span> addr<span class="token punctuation">)</span><span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> err<span class="token punctuation">&#125;</span><span class="token keyword">return</span> srv<span class="token punctuation">.</span><span class="token function">Serve</span><span class="token punctuation">(</span>ln<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里调用<code>net</code>网络库进行<code>tcp</code>连接，包含了创建<code>socket</code>、<code>bind</code>绑定<code>socket</code>与地址，<code>listen</code>端口的操作，最后调用<code>Serve</code>方法循环等待客户端的请求：<br><img src="https://img-blog.csdnimg.cn/img_convert/43b725b62eb20aca20dad2aca324a733.png" alt="image.png"><br>可以看到，每个<code>HTTP</code>请求服务端都会单独创建一个<code>goroutine</code>来处理请求，我们看一下处理过程：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token punctuation">(</span>c <span class="token operator">*</span>conn<span class="token punctuation">)</span> <span class="token function">serve</span><span class="token punctuation">(</span>ctx context<span class="token punctuation">.</span>Context<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>c<span class="token punctuation">.</span>remoteAddr <span class="token operator">=</span> c<span class="token punctuation">.</span>rwc<span class="token punctuation">.</span><span class="token function">RemoteAddr</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">String</span><span class="token punctuation">(</span><span class="token punctuation">)</span>ctx <span class="token operator">=</span> context<span class="token punctuation">.</span><span class="token function">WithValue</span><span class="token punctuation">(</span>ctx<span class="token punctuation">,</span> LocalAddrContextKey<span class="token punctuation">,</span> c<span class="token punctuation">.</span>rwc<span class="token punctuation">.</span><span class="token function">LocalAddr</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">var</span> inFlightResponse <span class="token operator">*</span>response<span class="token keyword">defer</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token comment">// 添加recover函数防止panic引发主程序挂掉；</span><span class="token keyword">if</span> err <span class="token operator">:=</span> <span class="token function">recover</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token operator">&amp;&amp;</span> err <span class="token operator">!=</span> ErrAbortHandler <span class="token punctuation">&#123;</span><span class="token keyword">const</span> size <span class="token operator">=</span> <span class="token number">64</span> <span class="token operator">&lt;&lt;</span> <span class="token number">10</span>buf <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span><span class="token punctuation">,</span> size<span class="token punctuation">)</span>buf <span class="token operator">=</span> buf<span class="token punctuation">[</span><span class="token punctuation">:</span>runtime<span class="token punctuation">.</span><span class="token function">Stack</span><span class="token punctuation">(</span>buf<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">]</span>c<span class="token punctuation">.</span>server<span class="token punctuation">.</span><span class="token function">logf</span><span class="token punctuation">(</span><span class="token string">"http: panic serving %v: %v\n%s"</span><span class="token punctuation">,</span> c<span class="token punctuation">.</span>remoteAddr<span class="token punctuation">,</span> err<span class="token punctuation">,</span> buf<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">// HTTP/1.x from here on.</span>ctx<span class="token punctuation">,</span> cancelCtx <span class="token operator">:=</span> context<span class="token punctuation">.</span><span class="token function">WithCancel</span><span class="token punctuation">(</span>ctx<span class="token punctuation">)</span>c<span class="token punctuation">.</span>cancelCtx <span class="token operator">=</span> cancelCtx<span class="token keyword">defer</span> <span class="token function">cancelCtx</span><span class="token punctuation">(</span><span class="token punctuation">)</span>c<span class="token punctuation">.</span>r <span class="token operator">=</span> <span class="token operator">&amp;</span>connReader<span class="token punctuation">&#123;</span>conn<span class="token punctuation">:</span> c<span class="token punctuation">&#125;</span>c<span class="token punctuation">.</span>bufr <span class="token operator">=</span> <span class="token function">newBufioReader</span><span class="token punctuation">(</span>c<span class="token punctuation">.</span>r<span class="token punctuation">)</span>c<span class="token punctuation">.</span>bufw <span class="token operator">=</span> <span class="token function">newBufioWriterSize</span><span class="token punctuation">(</span>checkConnErrorWriter<span class="token punctuation">&#123;</span>c<span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token operator">&lt;&lt;</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token keyword">for</span> <span class="token punctuation">&#123;</span><span class="token comment">// 读取请求，从连接中获取HTTP请求并构建一个实现了`net/http.Conn.ResponseWriter`接口的变量`net/http.response`</span>w<span class="token punctuation">,</span> err <span class="token operator">:=</span> c<span class="token punctuation">.</span><span class="token function">readRequest</span><span class="token punctuation">(</span>ctx<span class="token punctuation">)</span><span class="token keyword">if</span> c<span class="token punctuation">.</span>r<span class="token punctuation">.</span>remain <span class="token operator">!=</span> c<span class="token punctuation">.</span>server<span class="token punctuation">.</span><span class="token function">initialReadLimitSize</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>c<span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span>c<span class="token punctuation">.</span>rwc<span class="token punctuation">,</span> StateActive<span class="token punctuation">,</span> runHooks<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token comment">// 处理请求</span>serverHandler<span class="token punctuation">&#123;</span>c<span class="token punctuation">.</span>server<span class="token punctuation">&#125;</span><span class="token punctuation">.</span><span class="token function">ServeHTTP</span><span class="token punctuation">(</span>w<span class="token punctuation">,</span> w<span class="token punctuation">.</span>req<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>继续跟踪<code>ServeHTTP</code>方法，<code>ServeMux</code>是一个<code>HTTP</code>请求的多路复用器，在这里可以根据请求的<code>URL</code>匹配合适的处理器</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token punctuation">(</span>mux <span class="token operator">*</span>ServeMux<span class="token punctuation">)</span> <span class="token function">ServeHTTP</span><span class="token punctuation">(</span>w ResponseWriter<span class="token punctuation">,</span> r <span class="token operator">*</span>Request<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">if</span> r<span class="token punctuation">.</span>RequestURI <span class="token operator">==</span> <span class="token string">"*"</span> <span class="token punctuation">&#123;</span><span class="token keyword">if</span> r<span class="token punctuation">.</span><span class="token function">ProtoAtLeast</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>w<span class="token punctuation">.</span><span class="token function">Header</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Set</span><span class="token punctuation">(</span><span class="token string">"Connection"</span><span class="token punctuation">,</span> <span class="token string">"close"</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span>w<span class="token punctuation">.</span><span class="token function">WriteHeader</span><span class="token punctuation">(</span>StatusBadRequest<span class="token punctuation">)</span><span class="token keyword">return</span><span class="token punctuation">&#125;</span><span class="token comment">// 进行路由匹配，获取注册的处理函数</span>h<span class="token punctuation">,</span> <span class="token boolean">_</span> <span class="token operator">:=</span> mux<span class="token punctuation">.</span><span class="token function">Handler</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span><span class="token comment">// 这块就是执行我们注册的handler，也就是例子中的getProfile()</span>h<span class="token punctuation">.</span><span class="token function">ServeHTTP</span><span class="token punctuation">(</span>w<span class="token punctuation">,</span> r<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="路由匹配"><a href="#路由匹配" class="headerlink" title="路由匹配"></a>路由匹配</h2><p><code>mux.Handler()</code>中是路由匹配的代码</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token punctuation">(</span>mux <span class="token operator">*</span>ServeMux<span class="token punctuation">)</span> <span class="token function">handler</span><span class="token punctuation">(</span>host<span class="token punctuation">,</span> path <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>h Handler<span class="token punctuation">,</span> pattern <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>mux<span class="token punctuation">.</span>mu<span class="token punctuation">.</span><span class="token function">RLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">defer</span> mux<span class="token punctuation">.</span>mu<span class="token punctuation">.</span><span class="token function">RUnlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">// Host-specific pattern takes precedence over generic ones</span><span class="token keyword">if</span> mux<span class="token punctuation">.</span>hosts <span class="token punctuation">&#123;</span>h<span class="token punctuation">,</span> pattern <span class="token operator">=</span> mux<span class="token punctuation">.</span><span class="token function">match</span><span class="token punctuation">(</span>host <span class="token operator">+</span> path<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token keyword">if</span> h <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>h<span class="token punctuation">,</span> pattern <span class="token operator">=</span> mux<span class="token punctuation">.</span><span class="token function">match</span><span class="token punctuation">(</span>path<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token keyword">if</span> h <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>h<span class="token punctuation">,</span> pattern <span class="token operator">=</span> <span class="token function">NotFoundHandler</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">""</span><span class="token punctuation">&#125;</span><span class="token keyword">return</span><span class="token punctuation">&#125;</span><span class="token keyword">func</span> <span class="token punctuation">(</span>mux <span class="token operator">*</span>ServeMux<span class="token punctuation">)</span> <span class="token function">match</span><span class="token punctuation">(</span>path <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>h Handler<span class="token punctuation">,</span> pattern <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token comment">// 先从map中查找</span>v<span class="token punctuation">,</span> ok <span class="token operator">:=</span> mux<span class="token punctuation">.</span>m<span class="token punctuation">[</span>path<span class="token punctuation">]</span><span class="token keyword">if</span> ok <span class="token punctuation">&#123;</span><span class="token comment">// 找打了返回注册的函数</span><span class="token keyword">return</span> v<span class="token punctuation">.</span>h<span class="token punctuation">,</span> v<span class="token punctuation">.</span>pattern<span class="token punctuation">&#125;</span><span class="token comment">// 从切片中进行前缀匹配</span><span class="token keyword">for</span> <span class="token boolean">_</span><span class="token punctuation">,</span> e <span class="token operator">:=</span> <span class="token keyword">range</span> mux<span class="token punctuation">.</span>es <span class="token punctuation">&#123;</span><span class="token keyword">if</span> strings<span class="token punctuation">.</span><span class="token function">HasPrefix</span><span class="token punctuation">(</span>path<span class="token punctuation">,</span> e<span class="token punctuation">.</span>pattern<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> e<span class="token punctuation">.</span>h<span class="token punctuation">,</span> e<span class="token punctuation">.</span>pattern<span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">return</span> <span class="token boolean">nil</span><span class="token punctuation">,</span> <span class="token string">""</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>服务端的代码看主逻辑主要是看两部分，</p><ul><li>一个是注册处理器，标准库使用<code>map</code>进行存储，本质是一个静态索引，同时维护了一个切片，用来做前缀匹配，只要以<code>/</code>结尾的，都会在切片中存储；</li><li>服务端监听端口本质也是使用net网络库进行<code>TCP</code>连接，然后监听对应的<code>TCP</code>连接，每一个<code>HTTP</code>请求都会开一个<code>goroutine</code>去处理请求，所以如果有海量请求，会在一瞬间创建大量的<code>goroutine</code>，这个是一个性能瓶颈点。</li></ul>]]></content>
      
      
      <categories>
          
          <category> go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> net/http </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>net/http 库的客户端实现(下)</title>
      <link href="/posts/1571.html"/>
      <url>/posts/1571.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><a href="https://blog.csdn.net/upstream480/article/details/128354324">net/http 库的客户端实现(上)</a></p><p>net/http 库的客户端实现(下)</p><p><a href="https://blog.csdn.net/upstream480/article/details/128429477">net/http 库的服务端实现</a></p><p>上一篇文章我们讲了 <code>net/http</code> 库客户端 request 的构建，接下来继续讲构建<code>HTTP</code>请求之后的处理操作<br><a href="https://blog.csdn.net/upstream480/article/details/128354324">net/http 库的客户端实现(上)</a></p><h2 id="启动事务"><a href="#启动事务" class="headerlink" title="启动事务"></a>启动事务</h2><p>构建 <code>HTTP</code> 请求后，接着需要开启<code>HTTP</code>事务进行请求并且等待远程响应，以<code>net/http.Client.Do()</code>方法为例子，理一下它的调用链路：</p><ul><li>net/http.Client.Do()</li><li>net/http.Client.do()</li><li>net/http.Client.send()</li><li>net/http.Send()</li><li>net/http.Transport.RoundTrip()</li></ul><p><code>RoundTrip()</code>是<code>RoundTripper</code>类型中的一个的方法，<code>net/http.Transport</code>是其中的一个实现，可以在<code>net/http/transport.go</code>文件中找到这个方法，看一下源码。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token punctuation">(</span>t <span class="token operator">*</span>Transport<span class="token punctuation">)</span> <span class="token function">roundTrip</span><span class="token punctuation">(</span>req <span class="token operator">*</span>Request<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token operator">*</span>Response<span class="token punctuation">,</span> <span class="token builtin">error</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token comment">// 省略</span><span class="token keyword">for</span> <span class="token punctuation">&#123;</span><span class="token comment">// 检测 ctx 退出信号</span><span class="token keyword">select</span> <span class="token punctuation">&#123;</span><span class="token keyword">case</span> <span class="token operator">&lt;-</span>ctx<span class="token punctuation">.</span><span class="token function">Done</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>req<span class="token punctuation">.</span><span class="token function">closeBody</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">return</span> <span class="token boolean">nil</span><span class="token punctuation">,</span> ctx<span class="token punctuation">.</span><span class="token function">Err</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">default</span><span class="token punctuation">:</span><span class="token punctuation">&#125;</span><span class="token comment">// 获取连接，通过使用连接池对资源进行了复用；</span>pconn<span class="token punctuation">,</span> err <span class="token operator">:=</span> t<span class="token punctuation">.</span><span class="token function">getConn</span><span class="token punctuation">(</span>treq<span class="token punctuation">,</span> cm<span class="token punctuation">)</span><span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>t<span class="token punctuation">.</span><span class="token function">setReqCanceler</span><span class="token punctuation">(</span>cancelKey<span class="token punctuation">,</span> <span class="token boolean">nil</span><span class="token punctuation">)</span>req<span class="token punctuation">.</span><span class="token function">closeBody</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">return</span> <span class="token boolean">nil</span><span class="token punctuation">,</span> err<span class="token punctuation">&#125;</span><span class="token keyword">var</span> resp <span class="token operator">*</span>Response<span class="token keyword">if</span> pconn<span class="token punctuation">.</span>alt <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span><span class="token comment">// HTTP/2 path.</span>t<span class="token punctuation">.</span><span class="token function">setReqCanceler</span><span class="token punctuation">(</span>cancelKey<span class="token punctuation">,</span> <span class="token boolean">nil</span><span class="token punctuation">)</span> <span class="token comment">// not cancelable with CancelRequest</span>resp<span class="token punctuation">,</span> err <span class="token operator">=</span> pconn<span class="token punctuation">.</span>alt<span class="token punctuation">.</span><span class="token function">RoundTrip</span><span class="token punctuation">(</span>req<span class="token punctuation">)</span><span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span><span class="token comment">// 处理响应</span>resp<span class="token punctuation">,</span> err <span class="token operator">=</span> pconn<span class="token punctuation">.</span><span class="token function">roundTrip</span><span class="token punctuation">(</span>treq<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token keyword">if</span> err <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>resp<span class="token punctuation">.</span>Request <span class="token operator">=</span> origReq<span class="token keyword">return</span> resp<span class="token punctuation">,</span> <span class="token boolean">nil</span><span class="token punctuation">&#125;</span><span class="token comment">// Rewind the body if we're able to.</span>req<span class="token punctuation">,</span> err <span class="token operator">=</span> <span class="token function">rewindBody</span><span class="token punctuation">(</span>req<span class="token punctuation">)</span><span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> <span class="token boolean">nil</span><span class="token punctuation">,</span> err<span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>重点看两部分</p><ul><li><code>net/http.Transport.getConn()</code>获取连接</li><li><code>net/http.persistConn.roundTrip()</code>处理写入 <code>HTTP</code> 请求，并在<code>select</code>中等待响应的返回</li></ul><h2 id="获取连接-getConn"><a href="#获取连接-getConn" class="headerlink" title="获取连接(getConn)"></a>获取连接(getConn)</h2><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token punctuation">(</span>t <span class="token operator">*</span>Transport<span class="token punctuation">)</span> <span class="token function">getConn</span><span class="token punctuation">(</span>treq <span class="token operator">*</span>transportRequest<span class="token punctuation">,</span> cm connectMethod<span class="token punctuation">)</span> <span class="token punctuation">(</span>pc <span class="token operator">*</span>persistConn<span class="token punctuation">,</span> err <span class="token builtin">error</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> req <span class="token operator">:=</span> treq<span class="token punctuation">.</span>Request trace <span class="token operator">:=</span> treq<span class="token punctuation">.</span>trace ctx <span class="token operator">:=</span> req<span class="token punctuation">.</span><span class="token function">Context</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">if</span> trace <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token operator">&amp;&amp;</span> trace<span class="token punctuation">.</span>GetConn <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>  trace<span class="token punctuation">.</span><span class="token function">GetConn</span><span class="token punctuation">(</span>cm<span class="token punctuation">.</span><span class="token function">addr</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#125;</span> w <span class="token operator">:=</span> <span class="token operator">&amp;</span>wantConn<span class="token punctuation">&#123;</span>  cm<span class="token punctuation">:</span>         cm<span class="token punctuation">,</span>  key<span class="token punctuation">:</span>        cm<span class="token punctuation">.</span><span class="token function">key</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>  ctx<span class="token punctuation">:</span>        ctx<span class="token punctuation">,</span>  ready<span class="token punctuation">:</span>      <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token keyword">struct</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span>  beforeDial<span class="token punctuation">:</span> testHookPrePendingDial<span class="token punctuation">,</span>  afterDial<span class="token punctuation">:</span>  testHookPostPendingDial<span class="token punctuation">,</span> <span class="token punctuation">&#125;</span> <span class="token keyword">defer</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>   w<span class="token punctuation">.</span><span class="token function">cancel</span><span class="token punctuation">(</span>t<span class="token punctuation">,</span> err<span class="token punctuation">)</span>  <span class="token punctuation">&#125;</span> <span class="token punctuation">&#125;</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 在队列中有闲置连接，直接返回</span> <span class="token keyword">if</span> delivered <span class="token operator">:=</span> t<span class="token punctuation">.</span><span class="token function">queueForIdleConn</span><span class="token punctuation">(</span>w<span class="token punctuation">)</span><span class="token punctuation">;</span> delivered <span class="token punctuation">&#123;</span>  pc <span class="token operator">:=</span> w<span class="token punctuation">.</span>pc  <span class="token keyword">return</span> pc<span class="token punctuation">,</span> <span class="token boolean">nil</span> <span class="token punctuation">&#125;</span> cancelc <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token builtin">error</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span> t<span class="token punctuation">.</span><span class="token function">setReqCanceler</span><span class="token punctuation">(</span>treq<span class="token punctuation">.</span>cancelKey<span class="token punctuation">,</span> <span class="token keyword">func</span><span class="token punctuation">(</span>err <span class="token builtin">error</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> cancelc <span class="token operator">&lt;-</span> err <span class="token punctuation">&#125;</span><span class="token punctuation">)</span> <span class="token comment">// 放到队列中等待建立新的连接</span> t<span class="token punctuation">.</span><span class="token function">queueForDial</span><span class="token punctuation">(</span>w<span class="token punctuation">)</span> <span class="token comment">// 阻塞等待连接</span> <span class="token keyword">select</span> <span class="token punctuation">&#123;</span> <span class="token keyword">case</span> <span class="token operator">&lt;-</span>w<span class="token punctuation">.</span>ready<span class="token punctuation">:</span>  <span class="token keyword">return</span> w<span class="token punctuation">.</span>pc<span class="token punctuation">,</span> w<span class="token punctuation">.</span>err <span class="token keyword">case</span> <span class="token operator">&lt;-</span>req<span class="token punctuation">.</span>Cancel<span class="token punctuation">:</span>  <span class="token keyword">return</span> <span class="token boolean">nil</span><span class="token punctuation">,</span> errRequestCanceledConn <span class="token keyword">case</span> <span class="token operator">&lt;-</span>req<span class="token punctuation">.</span><span class="token function">Context</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Done</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>  <span class="token keyword">return</span> <span class="token boolean">nil</span><span class="token punctuation">,</span> req<span class="token punctuation">.</span><span class="token function">Context</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Err</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">case</span> err <span class="token operator">:=</span> <span class="token operator">&lt;-</span>cancelc<span class="token punctuation">:</span>  <span class="token keyword">if</span> err <span class="token operator">==</span> errRequestCanceled <span class="token punctuation">&#123;</span>   err <span class="token operator">=</span> errRequestCanceledConn  <span class="token punctuation">&#125;</span>  <span class="token keyword">return</span> <span class="token boolean">nil</span><span class="token punctuation">,</span> err <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://img-blog.csdnimg.cn/img_convert/520a28928669760a0b12da6b6e04a1fd.png" alt="image.png"><br>因为连接的建议会消耗比较多的时间，带来较大的开下，所以Go语言使用了连接池对资源进行分配和复用，先调用 <code>net/http.Transport.queueForIdleConn()</code> 获取等待闲置的连接，如果没有获取到在调用<code>net/http.Transport.queueForDial</code> 在队列中等待建立新的连接，通过<code>select</code>监听连接是否建立完毕，超时未获取到连接会上剖错误，我们继续在<code>queueForDial</code>追踪<code>TCP</code>连接的建立：<br><img src="https://img-blog.csdnimg.cn/img_convert/ca040276646192834f5178257f842aa3.png" alt="image.png"></p><p>启动一个<code>goroutine</code>做<code>tcp</code>的建连，最终调用<code>dialConn</code>方法，在这个方法内做持久化连接，调用<code>net</code>库的<code>dial</code>方法进行<code>TCP</code>连接：<br><img src="https://img-blog.csdnimg.cn/img_convert/fdb20c419fe36f0bf15e01b9426d53c6.png" alt="image.png"><br>在连接建立后，代码中我们我们还看到分别启动了两个<code>goroutine</code>，</p><ul><li><code>readLoop</code>用于从<code>tcp</code>连接中读取数据，</li><li><code>writeLoop</code>用于从<code>tcp</code>连接中写入数据；</li></ul><p><code>writeLoop</code>方法监听<code>writech</code>通道，在循环中写入发送的数据。<br><img src="https://img-blog.csdnimg.cn/img_convert/8f93b0315a6a8d20e5697ccef4808f12.png" alt="image.png"></p><p><code>net/http.Transport&#123;&#125;</code>中提供了连接池配置参数，可以自定义</p><h2 id="处理-HTTP-请求"><a href="#处理-HTTP-请求" class="headerlink" title="处理 HTTP 请求"></a>处理 HTTP 请求</h2><p><code>net/http.persistConn.roundTrip()</code> 处理HTTP请求<br><img src="https://img-blog.csdnimg.cn/img_convert/84cd0121f26ffa0e8011af14edaec6d1.png" alt="image.png"></p><p><img src="https://img-blog.csdnimg.cn/img_convert/14483d090ea7851df8ab24a352fe3b5b.png" alt="image.png"><br><strong>有两个通道：</strong></p><ul><li><p><code>pc.writech</code> ：其类型是<code>chan writeRequest </code>，<code>writeLoop</code>协程会循环写入数据，<code>net/http.Request.write</code>会根据<code>net/http.Request</code>结构中的字段按照<code>HTTP</code>协议组成<code>TCP</code>数据段，<code>TCP</code>协议栈会负责将<code>HTTP</code>请求中的内容发送到目标服务器上；</p></li><li><p><code>pc.reqch</code>：其类型是<code>chan requestAndChan</code>，<code>readLoop</code>协程会循环读取响应数据并且调用<code>net/http.ReadResponse</code>进行协议解析，其中包含状态码、协议版本、请求头等内容；</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2></li><li><p><code>net/http.Client</code>是级别最高的抽象，其中<code>transport</code>用于开启<code>HTTP</code>事务，<code>jar</code>用于处理<code>cookie</code>；</p></li><li><p><code>net/http.Transport</code>中主要逻辑两部分：</p><ul><li>从连接池中获取持久化连接</li><li>使用持久化连接处理HTTP请求</li></ul></li></ul><p><code>net/http</code>库中默认有一个<code>DefaultClient</code>可以直接使用，<code>DefaultClient</code>有对应<code>DefaultTransport</code>，可以满足大多数场景。</p><ul><li>如果需要使用自己管理<code>HTTP</code>客户端的头域、重定向等策略，可以自定义<code>Client</code>，</li><li>如果需要管理代理、TLS配置、连接池、压缩等设置，可以自定义<code>Transport</code>；</li></ul><p>因为<code>HTTP</code>协议的版本是不断变化的，所以为了可扩展性，<code>transport</code>是一个接口类型，具体的是实现是<code>Transport</code>、<code>http2Transport</code>、<code>fileTransport</code>，这样实现扩展性变得很高。</p><p><code>HTTP</code>在建立连接时会耗费大量的资源，需要开辟一个<code>goroutine</code>去创建<code>TCP</code>连接，连接建立后会在创建两个<code>goroutine</code>用于<code>HTTP</code>请求的写入和响应的解析，然后使用<code>channel</code>进行通信，所以要合理利用连接池，避免大量的<code>TCP</code>连接的建立可以优化性能；</p>]]></content>
      
      
      <categories>
          
          <category> go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> net/http </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>net/http 库的客户端实现(上)</title>
      <link href="/posts/38434.html"/>
      <url>/posts/38434.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>net/http 库的客户端实现(上)</p><p><a href="https://blog.csdn.net/upstream480/article/details/128429174">net/http 库的客户端实现(下)</a></p><p><a href="https://blog.csdn.net/upstream480/article/details/128429477">net/http 库的服务端实现</a></p><p>Go语言标准库 <code>net/http</code> 是一个非常强大的标准库，使得构建 <code>HTTP</code> 请求和编写 <code>Web</code> 服务器的工作变得非常简单。</p><p>我们来看看是他是如何实现<code>客户端</code>和<code>服务端</code>的。</p><h2 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h2><p>假设本地有一个<code>GET</code>方法的<code>HTTP</code>接口，响应  <code>Hello World！</code>  使用 <code>net/http</code> 库构建<code>HTTP</code>客户端请求这个接口。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token punctuation">(</span><span class="token string">"fmt"</span><span class="token string">"io/ioutil"</span><span class="token string">"net/http"</span><span class="token punctuation">)</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    resp<span class="token punctuation">,</span> err <span class="token operator">:=</span> http<span class="token punctuation">.</span>DefaultClient<span class="token punctuation">.</span><span class="token function">Get</span><span class="token punctuation">(</span><span class="token string">"http://127.0.0.1:8080/hello"</span><span class="token punctuation">)</span>    <span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>        fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"get failed, err:%v\n"</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span>        <span class="token keyword">return</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">defer</span> resp<span class="token punctuation">.</span>Body<span class="token punctuation">.</span><span class="token function">Close</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    body<span class="token punctuation">,</span> err <span class="token operator">:=</span> ioutil<span class="token punctuation">.</span><span class="token function">ReadAll</span><span class="token punctuation">(</span>resp<span class="token punctuation">.</span>Body<span class="token punctuation">)</span>    <span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>        fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"read from resp.body failed, err:%v\n"</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span>        <span class="token keyword">return</span>    <span class="token punctuation">&#125;</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token function">string</span><span class="token punctuation">(</span>body<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以获得响应内容  <code>Hello World！</code>  </p><p>通过这样一个简单的例子，可以看到客户端主要使用<code>http.Client&#123;&#125;</code>，服务端主要使用<code>http.ListenAndServe</code> 和<code>http.HandleFunc</code>，今天我们先看看客户端的代码是怎么封装的。</p><h2 id="client-结构体"><a href="#client-结构体" class="headerlink" title="client 结构体"></a>client 结构体</h2><p>定义客户端的结构体是<code>net/http.Client&#123;&#125;</code>，具体结构如下：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">type</span> Client <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>    Transport RoundTripper    CheckRedirect <span class="token keyword">func</span><span class="token punctuation">(</span>req <span class="token operator">*</span>Request<span class="token punctuation">,</span> via <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">*</span>Request<span class="token punctuation">)</span> <span class="token builtin">error</span>    Jar CookieJar    Timeout time<span class="token punctuation">.</span>Duration<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><code>Transport</code>：其类型是<code>RoundTripper</code>，<code>RoundTrip</code>代表一个本地事务，<code>RoundTripper</code>接口的实现主要有三个，主要目的是支持更好的扩展性。<ul><li><code>Transport</code></li><li><code>http2Transport</code></li><li><code>fileTransport</code>；</li></ul></li><li><code>CheckRedirect</code>：用来做重定向</li><li><code>Jar</code>：其类型是<code>CookieJar</code>，用来做<code>cookie</code>管理，<code>CookieJar</code>接口的实现<code>Jar</code>结构体在源码包<code>net/http/cookiejar/jar.go</code>；</li><li><code>Timeout</code> 超时时间</li></ul><p>我们可以直接通过<code>net/http.DefaultClient</code>发起HTTP请求，也可以自己构建新的<code>net/http.Client</code>实现自定义的HTTP事务。</p><h2 id="client-基本结构"><a href="#client-基本结构" class="headerlink" title="client 基本结构"></a>client 基本结构</h2><p><img src="https://img-blog.csdnimg.cn/9d2eb4b264a14dbbaed75089fc5c2a2d.png" alt="在这里插入图片描述"></p><h2 id="Request"><a href="#Request" class="headerlink" title="Request"></a>Request</h2><p><code>Request</code> 结构体，其中包含了 <code>HTTP</code> 请求的方法、<code>URL</code>、协议版本、协议头以及请求体等字段，<br>还包括了指向响应的引用：<code>Response</code>；</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">type</span> Request <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>    Method <span class="token builtin">string</span>    URL <span class="token operator">*</span>url<span class="token punctuation">.</span>URL    Proto      <span class="token builtin">string</span> <span class="token comment">// "HTTP/1.0"</span>    ProtoMajor <span class="token builtin">int</span>    <span class="token comment">// 1</span>    ProtoMinor <span class="token builtin">int</span>    <span class="token comment">// 0</span>    Header Header    Body io<span class="token punctuation">.</span>ReadCloser    GetBody <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>io<span class="token punctuation">.</span>ReadCloser<span class="token punctuation">,</span> <span class="token builtin">error</span><span class="token punctuation">)</span>    ContentLength <span class="token builtin">int64</span>    removed as necessary when sending and    TransferEncoding <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">string</span>    Close <span class="token builtin">bool</span>    Host <span class="token builtin">string</span>    Form url<span class="token punctuation">.</span>Values    PostForm url<span class="token punctuation">.</span>Values    MultipartForm <span class="token operator">*</span>multipart<span class="token punctuation">.</span>Form    Trailer Header    RemoteAddr <span class="token builtin">string</span>    RequestURI <span class="token builtin">string</span>    TLS <span class="token operator">*</span>tls<span class="token punctuation">.</span>ConnectionState    Cancel <span class="token operator">&lt;-</span><span class="token keyword">chan</span> <span class="token keyword">struct</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>    Response <span class="token operator">*</span>Response    ctx context<span class="token punctuation">.</span>Context<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>提供了 <code>NewRequest()</code> 、<code>NewRequestWithContext()</code>两个方法用来构建请求，这个方法可以校验<code>HTTP</code>请求的字段并根据输入的参数拼装成新的请求结构体。</p><p><code>NewRequest()</code>方法内部也是调用的<code>NewRequestWithContext</code>。<br><img src="https://img-blog.csdnimg.cn/0df2c8371e194cff89a99bcdb455e459.png" alt="在这里插入图片描述"></p><p>区别就是是否使用 <code>context</code> 来做<code>goroutine</code>上下文传递；</p><h2 id="NewRequestWithContext"><a href="#NewRequestWithContext" class="headerlink" title="NewRequestWithContext()"></a>NewRequestWithContext()</h2><p>创建 <code>request</code> 请求结构体</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">NewRequestWithContext</span><span class="token punctuation">(</span>ctx context<span class="token punctuation">.</span>Context<span class="token punctuation">,</span> method<span class="token punctuation">,</span> url <span class="token builtin">string</span><span class="token punctuation">,</span> body io<span class="token punctuation">.</span>Reader<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token operator">*</span>Request<span class="token punctuation">,</span> <span class="token builtin">error</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token comment">// 默认使用 GET 方法</span><span class="token keyword">if</span> method <span class="token operator">==</span> <span class="token string">""</span> <span class="token punctuation">&#123;</span>method <span class="token operator">=</span> <span class="token string">"GET"</span><span class="token punctuation">&#125;</span><span class="token comment">// 校验请求方法是否有效，常用 GET、POST、PUT，DELETE 等</span><span class="token comment">//OPTIONS，GET，HEAD，POST，PUT，DELETE，TRACE，CONNECT</span><span class="token keyword">if</span> <span class="token operator">!</span><span class="token function">validMethod</span><span class="token punctuation">(</span>method<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> <span class="token boolean">nil</span><span class="token punctuation">,</span> fmt<span class="token punctuation">.</span><span class="token function">Errorf</span><span class="token punctuation">(</span><span class="token string">"net/http: invalid method %q"</span><span class="token punctuation">,</span> method<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token comment">// ctx 必传，NewRequest() 方法调用时会传递 context.Background()</span><span class="token keyword">if</span> ctx <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> <span class="token boolean">nil</span><span class="token punctuation">,</span> errors<span class="token punctuation">.</span><span class="token function">New</span><span class="token punctuation">(</span><span class="token string">"net/http: nil Context"</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token comment">// 解析URL，解析Scheme、Host、Path等信息</span>u<span class="token punctuation">,</span> err <span class="token operator">:=</span> urlpkg<span class="token punctuation">.</span><span class="token function">Parse</span><span class="token punctuation">(</span>url<span class="token punctuation">)</span><span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> <span class="token boolean">nil</span><span class="token punctuation">,</span> err<span class="token punctuation">&#125;</span><span class="token comment">// body 在下面会根据其类型包装成 io.ReadCloser 类型</span>rc<span class="token punctuation">,</span> ok <span class="token operator">:=</span> body<span class="token punctuation">.</span><span class="token punctuation">(</span>io<span class="token punctuation">.</span>ReadCloser<span class="token punctuation">)</span><span class="token keyword">if</span> <span class="token operator">!</span>ok <span class="token operator">&amp;&amp;</span> body <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>rc <span class="token operator">=</span> io<span class="token punctuation">.</span><span class="token function">NopCloser</span><span class="token punctuation">(</span>body<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token comment">// The host's colon:port should be normalized. See Issue 14836.</span>u<span class="token punctuation">.</span>Host <span class="token operator">=</span> <span class="token function">removeEmptyPort</span><span class="token punctuation">(</span>u<span class="token punctuation">.</span>Host<span class="token punctuation">)</span>req <span class="token operator">:=</span> <span class="token operator">&amp;</span>Request<span class="token punctuation">&#123;</span>ctx<span class="token punctuation">:</span>        ctx<span class="token punctuation">,</span>Method<span class="token punctuation">:</span>     method<span class="token punctuation">,</span>URL<span class="token punctuation">:</span>        u<span class="token punctuation">,</span>Proto<span class="token punctuation">:</span>      <span class="token string">"HTTP/1.1"</span><span class="token punctuation">,</span>ProtoMajor<span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span>ProtoMinor<span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span>Header<span class="token punctuation">:</span>     <span class="token function">make</span><span class="token punctuation">(</span>Header<span class="token punctuation">)</span><span class="token punctuation">,</span>Body<span class="token punctuation">:</span>       rc<span class="token punctuation">,</span>Host<span class="token punctuation">:</span>       u<span class="token punctuation">.</span>Host<span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span class="token keyword">if</span> body <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span><span class="token keyword">switch</span> v <span class="token operator">:=</span> body<span class="token punctuation">.</span><span class="token punctuation">(</span><span class="token keyword">type</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">case</span> <span class="token operator">*</span>bytes<span class="token punctuation">.</span>Buffer<span class="token punctuation">:</span>req<span class="token punctuation">.</span>ContentLength <span class="token operator">=</span> <span class="token function">int64</span><span class="token punctuation">(</span>v<span class="token punctuation">.</span><span class="token function">Len</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>buf <span class="token operator">:=</span> v<span class="token punctuation">.</span><span class="token function">Bytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span>req<span class="token punctuation">.</span>GetBody <span class="token operator">=</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>io<span class="token punctuation">.</span>ReadCloser<span class="token punctuation">,</span> <span class="token builtin">error</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>r <span class="token operator">:=</span> bytes<span class="token punctuation">.</span><span class="token function">NewReader</span><span class="token punctuation">(</span>buf<span class="token punctuation">)</span><span class="token keyword">return</span> io<span class="token punctuation">.</span><span class="token function">NopCloser</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token boolean">nil</span><span class="token punctuation">&#125;</span><span class="token keyword">case</span> <span class="token operator">*</span>bytes<span class="token punctuation">.</span>Reader<span class="token punctuation">:</span>req<span class="token punctuation">.</span>ContentLength <span class="token operator">=</span> <span class="token function">int64</span><span class="token punctuation">(</span>v<span class="token punctuation">.</span><span class="token function">Len</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>snapshot <span class="token operator">:=</span> <span class="token operator">*</span>vreq<span class="token punctuation">.</span>GetBody <span class="token operator">=</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>io<span class="token punctuation">.</span>ReadCloser<span class="token punctuation">,</span> <span class="token builtin">error</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>r <span class="token operator">:=</span> snapshot<span class="token keyword">return</span> io<span class="token punctuation">.</span><span class="token function">NopCloser</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>r<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token boolean">nil</span><span class="token punctuation">&#125;</span><span class="token keyword">case</span> <span class="token operator">*</span>strings<span class="token punctuation">.</span>Reader<span class="token punctuation">:</span>req<span class="token punctuation">.</span>ContentLength <span class="token operator">=</span> <span class="token function">int64</span><span class="token punctuation">(</span>v<span class="token punctuation">.</span><span class="token function">Len</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>snapshot <span class="token operator">:=</span> <span class="token operator">*</span>vreq<span class="token punctuation">.</span>GetBody <span class="token operator">=</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>io<span class="token punctuation">.</span>ReadCloser<span class="token punctuation">,</span> <span class="token builtin">error</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>r <span class="token operator">:=</span> snapshot<span class="token keyword">return</span> io<span class="token punctuation">.</span><span class="token function">NopCloser</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>r<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token boolean">nil</span><span class="token punctuation">&#125;</span><span class="token keyword">default</span><span class="token punctuation">:</span><span class="token keyword">if</span> req<span class="token punctuation">.</span>GetBody <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token operator">&amp;&amp;</span> req<span class="token punctuation">.</span>ContentLength <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">&#123;</span>req<span class="token punctuation">.</span>Body <span class="token operator">=</span> NoBodyreq<span class="token punctuation">.</span>GetBody <span class="token operator">=</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>io<span class="token punctuation">.</span>ReadCloser<span class="token punctuation">,</span> <span class="token builtin">error</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> NoBody<span class="token punctuation">,</span> <span class="token boolean">nil</span> <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">return</span> req<span class="token punctuation">,</span> <span class="token boolean">nil</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> net/http </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OAuth2.0的四种授权方式</title>
      <link href="/posts/41831.html"/>
      <url>/posts/41831.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><code>OAuth</code> 简单理解就是一种授权机制，它是在客户端和资源所有者之间的授权层，用来分离两种不同的角色。在资源所有者同意并向客户端颁发令牌后，客户端携带令牌可以访问资源所有者的资源。<br><code>OAuth2.0</code> 是 <code>OAuth</code> 协议的一个版本，有 <code>2.0</code> 版本那就有 <code>1.0</code> 版本，但<code>OAuth1.0</code> 已经不使用了，而且<code>OAuth2.0</code> 不向下兼容。</p><h2 id="场景举例"><a href="#场景举例" class="headerlink" title="场景举例"></a>场景举例</h2><p>最简单的就是小区单元楼里面的门禁系统，它就是使用<code>OAuth</code>授权的，朋友过来玩的时候，到楼下有门禁进不来，对于本小区住户来说，可以输入密码进入，因为朋友不是小区住户，直接给他密码不合适，他可以在门禁上面输入我住的住户号，比如 <code>1204</code>，此时，房间里面的门禁电话就会响，我可以拿起电话，与他通话，确认为我朋友后，按下电话上面的<code>允许</code>按钮，门禁就会打开，他就可以进来了。<br>我按下电话上的允许按钮，就相当于给我朋友一个<code>token</code>，这个<code>token</code>拥有类似<code>密码</code>的功能，但也不太相同，<code>token</code> 拥有权限范围，有时效性的，到期自动失效，而且这些属性无法修改。</p><h2 id="涉及参数"><a href="#涉及参数" class="headerlink" title="涉及参数"></a>涉及参数</h2><p>在讲授权方式前，先了解授权过程中会涉及到的参数：</p><ul><li><code>response_type</code>：<code>code</code> 表示要求返回授权码，<code>token</code> 表示直接返回令牌</li><li><code>client_id</code>：客户端身份标识</li><li><code>client_secret</code>：客户端密钥</li><li><code>redirect_uri</code>：重定向地址</li><li><code>scope</code>：表示授权的范围，<code>read</code> 只读权限，<code>all</code> 读写权限</li><li><code>grant_type</code>：表示授权的方式，<ul><li><code>AUTHORIZATION_CODE</code>（授权码）</li><li><code>password</code>（密码）</li><li><code>client_credentials</code>（凭证式）</li><li><code>refresh_token</code> 更新令牌</li></ul></li><li><code>state</code>：应用程序传递的一个随机数，用来防止<code>CSRF</code>攻击。</li></ul><h2 id="授权方式"><a href="#授权方式" class="headerlink" title="授权方式"></a>授权方式</h2><p><code>OAuth2.0</code> 的授权简单理解其实就是获取令牌<code>token</code>的过程，<code>OAuth</code> 协议定义了四种获得令牌的授权方式<code>authorization grant</code> ：</p><ul><li>授权码（<code>authorization-code</code>）</li><li>隐藏式（<code>implicit</code>）</li><li>密码式（<code>password</code>）</li><li>凭证式（<code>client credentials</code>）</li></ul><p>不管使用哪一种授权方式，在申请令牌之前，都必须在系统中去申请身份唯一标识，客户端 ID<code>client ID</code><br>和客户端密钥<code>client secret</code>保证 <code>token</code> 不被恶意使用。</p><h3 id="授权码"><a href="#授权码" class="headerlink" title="授权码"></a>授权码</h3><p>四种授权中<code>授权码方式</code>是比较复杂的，安全系数却是最高的，也比较常用。这种方式适用于兼具前后端的<code>Web</code>项目。<br><img src="https://img-blog.csdnimg.cn/img_convert/2d4fb20c406daff0c7f4219dcc08b9fb.png" alt="image.png"></p><p>1、用户选择使用微信登录<code>web</code>，<code>web</code> 会向微信发起授权请求，接下来微信询问用户是否同意授权（手机弹窗确认）。</p><ul><li><p><code>response_type</code> 为 <code>code</code> 要求返回授权码</p></li><li><p><code>scope</code> 参数表示本次授权范围；</p></li><li><p><code>redirect_uri</code> 重定向的地址。</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">https://wx.com/oauth/authorize?<span class="token assign-left variable">response_type</span><span class="token operator">=</span>code<span class="token operator">&amp;</span><span class="token assign-left variable">client_id</span><span class="token operator">=</span>CLIENT_ID<span class="token operator">&amp;</span><span class="token assign-left variable">redirect_uri</span><span class="token operator">=</span>http://login.web/callback<span class="token operator">&amp;</span><span class="token assign-left variable">scope</span><span class="token operator">=</span>read<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>2、用户同意授权后，微信 根据 <code>redirect_uri</code>重定向并返回<code>授权码</code>。</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">http://login.web/callback?code<span class="token operator">=</span>AUTHORIZATION_CODE<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>3、当<code>web</code>拿到授权码（<code>code</code>）时，带授权码和密匙等参数向微信申请令牌(<code>access_token</code>)。</p></li><li><p><code>grant_type</code>表示本次授权为授权码方式 <code>authorization_code</code> </p></li><li><p><code>client_secret</code>客户端密匙;</p></li><li><p><code>code</code>上一步得到的授权码。</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">https://wx.com/oauth/token?<span class="token assign-left variable">client_id</span><span class="token operator">=</span>CLIENT_ID<span class="token operator">&amp;</span><span class="token assign-left variable">client_secret</span><span class="token operator">=</span>CLIENT_SECRET<span class="token operator">&amp;</span><span class="token assign-left variable">grant_type</span><span class="token operator">=</span>authorization_code<span class="token operator">&amp;</span><span class="token assign-left variable">code</span><span class="token operator">=</span>AUTHORIZATION_CODE<span class="token operator">&amp;</span><span class="token assign-left variable">redirect_uri</span><span class="token operator">=</span>http://login.web/callback<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>4、最后微信收到请求后向 <code>redirect_uri</code> 地址发送 <code>JSON</code> 数据，其中的<code>access_token</code> 就是令牌。</p><pre class="line-numbers language-json" data-language="json"><code class="language-json"><span class="token punctuation">&#123;</span>      <span class="token property">"access_token"</span><span class="token operator">:</span><span class="token string">"ACCESS_TOKEN"</span><span class="token punctuation">,</span>  <span class="token property">"token_type"</span><span class="token operator">:</span><span class="token string">"bearer"</span><span class="token punctuation">,</span>  <span class="token property">"expires_in"</span><span class="token operator">:</span><span class="token number">2592000</span><span class="token punctuation">,</span>  <span class="token property">"refresh_token"</span><span class="token operator">:</span><span class="token string">"REFRESH_TOKEN"</span><span class="token punctuation">,</span>  <span class="token property">"scope"</span><span class="token operator">:</span><span class="token string">"read"</span><span class="token punctuation">,</span>  ......<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="隐藏式"><a href="#隐藏式" class="headerlink" title="隐藏式"></a>隐藏式</h3><p>如果是纯前端应用，无法使用授权码模式。令牌的申请与存储都需要在前端完成，隐藏式跳过了授权码这一步。前端应用直接获取 <code>token</code>，<code>response_type</code> 设置为 <code>token</code>，要求直接<code>access_token</code>，跳过授权码，微信授权通过后重定向到指定 <code>redirect_uri</code> 。</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">https://wx.com/oauth/authorize?<span class="token assign-left variable">response_type</span><span class="token operator">=</span>token<span class="token operator">&amp;</span><span class="token assign-left variable">client_id</span><span class="token operator">=</span>CLIENT_ID<span class="token operator">&amp;</span><span class="token assign-left variable">redirect_uri</span><span class="token operator">=</span>http:/login.web/callback<span class="token operator">&amp;</span><span class="token assign-left variable">scope</span><span class="token operator">=</span>read<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这种模式安全性相对于<code>授权码</code>低一些。</p><h3 id="密码式"><a href="#密码式" class="headerlink" title="密码式"></a>密码式</h3><p>用户在<code>web</code>页面直接输入自己的微信用户名和密码，<code>web</code>拿着信息直接去微信申请令牌，请求响应的 <code>JSON</code>结果中返回 <code>access_token</code>。<code>grant_type</code> 为 <code>password</code> 表示密码式授权。</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">https://wx.com/token?<span class="token assign-left variable">grant_type</span><span class="token operator">=</span>password<span class="token operator">&amp;</span><span class="token assign-left variable">username</span><span class="token operator">=</span>USERNAME<span class="token operator">&amp;</span><span class="token assign-left variable">password</span><span class="token operator">=</span>PASSWORD<span class="token operator">&amp;</span><span class="token assign-left variable">client_id</span><span class="token operator">=</span>CLIENT_ID<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这种授权方式是非常的危险，相当于把微信密码直接交给了<code>web</code>系统。如果采取此方式授权的应用一定要高度可信任的。</p><h3 id="凭证式"><a href="#凭证式" class="headerlink" title="凭证式"></a>凭证式</h3><p>凭证式和密码式比较相似，适用于那些没有前端的命令行应用，可以用最简单的方式获取令牌，在请求响应的 <code>JSON</code> 结果中返回 <code>access_token</code>。</p></li><li><p><code>grant_type</code> 为 <code>client_credentials</code> 表示凭证式授权，</p></li><li><p><code>client_id</code> 和 <code>client_secret</code> 用来识别身份。</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">https://wx.com/token?<span class="token assign-left variable">grant_type</span><span class="token operator">=</span>client_credentials<span class="token operator">&amp;</span><span class="token assign-left variable">client_id</span><span class="token operator">=</span>CLIENT_ID<span class="token operator">&amp;</span><span class="token assign-left variable">client_secret</span><span class="token operator">=</span>CLIENT_SECRET<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="令牌使用"><a href="#令牌使用" class="headerlink" title="令牌使用"></a>令牌使用</h2><p>拥有令牌就可以调用微信的 <code>API</code> 请求数据了，每个请求微信的请求都必须带上 <code>token</code>，将 <code>token</code> 放在 <code>http</code> 请求头<code>header</code>的一个<code>Authorization</code>里。<br><img src="https://img-blog.csdnimg.cn/img_convert/64278fd7b3d5f0dac97971aaa70eaa26.png" alt="image.png"></p><h2 id="令牌刷新"><a href="#令牌刷新" class="headerlink" title="令牌刷新"></a>令牌刷新</h2><p><code>token</code> 是有时效性的，一旦过期就需要重新获取，如果重走一遍授权流程，太过麻烦，一般在颁发令牌 <code>token</code> 时会一次发两个令牌，一个令牌用来请求 <code>API</code>，另一个负责更新令牌 <code>refresh_token</code>。</p></li><li><p><code>grant_type</code> 为 <code>refresh_token</code> 请求为更新令牌，</p></li><li><p>参数 <code>refresh_token</code> 是用于更新令牌的令牌。</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">https://wx.com/oauth/token?<span class="token assign-left variable">grant_type</span><span class="token operator">=</span>refresh_token<span class="token operator">&amp;</span><span class="token assign-left variable">client_id</span><span class="token operator">=</span>CLIENT_ID<span class="token operator">&amp;</span><span class="token assign-left variable">client_secret</span><span class="token operator">=</span>CLIENT_SECRET<span class="token operator">&amp;</span><span class="token assign-left variable">refresh_token</span><span class="token operator">=</span>REFRESH_TOKEN<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul>]]></content>
      
      
      <categories>
          
          <category> 权限控制 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OAuth2.0 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MQTT协议</title>
      <link href="/posts/41246.html"/>
      <url>/posts/41246.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><code>MQTT (Message Queue Telemetry Transport)</code>是一种基于<code>发布/订阅</code>（<code>publish/subscribe</code>）模式的轻量级通讯协议，通过订阅相应的主题来获取消息，是物联网（Internet of Thing）中的一个标准传输协议。<br>该协议将消息的发布者（<code>publisher</code>）与订阅者（<code>subscriber</code>）进行分离，因此可以在不可靠的网络环境中，为远程连接的设备提供可靠的消息服务，使用方式与传统的 <code>MQ</code> 有点类似。<br><img src="https://img-blog.csdnimg.cn/6a88f66422d34beeaa057c5894232b46.png" alt="在这里插入图片描述"></p><p><code>TCP</code> 协议位于传输层，<code>MQTT</code> 协议位于应用层，<code>MQTT</code> 协议构建于 <code>TCP/IP</code> 协议上，理论上，只要支持 <code>TCP/IP</code> 协议栈的地方，都可以使用 <code>MQTT</code> 协议。</p><h2 id="协议优势"><a href="#协议优势" class="headerlink" title="协议优势"></a>协议优势</h2><p><code>MQTT</code> 协议在物联网（IOT）中非常流行，主要有几点：</p><ul><li> <code>HTTP</code> 协议它是一种同步协议，客户端请求后需要等待服务器的响应。而在物联网（<code>IOT</code>）环境中，设备会很受制于环境的影响，比如带宽低、网络延迟高、网络通信不稳定等，显然异步消息协议更为适合 <code>IOT</code> 应用程序。</li><li><code>HTTP</code> 是单向的，如果要获取消息客户端必须发起连接，而在物联网（<code>IOT</code>）应用程序中，设备或传感器往往都是客户端，这意味着它们无法被动地接收来自网络的命令。</li><li>通常需要将一条命令或者消息，发送到网络上的所有设备上。<code>HTTP</code> 要实现这样的功能不但很困难，而且成本极高。</li></ul><h2 id="协议结构"><a href="#协议结构" class="headerlink" title="协议结构"></a>协议结构</h2><p><code>MQTT</code>是一种轻量级的协议，它只专注于发消息， 所以此协议的结构也比较简单。</p><h3 id="MQTT数据包"><a href="#MQTT数据包" class="headerlink" title="MQTT数据包"></a>MQTT数据包</h3><p>在<code>MQTT</code>协议中，一个<code>MQTT</code>数据包由：固定头（<code>Fixed header</code>）、 可变头（<code>Variable header</code>）、 消息体（<code>payload</code>）三部分构成。<br><img src="https://img-blog.csdnimg.cn/836c68790b3742b699d911c251195a19.png" alt="在这里插入图片描述"></p><ul><li>固定头（<code>Fixed header</code>），所有数据包中都有固定头，包含数据包类型及数据包的分组标识。</li><li>可变头（<code>Variable header</code>），部分数据包类型中有可变头。</li><li>消息体（<code>Payload</code>），存在于部分数据包类，是客户端收到的具体消息内容。<h4 id="固定头"><a href="#固定头" class="headerlink" title="固定头"></a>固定头</h4></li></ul><p><strong>固定头</strong> 存在于所有 <code>MQTT</code> 数据包中，使用两个字节，共<code>16</code>位，结构如下：</p><table><thead><tr><th>Bit</th><th>7</th><th>6</th><th>5</th><th>4</th><th>3</th><th>2</th><th>1</th><th>0</th></tr></thead><tbody><tr><td>byte 1</td><td>MQTT数据包类型</td><td></td><td></td><td></td><td>不同类型MQTT数据包的具体标识</td><td></td><td></td><td></td></tr><tr><td>byte 2…</td><td>剩余长度</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><p><code>4-7</code>位表示消息类型，使用 <code>4</code> 位二进制表示，可代表如下的16种消息类型，不过 <code>0</code> 和 <code>15</code>位置属于保留待用，所以共<code>14</code>种消息事件类型。</p><table><thead><tr><th>名称</th><th>值</th><th>流方向</th><th>描述</th></tr></thead><tbody><tr><td>Reserved</td><td>0</td><td>不可用</td><td>保留位</td></tr><tr><td>CONNECT</td><td>1</td><td>客户端到服务器</td><td>客户端请求连接到服务器</td></tr><tr><td>CONNACK</td><td>2</td><td>服务器到客户端</td><td>连接确认</td></tr><tr><td>PUBLISH</td><td>3</td><td>双向</td><td>发布消息</td></tr><tr><td>PUBACK</td><td>4</td><td>双向</td><td>发布确认</td></tr><tr><td>PUBREC</td><td>5</td><td>双向</td><td>发布收到（保证第1部分到达）</td></tr><tr><td>PUBREL</td><td>6</td><td>双赂</td><td>发布释放（保证第2部分到达）</td></tr><tr><td>PUBCOMP</td><td>7</td><td>双向</td><td>发布完成（保证第3部分到达）</td></tr><tr><td>SUBSCRIBE</td><td>8</td><td>客户端到服务器</td><td>客户端请求订阅</td></tr><tr><td>SUBACK</td><td>9</td><td>服务器到客户端</td><td>订阅确认</td></tr><tr><td>UNSUBSCRIBE</td><td>10</td><td>客户端到服务器</td><td>请求取消订阅</td></tr><tr><td>UNSUBACK</td><td>11</td><td>服务器到客户端</td><td>取消订阅确认</td></tr><tr><td>PINGREQ</td><td>12</td><td>客户端到服务器</td><td>PING请求</td></tr><tr><td>PINGRESP</td><td>13</td><td>服务器到客户端</td><td>PING应答</td></tr><tr><td>DISCONNECT</td><td>14</td><td>客户端到服务器</td><td>中断连接</td></tr><tr><td>Reserved</td><td>15</td><td>不可用</td><td>保留位</td></tr></tbody></table><p><strong>DUP Flag（重试标识）</strong></p><ul><li><code>DUP Flag</code>：保证消息可靠传输，消息是否已送达的标识。默认为<code>0</code>，只占用一个字节，表示第一次发送，当值为 <code>1</code> 时，表示当前消息先前已经被传送过。</li></ul><p><strong>QoS Level（消息质量等级）</strong></p><ul><li><code>QoS Level</code>：消息的质量等级</li></ul><p><strong>RETAIN（持久化）</strong></p><ul><li>值为 <code>1</code> ：表示发送的消息需要一直持久保存，而且不受服务器重启影响，不但要发送给当前的订阅者，且以后新加入的客户端订阅了此 <code>Topic</code>，订阅者也会马上得到推送。注意：新加入的订阅者，只会取出最新的一个<code>RETAIN flag = 1</code>的消息推送。</li><li>值为 <code>0</code> ：仅为当前订阅者推送此消息。</li></ul><p><strong>Remaining Length（剩余长度）</strong></p><ul><li>在当前消息中剩余的 <code>byte</code> 数，包含可变头部和消息体<code>payload</code>。</li></ul><h4 id="可变头"><a href="#可变头" class="headerlink" title="可变头"></a>可变头</h4><p>固定头部仅定义了消息类型和一些标志位，一些消息的元数据需要放入可变头部中。可变头部内容字节长度 + 消息体payload = 剩余长度。</p><p>可变头部居于固定头部和<code>payload</code>中间，包含了协议名称，版本号，连接标志，用户授权，心跳时间等内容。</p><p>可变头存在于这些类型的消息：</p><ul><li><p><code>PUBLISH (QoS &gt; 0)</code></p></li><li><p><code>PUBACK</code></p></li><li><p><code>PUBREC</code></p></li><li><p><code>PUBREL</code></p></li><li><p><code>PUBCOMP</code></p></li><li><p><code>SUBSCRIBE</code></p></li><li><p><code>SUBACK</code></p></li><li><p><code>UNSUBSCRIBE</code></p></li><li><p><code>UNSUBACK</code></p><h4 id="消息体"><a href="#消息体" class="headerlink" title="消息体"></a>消息体</h4><p>消息体 <code>payload</code> 只存在于 <code>CONNECT、PUBLISH、SUBSCRIBE、SUBACK、UNSUBSCRIBE</code> 这几种类型的消息：</p></li><li><p><code>CONNECT</code>：包含客户端的<code>ClientId</code>、订阅的<code>Topic</code>、<code>Message</code>以及用户名和密码。</p></li><li><p><code>PUBLISH</code>：向对应主题发送消息。</p></li><li><p><code>SUBSCRIBE</code>：要订阅的主题以及<code>QoS</code>。</p></li><li><p><code>SUBACK</code>：服务器对于<code>SUBSCRIBE</code>所申请的主题及 <code>QoS</code> 进行确认和回复。</p></li><li><p><code>UNSUBSCRIBE</code>：取消要订阅的主题。</p><h3 id="消息质量-QoS"><a href="#消息质量-QoS" class="headerlink" title="消息质量(QoS)"></a>消息质量(QoS)</h3><p>消息的发送质量，发布者（<code>publisher</code>）和订阅者（<code>subscriber</code>）都可以指定 <code>qos</code> 等级，有三个等级：</p></li><li><p><code>QoS 0</code></p></li><li><p><code>QoS 1</code></p></li><li><p><code>QoS 2</code></p><h4 id="QoS-0"><a href="#QoS-0" class="headerlink" title="QoS 0"></a>QoS 0</h4><p><code>At most once</code>（至多一次）只发送一次消息，不保证消息是否成功送达，没有确认机制，消息可能会丢失或重复。</p></li></ul><p><strong>具体流程</strong><br><img src="https://img-blog.csdnimg.cn/33c202d66bc949eca2de2cf82c6ed46f.png" alt="在这里插入图片描述"></p><h4 id="QoS-1"><a href="#QoS-1" class="headerlink" title="QoS 1"></a>QoS 1</h4><p><code>At least once</code>（至少一次），相对于 <code>QoS 0</code> 而言 <code>Qos 1</code> 增加了 <code>ack</code> 确认机制，发送者（<code>publisher</code>）推送消息到<code>MQTT</code>代理（<code>broker</code>）时，两者自身都会先持久化消息，只有当<code>publisher</code> 或者 <code>Broker</code>分别收到 <code>PUBACK</code>确认时，才会删除自身持久化的消息，否则就会重发。</p><p>虽然可以通过确认来保证一定收到客户端 或 服务器的 <code>message</code>，可却不能保证只收到一次 <code>message</code>，当客户端<code>publisher</code>没收到<code>Broker</code>的<code>puback</code>或者 <code>Broker</code>没有收到<code>subscriber</code>的<code>puback</code>，那么就会一直重发。</p><p><strong>具体流程</strong></p><ul><li><code>publisher store msg</code> -&gt; <code>publish</code> -&gt;<code>broker</code> （发送 message）</li><li><code>broker</code> -&gt; <code>puback</code> -&gt; <code>publisher delete msg</code> （确认回执）</li></ul><p><img src="https://img-blog.csdnimg.cn/5325cd39a2824e729a1b5ac59bc1df07.png" alt="在这里插入图片描述"></p><h4 id="QoS-2"><a href="#QoS-2" class="headerlink" title="QoS 2"></a>QoS 2</h4><p><code>Exactly once</code>（只有一次），相对于<code>QoS 1，QoS 2</code>升级实现了仅接受一次<code>message</code>，<code>publisher</code> 和 <code>broker</code> 同样对消息进行持久化，其中 <code>publisher</code> 缓存了<code>message</code>和 对应的 <code>msgId</code>，而 <code>broker</code> 缓存了 <code>msgId</code>，可以保证消息不重复，由于又增加了一个<code>confirm</code> 机制，整个流程变得复杂很多。</p><p><strong>具体流程：</strong></p><ul><li><code>publisher store msg</code> -&gt; <code>publish</code> -&gt;<code>broker</code> -&gt; <code>broker store</code> (发送消息)</li><li><code>msgId</code>（传递 message） <code>broker</code> -&gt; <code>puberc</code> （确认传递成功）</li><li><code>publisher</code> -&gt; <code>pubrel</code> -&gt;<code>broker delete msgId</code> （通知<code>broker</code>删除<code>msgId</code>）</li><li><code>broker</code> -&gt; <code>pubcomp</code> -&gt; <code>publisher delete msg</code> （通知<code>publisher</code>删除<code>msg</code>）<br><img src="https://img-blog.csdnimg.cn/b5317304148c430a9d8fb00b07001c19.png" alt="在这里插入图片描述"></li></ul><h3 id="最后遗嘱-LWT"><a href="#最后遗嘱-LWT" class="headerlink" title="最后遗嘱(LWT)"></a>最后遗嘱(LWT)</h3><p><code>LWT</code> 全称为<code> Last Will and Testament</code>，遗嘱是一个由客户端预先定义好的主题和对应消息，附加在<code>CONNECT</code>的数据包中，包括遗愿主题、遗愿 <code>QoS</code>、遗愿消息等。</p><p>当<code>MQTT</code>代理 <code>Broker</code> 检测到有客户端<code>client</code>非正常断开连接时，再由服务器主动发布此消息，然后相关的订阅者会收到消息。</p><p><strong>遗嘱的相关参数：</strong></p><ul><li><code>Will Flag</code>：是否使用 <code>LWT</code>，1 开启</li><li><code>Will Topic</code>：遗愿主题名，不可使用通配符</li><li><code>Will Qos</code>：发布遗愿消息时使用的 <code>QoS</code></li><li><code>Will Retain</code>：遗愿消息的 <code>Retain</code> 标识</li><li><code>Will Message</code>：遗愿消息内容</li></ul><p><strong>客户端非正常断开连接的场景</strong></p><ul><li><code>Broker</code> 检测到底层的<code> I/O</code> 异常；</li><li>客户端 未能在心跳 <code>Keep Alive</code> 的间隔内和 <code>Broker</code> 进行消息交互；</li><li>客户端 在关闭底层 <code>TCP</code> 连接前没有发送 <code>DISCONNECT</code> 数据包；</li><li>客户端 发送错误格式的数据包到 <code>Broker</code>，导致关闭和客户端的连接等。</li></ul><p>当客户端通过发布 <code>DISCONNECT</code> 数据包断开连接时，属于正常断开连接，并不会触发 <code>LWT</code> 的机制，与此同时<code>Broker</code> 还会丢弃掉当前客户端在连接时指定的相关 <code>LWT</code> 参数。</p><h2 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h2><p>MQTT 是一种协议，支持MQTT协议的消息中间件产品有很多，比如</p><ul><li><code>RabbitMQ</code></li><li><code>Apache ActiveMQ</code></li><li><code>HiveMQ</code></li><li><code>Apache Apollo</code></li><li><code>emqttd Xively</code><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><code>MQTT</code> 协议广泛应用于物联网、移动互联网、智能硬件、车联网、电力能源等领域。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 消息队列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 队列 </tag>
            
            <tag> 发布/订阅 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>gin 集成 swagger</title>
      <link href="/posts/63349.html"/>
      <url>/posts/63349.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>一个好的项目工程，必然离不开一个好的 API 文档，如果要自己编写 API 文档，维护起来比较困难，而且难以保证一致性，因此我们要自动生成在线接口文档。</p><h2 id="swaggo"><a href="#swaggo" class="headerlink" title="swaggo"></a>swaggo</h2><p>swagger 在 java 里面，是一个非常流行的 api 组件，他们维护了 go 版本的 <a href="https://github.com/swaggo">swaggo</a><br>可以通过 Swagger 2.0 自动生成RESTful API 文档。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="下载代码"><a href="#下载代码" class="headerlink" title="下载代码"></a>下载代码</h3><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token comment"># 最新版本</span>go get -u github.com/swaggo/swag/cmd/swag<span class="token comment"># 可以加上版本号</span>go get -u github.com/swaggo/swag/cmd/swag@v1.8.8<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="另外还需要下载两个包"><a href="#另外还需要下载两个包" class="headerlink" title="另外还需要下载两个包"></a>另外还需要下载两个包</h3><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token comment"># gin-swagger 中间件</span>go get github.com/swaggo/gin-swagger<span class="token comment"># swagger 内置文件</span>go get github.com/swaggo/gin-swagger/swaggerFiles<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="安装到-PATH"><a href="#安装到-PATH" class="headerlink" title="安装到 $PATH"></a>安装到 $PATH</h3><p>若 <code>$GOPATH</code> 的 <code>bin</code> 目录下面没有 <code>swag</code> 文件，需要 <code>go install</code></p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token builtin class-name">cd</span> <span class="token variable">$GOPATH</span>/pkg/mod/github.com/swaggo/swag@v1.8.8/cmd/swag<span class="token comment"># 安装</span>go <span class="token function">install</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>若 <code>$GOROOT/bin</code> 没有加入<code>$PATH</code> 中，需要将其可执行文件移动到 <code>$GOBIN</code> 下</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token function">mv</span> <span class="token variable">$GOPATH</span>/bin/swag /usr/local/go/bin<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="检查安装"><a href="#检查安装" class="headerlink" title="检查安装"></a>检查安装</h3><p>出现这个情况，说明安装成功了</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">$ swag -vswag version v1.8.8<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="gin-集成-swaggo"><a href="#gin-集成-swaggo" class="headerlink" title="gin 集成 swaggo"></a>gin 集成 swaggo</h2><h3 id="编写-api-注释"><a href="#编写-api-注释" class="headerlink" title="编写 api 注释"></a>编写 api 注释</h3><p>Swagger 中需要将相应的注释或注解编写到方法上，再利用生成器自动生成说明文件</p><p>gin-swagger 给出的范例：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// @Summary Add a new pet to the store</span><span class="token comment">// @Description get string by ID</span><span class="token comment">// @Accept  json</span><span class="token comment">// @Produce  json</span><span class="token comment">// @Param   some_id     path    int     true        "Some ID"</span><span class="token comment">// @Success 200 &#123;string&#125; string"ok"</span><span class="token comment">// @Failure 400 &#123;object&#125; web.APIError "We need ID!!"</span><span class="token comment">// @Failure 404 &#123;object&#125; web.APIError "Can not find ID"</span><span class="token comment">// @Router /testapi/get-string-by-int/&#123;some_id&#125; [get]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>参照 <code>Swagger</code> 的注解规范和范例去编写</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// Register</span><span class="token comment">// @Tags 用户管理</span><span class="token comment">// @Summary 用户注册</span><span class="token comment">// @Param username formData string true "username"</span><span class="token comment">// @Param password formData string true "password"</span><span class="token comment">// @Success 200 &#123;string&#125; json "&#123;"code":"200","msg":"success","data":""&#125;"</span><span class="token comment">// @Router /register [post]</span><span class="token keyword">func</span> <span class="token function">Register</span><span class="token punctuation">(</span>c <span class="token operator">*</span>gin<span class="token punctuation">.</span>Context<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h3><p>在完成了 <code>api </code>注释的编写后，我们需要针对 swagger 新增初始化动作和对应的路由规则，才可以使用。在 <code>routers/router.go</code> 文件，增加 <code>swagger</code> 的路由：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">Router</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span>gin<span class="token punctuation">.</span>Engine <span class="token punctuation">&#123;</span>r <span class="token operator">:=</span> gin<span class="token punctuation">.</span><span class="token function">Default</span><span class="token punctuation">(</span><span class="token punctuation">)</span>r<span class="token punctuation">.</span><span class="token function">GET</span><span class="token punctuation">(</span><span class="token string">"/swagger/*any"</span><span class="token punctuation">,</span> ginSwagger<span class="token punctuation">.</span><span class="token function">WrapHandler</span><span class="token punctuation">(</span>swaggerfiles<span class="token punctuation">.</span>Handler<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">return</span> r<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="生成"><a href="#生成" class="headerlink" title="生成"></a>生成</h3><p>在项目目录下，执行 <code>swag init</code> </p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token number">2022</span>/12/04 <span class="token number">15</span>:27:52 Generate swagger docs<span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token number">2022</span>/12/04 <span class="token number">15</span>:27:52 Generate general API Info, search dir:./<span class="token number">2022</span>/12/04 <span class="token number">15</span>:27:52 create docs.go at  docs/docs.go<span class="token number">2022</span>/12/04 <span class="token number">15</span>:27:52 create swagger.json at  docs/swagger.json<span class="token number">2022</span>/12/04 <span class="token number">15</span>:27:52 create swagger.yaml at  docs/swagger.yaml<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>执行完成后会在项目根目录下生成 <code>docs</code> 目录，里面就是 <code>api</code> 文档相关的内容</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">docs/├── docs.go└── swagger    ├── swagger.json    └── swagger.yaml<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看一下 <code>json</code> 的内容，其他的也是一样的，只是格式不同<br><img src="https://img-blog.csdnimg.cn/401b164c467f406c95e51637460a48f4.png" alt="在这里插入图片描述"></p><h3 id="查看文档"><a href="#查看文档" class="headerlink" title="查看文档"></a>查看文档</h3><p>访问地址</p><pre class="line-numbers language-none"><code class="language-none">http:&#x2F;&#x2F;127.0.0.1:8080&#x2F;swagger&#x2F;index.html<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://img-blog.csdnimg.cn/790d79f390bd4b148a08118fd22b7a6d.png" alt="在这里插入图片描述"></p><h2 id="其他信息"><a href="#其他信息" class="headerlink" title="其他信息"></a>其他信息</h2><p>在 <code>main.go</code> 方法上，可以增加一些其他信息，完善项目的信息</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// @title Swagger Example API</span><span class="token comment">// @version 1.0</span><span class="token comment">// @description This is a sample server celler server.</span><span class="token comment">// @termsOfService https://github.com/stream108</span><span class="token comment">// @contact.name 一江溪水</span><span class="token comment">// @contact.url https://github.com/stream1080</span><span class="token comment">// @contact.email https://github.com/stream108</span><span class="token comment">// @license.name Apache 2.0</span><span class="token comment">// @license.url http://www.apache.org/licenses/LICENSE-2.0.html</span><span class="token comment">// @host 127.0.0.1:8080</span><span class="token comment">// @BasePath /api/v1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://img-blog.csdnimg.cn/1fc8a506931c4162b3b7884a566c21f3.png"></p>]]></content>
      
      
      <categories>
          
          <category> go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> gin </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>gin 统一响应结果</title>
      <link href="/posts/52688.html"/>
      <url>/posts/52688.html</url>
      
        <content type="html"><![CDATA[<h2 id="使用-gin"><a href="#使用-gin" class="headerlink" title="使用 gin"></a>使用 gin</h2><p>使用 gin 框架，编写 api 接口时，需要定义返回格式</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token punctuation">(</span><span class="token string">"net/http"</span><span class="token string">"github.com/gin-gonic/gin"</span><span class="token punctuation">)</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>r <span class="token operator">:=</span> gin<span class="token punctuation">.</span><span class="token function">Default</span><span class="token punctuation">(</span><span class="token punctuation">)</span>r<span class="token punctuation">.</span><span class="token function">GET</span><span class="token punctuation">(</span><span class="token string">"/ping"</span><span class="token punctuation">,</span> <span class="token keyword">func</span><span class="token punctuation">(</span>c <span class="token operator">*</span>gin<span class="token punctuation">.</span>Context<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>c<span class="token punctuation">.</span><span class="token function">JSON</span><span class="token punctuation">(</span>http<span class="token punctuation">.</span>StatusOK<span class="token punctuation">,</span> gin<span class="token punctuation">.</span>H<span class="token punctuation">&#123;</span><span class="token string">"code"</span><span class="token punctuation">:</span> <span class="token number">200</span><span class="token punctuation">,</span><span class="token string">"msg"</span><span class="token punctuation">:</span>  <span class="token string">"success"</span><span class="token punctuation">,</span><span class="token string">"data"</span><span class="token punctuation">:</span> <span class="token boolean">nil</span><span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token comment">// 监听端口，启动服务</span>r<span class="token punctuation">.</span><span class="token function">Run</span><span class="token punctuation">(</span><span class="token string">":8080"</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这种方法有一个弊端，每次返回都需要写这个结构</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">c<span class="token punctuation">.</span><span class="token function">JSON</span><span class="token punctuation">(</span>http<span class="token punctuation">.</span>StatusOK<span class="token punctuation">,</span> gin<span class="token punctuation">.</span>H<span class="token punctuation">&#123;</span><span class="token string">"code"</span><span class="token punctuation">:</span> <span class="token number">200</span><span class="token punctuation">,</span><span class="token string">"msg"</span><span class="token punctuation">:</span>  <span class="token string">"success"</span><span class="token punctuation">,</span><span class="token string">"data"</span><span class="token punctuation">:</span> <span class="token boolean">nil</span><span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="封装统一结果"><a href="#封装统一结果" class="headerlink" title="封装统一结果"></a>封装统一结果</h2><h3 id="定义统一结构体"><a href="#定义统一结构体" class="headerlink" title="定义统一结构体"></a>定义统一结构体</h3><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> result<span class="token keyword">import</span> <span class="token punctuation">(</span><span class="token string">"net/http"</span><span class="token string">"github.com/gin-gonic/gin"</span><span class="token punctuation">)</span><span class="token keyword">type</span> Response <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>Code <span class="token builtin">int</span>         <span class="token string">`json:"code"`</span>Msg  <span class="token builtin">string</span>      <span class="token string">`json:"msg"`</span>Data <span class="token keyword">interface</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span> <span class="token string">`json:"data"`</span><span class="token punctuation">&#125;</span><span class="token keyword">func</span> <span class="token function">Result</span><span class="token punctuation">(</span>c <span class="token operator">*</span>gin<span class="token punctuation">.</span>Context<span class="token punctuation">,</span> code <span class="token builtin">int</span><span class="token punctuation">,</span> msg <span class="token builtin">string</span><span class="token punctuation">,</span> data <span class="token keyword">interface</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>c<span class="token punctuation">.</span><span class="token function">JSON</span><span class="token punctuation">(</span>http<span class="token punctuation">.</span>StatusOK<span class="token punctuation">,</span> Response<span class="token punctuation">&#123;</span>code<span class="token punctuation">,</span>msg<span class="token punctuation">,</span>data<span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token keyword">func</span> <span class="token function">Error</span><span class="token punctuation">(</span>code <span class="token builtin">int</span><span class="token punctuation">,</span> msg <span class="token builtin">string</span><span class="token punctuation">)</span> Response <span class="token punctuation">&#123;</span><span class="token keyword">return</span> Response<span class="token punctuation">&#123;</span>code<span class="token punctuation">,</span>msg<span class="token punctuation">,</span><span class="token boolean">nil</span><span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">func</span> <span class="token function">Ok</span><span class="token punctuation">(</span>c <span class="token operator">*</span>gin<span class="token punctuation">.</span>Context<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token function">OkWithData</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> <span class="token boolean">nil</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token keyword">func</span> <span class="token function">OkWithData</span><span class="token punctuation">(</span>c <span class="token operator">*</span>gin<span class="token punctuation">.</span>Context<span class="token punctuation">,</span> data <span class="token keyword">interface</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token function">Result</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> SUCCESS<span class="token punctuation">.</span>Code<span class="token punctuation">,</span> SUCCESS<span class="token punctuation">.</span>Msg<span class="token punctuation">,</span> data<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token keyword">func</span> <span class="token function">OkWithMsg</span><span class="token punctuation">(</span>c <span class="token operator">*</span>gin<span class="token punctuation">.</span>Context<span class="token punctuation">,</span> msg <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token function">Result</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> SUCCESS<span class="token punctuation">.</span>Code<span class="token punctuation">,</span> msg<span class="token punctuation">,</span> <span class="token boolean">nil</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token keyword">func</span> <span class="token function">Fail</span><span class="token punctuation">(</span>c <span class="token operator">*</span>gin<span class="token punctuation">.</span>Context<span class="token punctuation">,</span> err Response<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token function">Result</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> err<span class="token punctuation">.</span>Code<span class="token punctuation">,</span> err<span class="token punctuation">.</span>Msg<span class="token punctuation">,</span> <span class="token boolean">nil</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token keyword">func</span> <span class="token function">FailWithMsg</span><span class="token punctuation">(</span>c <span class="token operator">*</span>gin<span class="token punctuation">.</span>Context<span class="token punctuation">,</span> err Response<span class="token punctuation">,</span> msg <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token function">Result</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> err<span class="token punctuation">.</span>Code<span class="token punctuation">,</span> msg<span class="token punctuation">,</span> <span class="token boolean">nil</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token punctuation">(</span><span class="token string">"gin-demo/result"</span><span class="token string">"github.com/gin-gonic/gin"</span><span class="token punctuation">)</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>r <span class="token operator">:=</span> gin<span class="token punctuation">.</span><span class="token function">Default</span><span class="token punctuation">(</span><span class="token punctuation">)</span>r<span class="token punctuation">.</span><span class="token function">GET</span><span class="token punctuation">(</span><span class="token string">"/ping"</span><span class="token punctuation">,</span> <span class="token keyword">func</span><span class="token punctuation">(</span>c <span class="token operator">*</span>gin<span class="token punctuation">.</span>Context<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>result<span class="token punctuation">.</span><span class="token function">Ok</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span>r<span class="token punctuation">.</span><span class="token function">GET</span><span class="token punctuation">(</span><span class="token string">"/hello"</span><span class="token punctuation">,</span> <span class="token keyword">func</span><span class="token punctuation">(</span>c <span class="token operator">*</span>gin<span class="token punctuation">.</span>Context<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>result<span class="token punctuation">.</span><span class="token function">OkWithData</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> <span class="token string">"hello world"</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token comment">// 监听端口，启动服务</span>r<span class="token punctuation">.</span><span class="token function">Run</span><span class="token punctuation">(</span><span class="token string">":8080"</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这样在每个 HandlerFunc 方法中只需要使用 result 包下面的方法即可，统一管理，还可以定义统一的错误码</p><h2 id="统一错误码"><a href="#统一错误码" class="headerlink" title="统一错误码"></a>统一错误码</h2><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> result<span class="token keyword">var</span> <span class="token punctuation">(</span>OK         <span class="token operator">=</span> <span class="token function">Error</span><span class="token punctuation">(</span><span class="token number">200</span><span class="token punctuation">,</span> <span class="token string">"success"</span><span class="token punctuation">)</span>NeedRedirect    <span class="token operator">=</span> <span class="token function">Error</span><span class="token punctuation">(</span><span class="token number">301</span><span class="token punctuation">,</span> <span class="token string">"need redirect"</span><span class="token punctuation">)</span>InvalidArgs     <span class="token operator">=</span> <span class="token function">Error</span><span class="token punctuation">(</span><span class="token number">400</span><span class="token punctuation">,</span> <span class="token string">"invalid params"</span><span class="token punctuation">)</span>Unauthorized    <span class="token operator">=</span> <span class="token function">Error</span><span class="token punctuation">(</span><span class="token number">401</span><span class="token punctuation">,</span> <span class="token string">"unauthorized"</span><span class="token punctuation">)</span>Forbidden       <span class="token operator">=</span> <span class="token function">Error</span><span class="token punctuation">(</span><span class="token number">403</span><span class="token punctuation">,</span> <span class="token string">"forbidden"</span><span class="token punctuation">)</span>NotFound        <span class="token operator">=</span> <span class="token function">Error</span><span class="token punctuation">(</span><span class="token number">404</span><span class="token punctuation">,</span> <span class="token string">"not found"</span><span class="token punctuation">)</span>Conflict        <span class="token operator">=</span> <span class="token function">Error</span><span class="token punctuation">(</span><span class="token number">409</span><span class="token punctuation">,</span> <span class="token string">"entry exist"</span><span class="token punctuation">)</span>TooManyRequests <span class="token operator">=</span> <span class="token function">Error</span><span class="token punctuation">(</span><span class="token number">429</span><span class="token punctuation">,</span> <span class="token string">"too many requests"</span><span class="token punctuation">)</span>ResultError     <span class="token operator">=</span> <span class="token function">Error</span><span class="token punctuation">(</span><span class="token number">500</span><span class="token punctuation">,</span> <span class="token string">"response error"</span><span class="token punctuation">)</span>DatabaseError   <span class="token operator">=</span> <span class="token function">Error</span><span class="token punctuation">(</span><span class="token number">598</span><span class="token punctuation">,</span> <span class="token string">"database error"</span><span class="token punctuation">)</span>CSRFDetected    <span class="token operator">=</span> <span class="token function">Error</span><span class="token punctuation">(</span><span class="token number">599</span><span class="token punctuation">,</span> <span class="token string">"csrf attack detected"</span><span class="token punctuation">)</span>UserError  <span class="token operator">=</span> <span class="token function">Error</span><span class="token punctuation">(</span><span class="token number">5001</span><span class="token punctuation">,</span> <span class="token string">"username or password error"</span><span class="token punctuation">)</span>CodeExpire <span class="token operator">=</span> <span class="token function">Error</span><span class="token punctuation">(</span><span class="token number">5002</span><span class="token punctuation">,</span> <span class="token string">"verification expire"</span><span class="token punctuation">)</span>CodeError  <span class="token operator">=</span> <span class="token function">Error</span><span class="token punctuation">(</span><span class="token number">5003</span><span class="token punctuation">,</span> <span class="token string">"verification error"</span><span class="token punctuation">)</span>UserExist  <span class="token operator">=</span> <span class="token function">Error</span><span class="token punctuation">(</span><span class="token number">5004</span><span class="token punctuation">,</span> <span class="token string">"user Exist"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="响应错误码"><a href="#响应错误码" class="headerlink" title="响应错误码"></a>响应错误码</h2><pre class="line-numbers language-go" data-language="go"><code class="language-go">r<span class="token punctuation">.</span><span class="token function">GET</span><span class="token punctuation">(</span><span class="token string">"/hello"</span><span class="token punctuation">,</span> <span class="token keyword">func</span><span class="token punctuation">(</span>c <span class="token operator">*</span>gin<span class="token punctuation">.</span>Context<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>result<span class="token punctuation">.</span><span class="token function">Fail</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> result<span class="token punctuation">.</span>ResultError<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> gin </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go 的 new 和 make</title>
      <link href="/posts/64403.html"/>
      <url>/posts/64403.html</url>
      
        <content type="html"><![CDATA[<h2 id="golang-变量定义的方式"><a href="#golang-变量定义的方式" class="headerlink" title="golang 变量定义的方式"></a>golang 变量定义的方式</h2><p>可以通过 var+变量名称+变量类型 进行声明变量，当我们没有给它赋值的时候，它们的结果是变量类型的零值，例如：</p><ul><li>string 的零值是””, </li><li>int 的零值是0，</li><li>引用类型的零值是nil。</li></ul><p>前面两种类型可以直接使用，但如果把它改成指针，就会报错</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token string">"fmt"</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">var</span> str <span class="token operator">*</span><span class="token builtin">string</span>  fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span>  <span class="token operator">*</span>str <span class="token operator">=</span> <span class="token string">"hello world"</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>执行结果</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token operator">&lt;</span><span class="token boolean">nil</span><span class="token operator">></span><span class="token builtin">panic</span><span class="token punctuation">:</span> runtime <span class="token builtin">error</span><span class="token punctuation">:</span> invalid memory address or <span class="token boolean">nil</span> pointer dereference<span class="token punctuation">[</span>signal SIGSEGV<span class="token punctuation">:</span> segmentation violation code<span class="token operator">=</span><span class="token number">0x1</span> addr<span class="token operator">=</span><span class="token number">0x0</span> pc<span class="token operator">=</span><span class="token number">0x10897d5</span><span class="token punctuation">]</span>goroutine <span class="token number">1</span> <span class="token punctuation">[</span>running<span class="token punctuation">]</span><span class="token punctuation">:</span>main<span class="token punctuation">.</span><span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token operator">/</span>Users<span class="token operator">/</span>xxxxx<span class="token operator">/</span><span class="token keyword">go</span><span class="token operator">/</span>src<span class="token operator">/</span>github<span class="token punctuation">.</span>com<span class="token operator">/</span>xxx<span class="token operator">/</span><span class="token keyword">go</span><span class="token operator">-</span>demo<span class="token operator">/</span>gin<span class="token operator">-</span>demo<span class="token operator">/</span>main<span class="token punctuation">.</span><span class="token keyword">go</span><span class="token punctuation">:</span><span class="token number">8</span> <span class="token operator">+</span><span class="token number">0x55</span>exit status <span class="token number">2</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>因为对于引用类型的变量，不仅要声明，并且还要给它分配内存。分配内存就是使用 new</p><h2 id="new"><a href="#new" class="headerlink" title="new"></a>new</h2><h3 id="释义"><a href="#释义" class="headerlink" title="释义"></a>释义</h3><p>new 分配内存的内置函数，第一个参数是类型，而不是具体的值，返回值是该类型的指针。分配的值是该类型零值的指针。<br><img src="https://img-blog.csdnimg.cn/92414ab9541d4677a9aa054d126b512b.png" alt="在这里插入图片描述"></p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token string">"fmt"</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">var</span> str <span class="token operator">*</span><span class="token builtin">string</span>  fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span>  str <span class="token operator">=</span> <span class="token function">new</span><span class="token punctuation">(</span><span class="token builtin">string</span><span class="token punctuation">)</span>  <span class="token operator">*</span>str <span class="token operator">=</span> <span class="token string">"hello world"</span>  fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token operator">*</span>str<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="源码实现"><a href="#源码实现" class="headerlink" title="源码实现"></a>源码实现</h3><p>底层调用 mallocgc 方法的时候，needzero 传的是 true ，返回值是传入类型零值的指针</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">newobject</span><span class="token punctuation">(</span>typ <span class="token operator">*</span>_type<span class="token punctuation">)</span> unsafe<span class="token punctuation">.</span>Pointer<span class="token punctuation">&#123;</span><span class="token keyword">return</span> <span class="token function">mallocgc</span><span class="token punctuation">(</span>typ<span class="token punctuation">.</span>size<span class="token punctuation">,</span><span class="token keyword">type</span><span class="token punctuation">,</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="make"><a href="#make" class="headerlink" title="make"></a>make</h2><h3 id="释义-1"><a href="#释义-1" class="headerlink" title="释义"></a>释义</h3><p>make 也是用于内存分配的内置函数<br><img src="https://img-blog.csdnimg.cn/d0c98c8b725d4f4080f7a8cd3bc697ea.png" alt="在这里插入图片描述"></p><p>make内置函数分配并初始化一个slice、map或chan类型的对象。<br>像new函数一样，第一个参数是类型，而不是值。</p><p>与new不同，make的返回类型与其参数的类型相同，而不是指向它的指针。结果的取决于传入的类型。<br>并且 slice在 make 的时候，第二个参数必须传递，也就是切片的长度。否则会编译失败。</p><h3 id="源码实现-1"><a href="#源码实现-1" class="headerlink" title="源码实现"></a>源码实现</h3><p>不同的结构使用的方法不同</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// slice</span><span class="token keyword">func</span> <span class="token function">makeslice</span><span class="token punctuation">(</span>typ <span class="token operator">*</span><span class="token builtin">byte</span><span class="token punctuation">,</span> <span class="token builtin">len</span> <span class="token builtin">int</span><span class="token punctuation">,</span> <span class="token builtin">cap</span> <span class="token builtin">int</span><span class="token punctuation">)</span> unsafe<span class="token punctuation">.</span>Pointer<span class="token keyword">func</span> <span class="token function">makeslice64</span><span class="token punctuation">(</span>typ <span class="token operator">*</span><span class="token builtin">byte</span><span class="token punctuation">,</span> <span class="token builtin">len</span> <span class="token builtin">int64</span><span class="token punctuation">,</span> <span class="token builtin">cap</span> <span class="token builtin">int64</span><span class="token punctuation">)</span> unsafe<span class="token punctuation">.</span>Pointer<span class="token comment">// map</span><span class="token keyword">func</span> <span class="token function">makemap64</span><span class="token punctuation">(</span>mapType <span class="token operator">*</span><span class="token builtin">byte</span><span class="token punctuation">,</span> hint <span class="token builtin">int64</span><span class="token punctuation">,</span> mapbuf <span class="token operator">*</span>any<span class="token punctuation">)</span> <span class="token punctuation">(</span>hmap <span class="token keyword">map</span><span class="token punctuation">[</span>any<span class="token punctuation">]</span>any<span class="token punctuation">)</span><span class="token keyword">func</span> <span class="token function">makemap</span><span class="token punctuation">(</span>mapType <span class="token operator">*</span><span class="token builtin">byte</span><span class="token punctuation">,</span> hint <span class="token builtin">int</span><span class="token punctuation">,</span> mapbuf <span class="token operator">*</span>any<span class="token punctuation">)</span> <span class="token punctuation">(</span>hmap <span class="token keyword">map</span><span class="token punctuation">[</span>any<span class="token punctuation">]</span>any<span class="token punctuation">)</span><span class="token keyword">func</span> <span class="token function">makemap_small</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>hmap <span class="token keyword">map</span><span class="token punctuation">[</span>any<span class="token punctuation">]</span>any<span class="token punctuation">)</span><span class="token comment">// chan</span><span class="token keyword">func</span> <span class="token function">makechan64</span><span class="token punctuation">(</span>chanType <span class="token operator">*</span><span class="token builtin">byte</span><span class="token punctuation">,</span> size <span class="token builtin">int64</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>hchan <span class="token keyword">chan</span> any<span class="token punctuation">)</span><span class="token keyword">func</span> <span class="token function">makechan</span><span class="token punctuation">(</span>chanType <span class="token operator">*</span><span class="token builtin">byte</span><span class="token punctuation">,</span> size <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>hchan <span class="token keyword">chan</span> any<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>解决跨越的几种方式</title>
      <link href="/posts/6207.html"/>
      <url>/posts/6207.html</url>
      
        <content type="html"><![CDATA[<h2 id="跨域请求"><a href="#跨域请求" class="headerlink" title="跨域请求"></a>跨域请求</h2><p><strong>域</strong> 的定义：<strong>协议 + 域名 + 端口</strong>。<br>三者完全相同则为同域，反之有其一不同均为不同域，<br>当前<strong>发起请求</strong>的 <strong>域 <strong>和</strong>请求指向</strong>的 <strong>域</strong> 属于不同域时，该次请求称之为跨域请求。</p><ol><li><p>A应用只能访问 A 应用后台传来数据，B 应用只能访问 B 应用后台传来的数据；</p></li><li><p>如果 A 应用用 Ajax 获取数据时的 URL 地址中的协议、端口、域名其中有一个和 B 应用对应的话，则是 A 应用跨域获取 B 应用数据，是不允许的。</p><h2 id="同源策略"><a href="#同源策略" class="headerlink" title="同源策略"></a>同源策略</h2><p>同源策略（Sameoriginpolicy）是一种约定，它是浏览器最核心也最基本的安全功能，如果缺少了同源策略，则浏览器的正常功能可能都会受到影响。可以说Web是构建在同源策略基础之上的，浏览器只是针对同源策略的一种实现。</p></li><li><p>同源策略会阻止一个域的javascript脚本和另外一个域的内容进行交互。</p></li><li><p>所谓同源（即指在同一个域）就是两个页面具有相同的协议（protocol），主机（host）和端口号（port）</p><h2 id="跨域的几种情况"><a href="#跨域的几种情况" class="headerlink" title="跨域的几种情况"></a>跨域的几种情况</h2></li></ol><ul><li>同一域名下允许通信（未指定端口协议）</li><li>同一域名下不同文件夹允许通信</li><li>同一域名不同端口不允许通信</li><li>同一域名不同协议不允许通信</li><li>域名和域名对应IP不允许通信</li><li>主域名相同，子域名不同不允许通信</li><li>同一域名，不同二级域名不允许通信</li><li>不同域名不允许通信</li></ul><table><thead><tr><th>当前页面 URL</th><th>被请求URL</th><th>是否跨越</th><th>原因</th></tr></thead><tbody><tr><td><a href="http://www.baidu.com/">http://www.baidu.com</a></td><td><a href="http://www.baidu.com/java.html">http://www.baidu.com/java.html</a></td><td>否</td><td>同源(协议，域名，端口均相同)</td></tr><tr><td><a href="http://www.baidu.com/">http://www.baidu.com</a></td><td><a href="https://www.baidu.com/java.html">https://www.baidu.com/java.html</a></td><td>跨越</td><td>协议不同(http，https)</td></tr><tr><td><a href="http://www.baidu.com/">http://www.baidu.com</a></td><td><a href="http://www.google.com/">http://www.google.com</a></td><td>跨越</td><td>主域名不同(baidu，google)</td></tr><tr><td><a href="http://www.baidu.com/">http://www.baidu.com</a></td><td><a href="http://zhidao.baidu.com/">http://zhidao.baidu.com</a></td><td>跨越</td><td>子域名不同(www，zhidao)</td></tr><tr><td><a href="http://www.baidu.com:8080/">http://www.baidu.com:8080</a></td><td><a href="http://www.baidu.com:90/">http://www.baidu.com:90</a></td><td>跨越</td><td>端口不同(80，90))</td></tr></tbody></table><h2 id="1-定义-CorsFilter-全局跨域"><a href="#1-定义-CorsFilter-全局跨域" class="headerlink" title="1. 定义 CorsFilter (全局跨域)"></a>1. 定义 CorsFilter (全局跨域)</h2><p>在配置类中，返回一个 新的 CorsFIlter Bean ，并添加映射路径和具体的CORS配置路径。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Configuration</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">GlobalCorsConfig</span> <span class="token punctuation">&#123;</span>    <span class="token annotation punctuation">@Bean</span>    <span class="token keyword">public</span> <span class="token class-name">CorsFilter</span> <span class="token function">corsFilter</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">//1. 添加 CORS配置信息</span>        <span class="token class-name">CorsConfiguration</span> config <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CorsConfiguration</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//放行哪些原始域</span>        config<span class="token punctuation">.</span><span class="token function">addAllowedOrigin</span><span class="token punctuation">(</span><span class="token string">"*"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//是否发送 Cookie</span>        config<span class="token punctuation">.</span><span class="token function">setAllowCredentials</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//放行哪些请求方式</span>        config<span class="token punctuation">.</span><span class="token function">addAllowedMethod</span><span class="token punctuation">(</span><span class="token string">"*"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//放行哪些原始请求头部信息</span>        config<span class="token punctuation">.</span><span class="token function">addAllowedHeader</span><span class="token punctuation">(</span><span class="token string">"*"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//暴露哪些头部信息</span>        config<span class="token punctuation">.</span><span class="token function">addExposedHeader</span><span class="token punctuation">(</span><span class="token string">"*"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//2. 添加映射路径</span>        <span class="token class-name">UrlBasedCorsConfigurationSource</span> corsConfigurationSource <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">UrlBasedCorsConfigurationSource</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        corsConfigurationSource<span class="token punctuation">.</span><span class="token function">registerCorsConfiguration</span><span class="token punctuation">(</span><span class="token string">"/**"</span><span class="token punctuation">,</span>config<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//3. 返回新的CorsFilter</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">CorsFilter</span><span class="token punctuation">(</span>corsConfigurationSource<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2-重写-WebMvcConfigurer-全局跨域"><a href="#2-重写-WebMvcConfigurer-全局跨域" class="headerlink" title="2. 重写 WebMvcConfigurer (全局跨域)"></a>2. 重写 WebMvcConfigurer (全局跨域)</h2><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Configuration</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">CorsConfig</span> <span class="token keyword">implements</span> <span class="token class-name">WebMvcConfigurer</span> <span class="token punctuation">&#123;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">addCorsMappings</span><span class="token punctuation">(</span><span class="token class-name">CorsRegistry</span> registry<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        registry<span class="token punctuation">.</span><span class="token function">addMapping</span><span class="token punctuation">(</span><span class="token string">"/**"</span><span class="token punctuation">)</span>                <span class="token comment">//是否发送Cookie</span>                <span class="token punctuation">.</span><span class="token function">allowCredentials</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span>                <span class="token comment">//放行哪些原始域</span>                <span class="token punctuation">.</span><span class="token function">allowedOrigins</span><span class="token punctuation">(</span><span class="token string">"*"</span><span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">allowedMethods</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">&#123;</span><span class="token string">"GET"</span><span class="token punctuation">,</span> <span class="token string">"POST"</span><span class="token punctuation">,</span> <span class="token string">"PUT"</span><span class="token punctuation">,</span> <span class="token string">"DELETE"</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">allowedHeaders</span><span class="token punctuation">(</span><span class="token string">"*"</span><span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">exposedHeaders</span><span class="token punctuation">(</span><span class="token string">"*"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3-使用自定义-Filter-全局跨域"><a href="#3-使用自定义-Filter-全局跨域" class="headerlink" title="3.  使用自定义 Filter (全局跨域)"></a>3.  使用自定义 Filter (全局跨域)</h2><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>context<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span></span><span class="token class-name">Configuration</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">javax<span class="token punctuation">.</span>servlet<span class="token punctuation">.</span></span><span class="token operator">*</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">javax<span class="token punctuation">.</span>servlet<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span></span><span class="token class-name">WebFilter</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">javax<span class="token punctuation">.</span>servlet<span class="token punctuation">.</span>http<span class="token punctuation">.</span></span><span class="token class-name">HttpServletResponse</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span><span class="token class-name">IOException</span><span class="token punctuation">;</span><span class="token annotation punctuation">@WebFilter</span><span class="token punctuation">(</span>filterName <span class="token operator">=</span> <span class="token string">"CorsFilter "</span><span class="token punctuation">)</span><span class="token annotation punctuation">@Configuration</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">CorsFilter</span> <span class="token keyword">implements</span> <span class="token class-name">Filter</span> <span class="token punctuation">&#123;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">doFilter</span><span class="token punctuation">(</span><span class="token class-name">ServletRequest</span> req<span class="token punctuation">,</span> <span class="token class-name">ServletResponse</span> res<span class="token punctuation">,</span> <span class="token class-name">FilterChain</span> chain<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span><span class="token punctuation">,</span> <span class="token class-name">ServletException</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">HttpServletResponse</span> response <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">HttpServletResponse</span><span class="token punctuation">)</span> res<span class="token punctuation">;</span>        response<span class="token punctuation">.</span><span class="token function">setHeader</span><span class="token punctuation">(</span><span class="token string">"Access-Control-Allow-Origin"</span><span class="token punctuation">,</span><span class="token string">"*"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        response<span class="token punctuation">.</span><span class="token function">setHeader</span><span class="token punctuation">(</span><span class="token string">"Access-Control-Allow-Credentials"</span><span class="token punctuation">,</span> <span class="token string">"true"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        response<span class="token punctuation">.</span><span class="token function">setHeader</span><span class="token punctuation">(</span><span class="token string">"Access-Control-Allow-Methods"</span><span class="token punctuation">,</span> <span class="token string">"POST, GET, PATCH, DELETE, PUT"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        response<span class="token punctuation">.</span><span class="token function">setHeader</span><span class="token punctuation">(</span><span class="token string">"Access-Control-Max-Age"</span><span class="token punctuation">,</span> <span class="token string">"3600"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        response<span class="token punctuation">.</span><span class="token function">setHeader</span><span class="token punctuation">(</span><span class="token string">"Access-Control-Allow-Headers"</span><span class="token punctuation">,</span> <span class="token string">"Origin, X-Requested-With, Content-Type, Accept"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        chain<span class="token punctuation">.</span><span class="token function">doFilter</span><span class="token punctuation">(</span>req<span class="token punctuation">,</span> res<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="4-使用注解-局部跨域"><a href="#4-使用注解-局部跨域" class="headerlink" title="4.  使用注解 (局部跨域)"></a>4.  使用注解 (局部跨域)</h2><p>在 crontaller 类或者方法上使用注解 @CrossOrigin  表示该类的所有方法允许跨域。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"># 在类上面设置<span class="token annotation punctuation">@RestController</span><span class="token annotation punctuation">@CrossOrigin</span><span class="token punctuation">(</span>origins <span class="token operator">=</span> <span class="token string">"*"</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">HelloController</span> <span class="token punctuation">&#123;</span>    <span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span><span class="token string">"/hello"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">hello</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token string">"hello world"</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span># 在方法上面设置<span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span><span class="token string">"/hello"</span><span class="token punctuation">)</span><span class="token annotation punctuation">@CrossOrigin</span><span class="token punctuation">(</span>origins <span class="token operator">=</span> <span class="token string">"*"</span><span class="token punctuation">)</span><span class="token comment">//@CrossOrigin(value = "http://localhost:8081") //指定具体ip允许跨域</span><span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">hello</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token string">"hello world"</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 跨域 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>事件总线 EventBus</title>
      <link href="/posts/34942.html"/>
      <url>/posts/34942.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>EventBus 顾名思义，事件总线，是一个轻量级的 <strong>发布 - 订阅</strong> 模式的应用模式。相比于 MQ 更加简洁，轻量，它可以在一个小系统模块内部使用</p><p> EventBus允许组件之间通过<strong>发布 - 订阅</strong>进行通信，而不需要组件之间显示的注册。它专门设计为了代替使用显示注册的传统的 Java 进程内事件分发。它不是通用的发布-订阅系统，也不是用于进程间通信的。</p><h2 id="EventBus-介绍"><a href="#EventBus-介绍" class="headerlink" title="EventBus 介绍"></a>EventBus 介绍</h2><p>EventBus 是 google 的 Guava 库中的一个处理组件间通信的事件总线，它基于发布/订阅模式，实现了多组件之间通信的解耦合，事件产生方和事件消费方实现解耦分离，提升了通信的简洁性。</p><p>当一个事件的发生(事件产生方)，需要触发很多事件(事件消费方)的时候，我们通常会在事件产生方中，分别的去调用那些事件消费方，这样往往是很浪费资源。事件的产生方与事件的消费方，产生了极大的耦合，如果我们要改动某一个事件消费方，我们很可能还要改动事件的产生方。</p><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><p>在工作中，经常会遇见使用异步的方式来发送事件，或者触发另外一个动作：经常用到的框架是MQ（分布式方式通知）。如果是同一个 jvm 里面通知的话，就可以使用EventBus。由于EventBus使用起来简单、便捷，因此，工作中会经常用到。</p><h2 id="事件总线三要素"><a href="#事件总线三要素" class="headerlink" title="事件总线三要素"></a>事件总线三要素</h2><p><img src="https://img-blog.csdnimg.cn/53bc6afa990e4ff7b45e92c891524fef.png" alt="在这里插入图片描述"></p><h3 id="事件（Event）"><a href="#事件（Event）" class="headerlink" title="事件（Event）"></a>事件（Event）</h3><p>事件是EventBus之间相互通信的基本单位，一个Event可以是任何类型。一般会定义特定的事件类，类名以Event作为后缀，里面定义一些变量或者函数等。</p><h3 id="发布者（Publisher）"><a href="#发布者（Publisher）" class="headerlink" title="发布者（Publisher）"></a>发布者（Publisher）</h3><p>事件发布者，就是发送事件到EventBus事件总线的一方，事件发布者调用Post()方法，将事件发给EventBus。可以在程序的任何地方，调用EventBus的post()方法，发送事件给EventBus。</p><h3 id="订阅者（Subscriber）"><a href="#订阅者（Subscriber）" class="headerlink" title="订阅者（Subscriber）"></a>订阅者（Subscriber）</h3><p>事件订阅者，就是接收事件的一方，这些订阅者需要在自己的方法上，添加@Subscribe注解声明自己为事件订阅者。不过只声明是不够的，还需要将自己所在的类，注册到EventBus中，EventBus才能扫描到这个订阅者。</p><h2 id="EventBusConfig-配置"><a href="#EventBusConfig-配置" class="headerlink" title="EventBusConfig 配置"></a>EventBusConfig 配置</h2><h3 id="config"><a href="#config" class="headerlink" title="config"></a>config</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/** * @date 2022/7/14 10:45 * @desc 事件总线配置 */</span><span class="token annotation punctuation">@Configuration</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">EventBusConfig</span> <span class="token punctuation">&#123;</span><span class="token annotation punctuation">@Bean</span><span class="token keyword">public</span> <span class="token class-name">AsyncEventBus</span> <span class="token function">asyncEventBus</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">int</span> corePoolSize <span class="token operator">=</span> <span class="token class-name">Runtime</span><span class="token punctuation">.</span><span class="token function">getRuntime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">availableProcessors</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> maxPoolSize <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span><span class="token keyword">int</span> keepAliveTime <span class="token operator">=</span> <span class="token number">60</span> <span class="token operator">*</span> <span class="token number">1000</span><span class="token punctuation">;</span><span class="token class-name">BlockingQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Runnable</span><span class="token punctuation">></span></span> workQueue <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayBlockingQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token number">5000</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">RejectedExecutionHandler</span> handler <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ThreadPoolExecutor<span class="token punctuation">.</span>AbortPolicy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">ThreadFactory</span> factory <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ThreadFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">AtomicInteger</span> integer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AtomicInteger</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token annotation punctuation">@Override</span><span class="token keyword">public</span> <span class="token class-name">Thread</span> <span class="token function">newThread</span><span class="token punctuation">(</span><span class="token annotation punctuation">@Nonnull</span> <span class="token class-name">Runnable</span> r<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>r<span class="token punctuation">,</span> <span class="token string">"TheadPool-Thread-"</span> <span class="token operator">+</span> integer<span class="token punctuation">.</span><span class="token function">getAndIncrement</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">AsyncEventBus</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ThreadPoolExecutor</span><span class="token punctuation">(</span>corePoolSize<span class="token punctuation">,</span> maxPoolSize<span class="token punctuation">,</span> keepAliveTime<span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span>SECONDS<span class="token punctuation">,</span> workQueue<span class="token punctuation">,</span> factory<span class="token punctuation">,</span> handler<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Handler"><a href="#Handler" class="headerlink" title="Handler"></a>Handler</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> xxxEventHandler <span class="token punctuation">&#123;</span>        <span class="token annotation punctuation">@PostConstruct</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        asyncEventBus<span class="token punctuation">.</span><span class="token function">register</span><span class="token punctuation">(</span>xxxListener<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>        <span class="token annotation punctuation">@PreDestroy</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">destroy</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        asyncEventBus<span class="token punctuation">.</span><span class="token function">unregister</span><span class="token punctuation">(</span>xxxListener<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Listener"><a href="#Listener" class="headerlink" title="Listener"></a>Listener</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Subscribe</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">onMessageEvent</span><span class="token punctuation">(</span><span class="token class-name">Event</span> event<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token comment">// todo</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="post"><a href="#post" class="headerlink" title="post"></a>post</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">asyncEventBus<span class="token punctuation">.</span><span class="token function">post</span><span class="token punctuation">(</span>event<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="EventBus-和-AsyncEventBus-区别"><a href="#EventBus-和-AsyncEventBus-区别" class="headerlink" title="EventBus 和 AsyncEventBus 区别"></a>EventBus 和 AsyncEventBus 区别</h2><h3 id="EventBus-同步事件总线"><a href="#EventBus-同步事件总线" class="headerlink" title="EventBus: 同步事件总线"></a>EventBus: 同步事件总线</h3><ol><li><p>同步执行，事件发送方在发出事件之后，会等待所有的事件消费方执行完毕后，才会回来继续执行自己后面的代码。</p></li><li><p>事件发送方和事件消费方会在同一个线程中执行，消费方的执行线程取决于发送方。</p></li><li><p>同一个事件的多个订阅者，在接收到事件的顺序上面有不同。谁先注册到EventBus的，谁先执行，如果是在同一个类中的两个订阅者一起被注册到EventBus的情况，收到事件的顺序跟方法名有关。</p><h3 id="AsyncEventBus-异步事件总线"><a href="#AsyncEventBus-异步事件总线" class="headerlink" title="AsyncEventBus: 异步事件总线"></a>AsyncEventBus: 异步事件总线</h3></li><li><p>异步执行，事件发送方异步发出事件，不会等待事件消费方是否收到，直接执行自己后面的代码。</p></li><li><p>在定义AsyncEventBus时，构造函数中会传入一个线程池。事件消费方收到异步事件时，消费方会从线程池中获取一个新的线程来执行自己的任务。</p></li><li><p>同一个事件的多个订阅者，它们的注册顺序跟接收到事件的顺序上没有任何联系，都会同时收到事件，并且都是在新的线程中，异步并发的执行自己的任务。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 消息队列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 发布/订阅 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go 数据结构之 Slice (三)</title>
      <link href="/posts/40335.html"/>
      <url>/posts/40335.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><a href="https://blog.csdn.net/upstream480/article/details/124639529">Golang 数据结构之 Slice (二)</a><br>上一篇文章介绍了一下扩容的基本情况，这一篇文章分析了 growslice 函数的源码</p><h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><p>我们看看 growslice函数的源码，可以分成三部分：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">growslice</span><span class="token punctuation">(</span>et <span class="token operator">*</span>_type<span class="token punctuation">,</span> old slice<span class="token punctuation">,</span> <span class="token builtin">cap</span> <span class="token builtin">int</span><span class="token punctuation">)</span> slice <span class="token punctuation">&#123;</span><span class="token keyword">if</span> raceenabled <span class="token punctuation">&#123;</span>callerpc <span class="token operator">:=</span> <span class="token function">getcallerpc</span><span class="token punctuation">(</span>unsafe<span class="token punctuation">.</span><span class="token function">Pointer</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>et<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token function">racereadrangepc</span><span class="token punctuation">(</span>old<span class="token punctuation">.</span>array<span class="token punctuation">,</span> <span class="token function">uintptr</span><span class="token punctuation">(</span>old<span class="token punctuation">.</span><span class="token builtin">len</span><span class="token operator">*</span><span class="token function">int</span><span class="token punctuation">(</span>et<span class="token punctuation">.</span>size<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> callerpc<span class="token punctuation">,</span> <span class="token function">funcPC</span><span class="token punctuation">(</span>growslice<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token keyword">if</span> msanenabled <span class="token punctuation">&#123;</span><span class="token function">msanread</span><span class="token punctuation">(</span>old<span class="token punctuation">.</span>array<span class="token punctuation">,</span> <span class="token function">uintptr</span><span class="token punctuation">(</span>old<span class="token punctuation">.</span><span class="token builtin">len</span><span class="token operator">*</span><span class="token function">int</span><span class="token punctuation">(</span>et<span class="token punctuation">.</span>size<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token keyword">if</span> et<span class="token punctuation">.</span>size <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">&#123;</span><span class="token keyword">if</span> <span class="token builtin">cap</span> <span class="token operator">&lt;</span> old<span class="token punctuation">.</span><span class="token builtin">cap</span> <span class="token punctuation">&#123;</span><span class="token function">panic</span><span class="token punctuation">(</span><span class="token function">errorString</span><span class="token punctuation">(</span><span class="token string">"growslice: cap out of range"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token comment">// append should not create a slice with nil pointer but non-zero len.</span><span class="token comment">// We assume that append doesn't need to preserve old.array in this case.</span><span class="token keyword">return</span> slice<span class="token punctuation">&#123;</span>unsafe<span class="token punctuation">.</span><span class="token function">Pointer</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>zerobase<span class="token punctuation">)</span><span class="token punctuation">,</span> old<span class="token punctuation">.</span><span class="token builtin">len</span><span class="token punctuation">,</span> <span class="token builtin">cap</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span>newcap <span class="token operator">:=</span> old<span class="token punctuation">.</span><span class="token builtin">cap</span>doublecap <span class="token operator">:=</span> newcap <span class="token operator">+</span> newcap<span class="token keyword">if</span> <span class="token builtin">cap</span> <span class="token operator">></span> doublecap <span class="token punctuation">&#123;</span>newcap <span class="token operator">=</span> <span class="token builtin">cap</span><span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span><span class="token keyword">if</span> old<span class="token punctuation">.</span><span class="token builtin">len</span> <span class="token operator">&lt;</span> <span class="token number">1024</span> <span class="token punctuation">&#123;</span>newcap <span class="token operator">=</span> doublecap<span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span><span class="token keyword">for</span> newcap <span class="token operator">&lt;</span> <span class="token builtin">cap</span> <span class="token punctuation">&#123;</span>newcap <span class="token operator">+=</span> newcap <span class="token operator">/</span> <span class="token number">4</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">var</span> lenmem<span class="token punctuation">,</span> newlenmem<span class="token punctuation">,</span> capmem <span class="token builtin">uintptr</span><span class="token keyword">const</span> ptrSize <span class="token operator">=</span> unsafe<span class="token punctuation">.</span><span class="token function">Sizeof</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token builtin">byte</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token boolean">nil</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">switch</span> et<span class="token punctuation">.</span>size <span class="token punctuation">&#123;</span><span class="token keyword">case</span> <span class="token number">1</span><span class="token punctuation">:</span>lenmem <span class="token operator">=</span> <span class="token function">uintptr</span><span class="token punctuation">(</span>old<span class="token punctuation">.</span><span class="token builtin">len</span><span class="token punctuation">)</span>newlenmem <span class="token operator">=</span> <span class="token function">uintptr</span><span class="token punctuation">(</span><span class="token builtin">cap</span><span class="token punctuation">)</span>capmem <span class="token operator">=</span> <span class="token function">roundupsize</span><span class="token punctuation">(</span><span class="token function">uintptr</span><span class="token punctuation">(</span>newcap<span class="token punctuation">)</span><span class="token punctuation">)</span>newcap <span class="token operator">=</span> <span class="token function">int</span><span class="token punctuation">(</span>capmem<span class="token punctuation">)</span><span class="token keyword">case</span> ptrSize<span class="token punctuation">:</span>lenmem <span class="token operator">=</span> <span class="token function">uintptr</span><span class="token punctuation">(</span>old<span class="token punctuation">.</span><span class="token builtin">len</span><span class="token punctuation">)</span> <span class="token operator">*</span> ptrSizenewlenmem <span class="token operator">=</span> <span class="token function">uintptr</span><span class="token punctuation">(</span><span class="token builtin">cap</span><span class="token punctuation">)</span> <span class="token operator">*</span> ptrSizecapmem <span class="token operator">=</span> <span class="token function">roundupsize</span><span class="token punctuation">(</span><span class="token function">uintptr</span><span class="token punctuation">(</span>newcap<span class="token punctuation">)</span> <span class="token operator">*</span> ptrSize<span class="token punctuation">)</span>newcap <span class="token operator">=</span> <span class="token function">int</span><span class="token punctuation">(</span>capmem <span class="token operator">/</span> ptrSize<span class="token punctuation">)</span><span class="token keyword">default</span><span class="token punctuation">:</span>lenmem <span class="token operator">=</span> <span class="token function">uintptr</span><span class="token punctuation">(</span>old<span class="token punctuation">.</span><span class="token builtin">len</span><span class="token punctuation">)</span> <span class="token operator">*</span> et<span class="token punctuation">.</span>sizenewlenmem <span class="token operator">=</span> <span class="token function">uintptr</span><span class="token punctuation">(</span><span class="token builtin">cap</span><span class="token punctuation">)</span> <span class="token operator">*</span> et<span class="token punctuation">.</span>sizecapmem <span class="token operator">=</span> <span class="token function">roundupsize</span><span class="token punctuation">(</span><span class="token function">uintptr</span><span class="token punctuation">(</span>newcap<span class="token punctuation">)</span> <span class="token operator">*</span> et<span class="token punctuation">.</span>size<span class="token punctuation">)</span>newcap <span class="token operator">=</span> <span class="token function">int</span><span class="token punctuation">(</span>capmem <span class="token operator">/</span> et<span class="token punctuation">.</span>size<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token keyword">if</span> <span class="token builtin">cap</span> <span class="token operator">&lt;</span> old<span class="token punctuation">.</span><span class="token builtin">cap</span> <span class="token operator">||</span> <span class="token function">uintptr</span><span class="token punctuation">(</span>newcap<span class="token punctuation">)</span> <span class="token operator">></span> <span class="token function">maxSliceCap</span><span class="token punctuation">(</span>et<span class="token punctuation">.</span>size<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token function">panic</span><span class="token punctuation">(</span><span class="token function">errorString</span><span class="token punctuation">(</span><span class="token string">"growslice: cap out of range"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token keyword">var</span> p unsafe<span class="token punctuation">.</span>Pointer<span class="token keyword">if</span> et<span class="token punctuation">.</span>kind<span class="token operator">&amp;</span>kindNoPointers <span class="token operator">!=</span> <span class="token number">0</span> <span class="token punctuation">&#123;</span>p <span class="token operator">=</span> <span class="token function">mallocgc</span><span class="token punctuation">(</span>capmem<span class="token punctuation">,</span> <span class="token boolean">nil</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token function">memmove</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span> old<span class="token punctuation">.</span>array<span class="token punctuation">,</span> lenmem<span class="token punctuation">)</span><span class="token comment">// The append() that calls growslice is going to overwrite from old.len to cap (which will be the new length).</span><span class="token comment">// Only clear the part that will not be overwritten.</span><span class="token function">memclrNoHeapPointers</span><span class="token punctuation">(</span><span class="token function">add</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span> newlenmem<span class="token punctuation">)</span><span class="token punctuation">,</span> capmem<span class="token operator">-</span>newlenmem<span class="token punctuation">)</span><span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span><span class="token comment">// Note: can't use rawmem (which avoids zeroing of memory), because then GC can scan uninitialized memory.</span>p <span class="token operator">=</span> <span class="token function">mallocgc</span><span class="token punctuation">(</span>capmem<span class="token punctuation">,</span> et<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token keyword">if</span> <span class="token operator">!</span>writeBarrier<span class="token punctuation">.</span>enabled <span class="token punctuation">&#123;</span><span class="token function">memmove</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span> old<span class="token punctuation">.</span>array<span class="token punctuation">,</span> lenmem<span class="token punctuation">)</span><span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span><span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token function">uintptr</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> lenmem<span class="token punctuation">;</span> i <span class="token operator">+=</span> et<span class="token punctuation">.</span>size <span class="token punctuation">&#123;</span><span class="token function">typedmemmove</span><span class="token punctuation">(</span>et<span class="token punctuation">,</span> <span class="token function">add</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">add</span><span class="token punctuation">(</span>old<span class="token punctuation">.</span>array<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">return</span> slice<span class="token punctuation">&#123;</span>p<span class="token punctuation">,</span> old<span class="token punctuation">.</span><span class="token builtin">len</span><span class="token punctuation">,</span> newcap<span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="zerobase-策略"><a href="#zerobase-策略" class="headerlink" title="zerobase 策略"></a>zerobase 策略</h2><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">growslice</span><span class="token punctuation">(</span>et <span class="token operator">*</span>_type<span class="token punctuation">,</span> old slice<span class="token punctuation">,</span> <span class="token builtin">cap</span> <span class="token builtin">int</span><span class="token punctuation">)</span> slice <span class="token punctuation">&#123;</span><span class="token comment">// 省略～～～</span><span class="token keyword">if</span> et<span class="token punctuation">.</span>size <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">&#123;</span><span class="token keyword">if</span> <span class="token builtin">cap</span> <span class="token operator">&lt;</span> old<span class="token punctuation">.</span><span class="token builtin">cap</span> <span class="token punctuation">&#123;</span><span class="token function">panic</span><span class="token punctuation">(</span><span class="token function">errorString</span><span class="token punctuation">(</span><span class="token string">"growslice: cap out of range"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token comment">// append should not create a slice with nil pointer but non-zero len.</span><span class="token comment">// We assume that append doesn't need to preserve old.array in this case.</span><span class="token keyword">return</span> slice<span class="token punctuation">&#123;</span>unsafe<span class="token punctuation">.</span><span class="token function">Pointer</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>zerobase<span class="token punctuation">)</span><span class="token punctuation">,</span> old<span class="token punctuation">.</span><span class="token builtin">len</span><span class="token punctuation">,</span> <span class="token builtin">cap</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">// 省略～～～</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>如果 size 为 0 ，若将要扩容的容量比原本的容量小，则抛出异常（不能缩小）</li><li>否则，将重新生成一个新的 Slice 返回，其 Pointer 指向一个 0 byte 地址。</li></ul><h2 id="容量计算"><a href="#容量计算" class="headerlink" title="容量计算"></a>容量计算</h2><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">growslice</span><span class="token punctuation">(</span>et <span class="token operator">*</span>_type<span class="token punctuation">,</span> old slice<span class="token punctuation">,</span> <span class="token builtin">cap</span> <span class="token builtin">int</span><span class="token punctuation">)</span> slice <span class="token punctuation">&#123;</span><span class="token comment">//省略～～～</span>    <span class="token comment">// 新容量默认为原有容量</span>    newcap <span class="token operator">:=</span> old<span class="token punctuation">.</span><span class="token builtin">cap</span>    doublecap <span class="token operator">:=</span> newcap <span class="token operator">+</span> newcap    <span class="token comment">// 如果新容量大于旧容量的两倍，则直接按照新容量大小申请</span>    <span class="token keyword">if</span> <span class="token builtin">cap</span> <span class="token operator">></span> doublecap <span class="token punctuation">&#123;</span>newcap <span class="token operator">=</span> <span class="token builtin">cap</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 如果原有长度小于1024，则新容量是旧容量的2倍</span>        <span class="token keyword">if</span> old<span class="token punctuation">.</span><span class="token builtin">len</span> <span class="token operator">&lt;</span> <span class="token number">1024</span> <span class="token punctuation">&#123;</span>            newcap <span class="token operator">=</span> doublecap        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// 按照原有容量的 1/4 增加，直到满足新容量的需要</span>            <span class="token keyword">for</span> <span class="token number">0</span> <span class="token operator">&lt;</span> newcap <span class="token operator">&amp;&amp;</span> newcap <span class="token operator">&lt;</span> <span class="token builtin">cap</span> <span class="token punctuation">&#123;</span>                newcap <span class="token operator">+=</span> newcap <span class="token operator">/</span> <span class="token number">4</span>            <span class="token punctuation">&#125;</span>            <span class="token comment">// 检查容量是否溢出。</span>            <span class="token keyword">if</span> newcap <span class="token operator">&lt;=</span> <span class="token number">0</span> <span class="token punctuation">&#123;</span>                newcap <span class="token operator">=</span> <span class="token builtin">cap</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">//省略～～～</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>若 cap 大于 doublecap，则扩容后容量大小为 新 Slice 的容量;</li><li>若 len 小于 1024 个，在扩容时，增长因子为 1（也就是增加 1 倍）</li><li>若 len 大于 1024 个，在扩容时，增长因子为 0.25（原本容量的四分之一）</li></ul><p>总的来说，就是 len 小于 1024 时，增长 2 倍。大于 1024 时，增长 1.25 倍</p><h2 id="内存对齐"><a href="#内存对齐" class="headerlink" title="内存对齐"></a>内存对齐</h2><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">growslice</span><span class="token punctuation">(</span>et <span class="token operator">*</span>_type<span class="token punctuation">,</span> old slice<span class="token punctuation">,</span> <span class="token builtin">cap</span> <span class="token builtin">int</span><span class="token punctuation">)</span> slice <span class="token punctuation">&#123;</span><span class="token comment">//省略～～～</span>    <span class="token keyword">var</span> overflow <span class="token builtin">bool</span>    <span class="token keyword">var</span> lenmem<span class="token punctuation">,</span> newlenmem<span class="token punctuation">,</span> capmem <span class="token builtin">uintptr</span>        <span class="token keyword">switch</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">case</span> et<span class="token punctuation">.</span>size <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">:</span>        lenmem <span class="token operator">=</span> <span class="token function">uintptr</span><span class="token punctuation">(</span>old<span class="token punctuation">.</span><span class="token builtin">len</span><span class="token punctuation">)</span>        newlenmem <span class="token operator">=</span> <span class="token function">uintptr</span><span class="token punctuation">(</span><span class="token builtin">cap</span><span class="token punctuation">)</span>        capmem <span class="token operator">=</span> <span class="token function">roundupsize</span><span class="token punctuation">(</span><span class="token function">uintptr</span><span class="token punctuation">(</span>newcap<span class="token punctuation">)</span><span class="token punctuation">)</span>        overflow <span class="token operator">=</span> <span class="token function">uintptr</span><span class="token punctuation">(</span>newcap<span class="token punctuation">)</span> <span class="token operator">></span> maxAlloc        newcap <span class="token operator">=</span> <span class="token function">int</span><span class="token punctuation">(</span>capmem<span class="token punctuation">)</span>    <span class="token keyword">case</span> et<span class="token punctuation">.</span>size <span class="token operator">==</span> sys<span class="token punctuation">.</span>PtrSize<span class="token punctuation">:</span>        lenmem <span class="token operator">=</span> <span class="token function">uintptr</span><span class="token punctuation">(</span>old<span class="token punctuation">.</span><span class="token builtin">len</span><span class="token punctuation">)</span> <span class="token operator">*</span> sys<span class="token punctuation">.</span>PtrSize        newlenmem <span class="token operator">=</span> <span class="token function">uintptr</span><span class="token punctuation">(</span><span class="token builtin">cap</span><span class="token punctuation">)</span> <span class="token operator">*</span> sys<span class="token punctuation">.</span>PtrSize        capmem <span class="token operator">=</span> <span class="token function">roundupsize</span><span class="token punctuation">(</span><span class="token function">uintptr</span><span class="token punctuation">(</span>newcap<span class="token punctuation">)</span> <span class="token operator">*</span> sys<span class="token punctuation">.</span>PtrSize<span class="token punctuation">)</span>        overflow <span class="token operator">=</span> <span class="token function">uintptr</span><span class="token punctuation">(</span>newcap<span class="token punctuation">)</span> <span class="token operator">></span> maxAlloc<span class="token operator">/</span>sys<span class="token punctuation">.</span>PtrSize        newcap <span class="token operator">=</span> <span class="token function">int</span><span class="token punctuation">(</span>capmem <span class="token operator">/</span> sys<span class="token punctuation">.</span>PtrSize<span class="token punctuation">)</span>    <span class="token keyword">case</span> <span class="token function">isPowerOfTwo</span><span class="token punctuation">(</span>et<span class="token punctuation">.</span>size<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">var</span> shift <span class="token builtin">uintptr</span>        <span class="token keyword">if</span> sys<span class="token punctuation">.</span>PtrSize <span class="token operator">==</span> <span class="token number">8</span> <span class="token punctuation">&#123;</span>            shift <span class="token operator">=</span> <span class="token function">uintptr</span><span class="token punctuation">(</span>sys<span class="token punctuation">.</span><span class="token function">Ctz64</span><span class="token punctuation">(</span><span class="token function">uint64</span><span class="token punctuation">(</span>et<span class="token punctuation">.</span>size<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token number">63</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>            shift <span class="token operator">=</span> <span class="token function">uintptr</span><span class="token punctuation">(</span>sys<span class="token punctuation">.</span><span class="token function">Ctz32</span><span class="token punctuation">(</span><span class="token function">uint32</span><span class="token punctuation">(</span>et<span class="token punctuation">.</span>size<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token number">31</span><span class="token punctuation">&#125;</span>        lenmem <span class="token operator">=</span> <span class="token function">uintptr</span><span class="token punctuation">(</span>old<span class="token punctuation">.</span><span class="token builtin">len</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> shift        newlenmem <span class="token operator">=</span> <span class="token function">uintptr</span><span class="token punctuation">(</span><span class="token builtin">cap</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> shift        capmem <span class="token operator">=</span> <span class="token function">roundupsize</span><span class="token punctuation">(</span><span class="token function">uintptr</span><span class="token punctuation">(</span>newcap<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> shift<span class="token punctuation">)</span>        overflow <span class="token operator">=</span> <span class="token function">uintptr</span><span class="token punctuation">(</span>newcap<span class="token punctuation">)</span> <span class="token operator">></span> <span class="token punctuation">(</span>maxAlloc <span class="token operator">>></span> shift<span class="token punctuation">)</span>        newcap <span class="token operator">=</span> <span class="token function">int</span><span class="token punctuation">(</span>capmem <span class="token operator">>></span> shift<span class="token punctuation">)</span>    <span class="token keyword">default</span><span class="token punctuation">:</span>        lenmem <span class="token operator">=</span> <span class="token function">uintptr</span><span class="token punctuation">(</span>old<span class="token punctuation">.</span><span class="token builtin">len</span><span class="token punctuation">)</span> <span class="token operator">*</span> et<span class="token punctuation">.</span>size        newlenmem <span class="token operator">=</span> <span class="token function">uintptr</span><span class="token punctuation">(</span><span class="token builtin">cap</span><span class="token punctuation">)</span> <span class="token operator">*</span> et<span class="token punctuation">.</span>size        capmem<span class="token punctuation">,</span> overflow <span class="token operator">=</span> math<span class="token punctuation">.</span><span class="token function">MulUintptr</span><span class="token punctuation">(</span>et<span class="token punctuation">.</span>size<span class="token punctuation">,</span> <span class="token function">uintptr</span><span class="token punctuation">(</span>newcap<span class="token punctuation">)</span><span class="token punctuation">)</span>        capmem <span class="token operator">=</span> <span class="token function">roundupsize</span><span class="token punctuation">(</span>capmem<span class="token punctuation">)</span>        newcap <span class="token operator">=</span> <span class="token function">int</span><span class="token punctuation">(</span>capmem <span class="token operator">/</span> et<span class="token punctuation">.</span>size<span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">//省略～～～</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>对于不同的slice元素大小，选择不同的计算方法，获取原来 Slice 长度和计算假定扩容后的新 Slice 元素长度、容量大小以及指针地址（用于后续操作）</p><h2 id="数据拷贝"><a href="#数据拷贝" class="headerlink" title="数据拷贝"></a>数据拷贝</h2><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">growslice</span><span class="token punctuation">(</span>et <span class="token operator">*</span>_type<span class="token punctuation">,</span> old slice<span class="token punctuation">,</span> <span class="token builtin">cap</span> <span class="token builtin">int</span><span class="token punctuation">)</span> slice <span class="token punctuation">&#123;</span><span class="token comment">//省略～～～</span><span class="token comment">//确定新 Slice 容量大于老 Sice，并且新容量内存小于指定的最大内存、没有溢出。否则抛出异常</span><span class="token keyword">if</span> <span class="token builtin">cap</span> <span class="token operator">&lt;</span> old<span class="token punctuation">.</span><span class="token builtin">cap</span> <span class="token operator">||</span> <span class="token function">uintptr</span><span class="token punctuation">(</span>newcap<span class="token punctuation">)</span> <span class="token operator">></span> <span class="token function">maxSliceCap</span><span class="token punctuation">(</span>et<span class="token punctuation">.</span>size<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token function">panic</span><span class="token punctuation">(</span><span class="token function">errorString</span><span class="token punctuation">(</span><span class="token string">"growslice: cap out of range"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token keyword">var</span> p unsafe<span class="token punctuation">.</span>Pointer<span class="token keyword">if</span> et<span class="token punctuation">.</span>kind<span class="token operator">&amp;</span>kindNoPointers <span class="token operator">!=</span> <span class="token number">0</span> <span class="token punctuation">&#123;</span>p <span class="token operator">=</span> <span class="token function">mallocgc</span><span class="token punctuation">(</span>capmem<span class="token punctuation">,</span> <span class="token boolean">nil</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token function">memmove</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span> old<span class="token punctuation">.</span>array<span class="token punctuation">,</span> lenmem<span class="token punctuation">)</span><span class="token comment">// The append() that calls growslice is going to overwrite from old.len to cap (which will be the new length).</span><span class="token comment">// Only clear the part that will not be overwritten.</span><span class="token function">memclrNoHeapPointers</span><span class="token punctuation">(</span><span class="token function">add</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span> newlenmem<span class="token punctuation">)</span><span class="token punctuation">,</span> capmem<span class="token operator">-</span>newlenmem<span class="token punctuation">)</span><span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span><span class="token comment">// Note: can't use rawmem (which avoids zeroing of memory), because then GC can scan uninitialized memory.</span>p <span class="token operator">=</span> <span class="token function">mallocgc</span><span class="token punctuation">(</span>capmem<span class="token punctuation">,</span> et<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token keyword">if</span> <span class="token operator">!</span>writeBarrier<span class="token punctuation">.</span>enabled <span class="token punctuation">&#123;</span><span class="token function">memmove</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span> old<span class="token punctuation">.</span>array<span class="token punctuation">,</span> lenmem<span class="token punctuation">)</span><span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span><span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token function">uintptr</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> lenmem<span class="token punctuation">;</span> i <span class="token operator">+=</span> et<span class="token punctuation">.</span>size <span class="token punctuation">&#123;</span><span class="token function">typedmemmove</span><span class="token punctuation">(</span>et<span class="token punctuation">,</span> <span class="token function">add</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">add</span><span class="token punctuation">(</span>old<span class="token punctuation">.</span>array<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">return</span> slice<span class="token punctuation">&#123;</span>p<span class="token punctuation">,</span> old<span class="token punctuation">.</span><span class="token builtin">len</span><span class="token punctuation">,</span> newcap<span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>若元素类型为 kindNoPointers，也就是非指针类型。则在原来的 Slice 后面继续扩容</p><ol><li>根据先前计算的 capmem，在老 Slice cap 后继续申请内存空间；</li><li>将 old.array 上的 n 个 bytes（根据 lenmem）拷贝到新的内存空间上</li><li>新内存空间（p）加上新 Slice cap 的容量地址。最终得到完整的新 Slice cap 内存地址 add(p, newlenmem) （ptr）</li><li>从 ptr 开始重新初始化 n 个 bytes（capmem-newlenmem）</li></ol><p>拷贝数据是这两个主要函数</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// 拷贝数据</span><span class="token function">memmove</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span> old<span class="token punctuation">.</span>array<span class="token punctuation">,</span> lenmem<span class="token punctuation">)</span><span class="token comment">// 返回新的切片</span><span class="token keyword">return</span> slice<span class="token punctuation">&#123;</span>p<span class="token punctuation">,</span> old<span class="token punctuation">.</span><span class="token builtin">len</span><span class="token punctuation">,</span> newcap<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go 数据结构之 Slice (二)</title>
      <link href="/posts/3373.html"/>
      <url>/posts/3373.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><a href="https://blog.csdn.net/upstream480/article/details/124575040">Golang 数据结构之 Slice (一)</a><br>上一篇文章写了Slice的基本数据结构，而且提到了Slice可以自动扩容，这篇文章就简单看看Slice是怎么样扩容的。</p><h2 id="append函数"><a href="#append函数" class="headerlink" title="append函数"></a>append函数</h2><p>说扩容之前，不得不说一下 Slice 内置的 append 函数，这是一个用于向slice 追加元素的函数</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">var</span> nums <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">&#123;</span>nums <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">&#125;</span>fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"nums: %+v"</span><span class="token punctuation">,</span> nums<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>append 函数对于理解Slice 底层是如何进行工作的，有重要的意义。这是 builtin/builtin.go 中关于append func的说明，append 函数将元素附加到 Slice 的末尾。 </p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// The append built-in function appends elements to the end of a slice. If</span><span class="token comment">// it has sufficient capacity, the destination is resliced to accommodate the</span><span class="token comment">// new elements. If it does not, a new underlying array will be allocated.</span><span class="token comment">// Append returns the updated slice. It is therefore necessary to store the</span><span class="token comment">// result of append, often in the variable holding the slice itself:</span><span class="token comment">//slice = append(slice, elem1, elem2)</span><span class="token comment">//slice = append(slice, anotherSlice...)</span><span class="token comment">// As a special case, it is legal to append a string to a byte slice, like this:</span><span class="token comment">//slice = append([]byte("hello "), "world"...)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>如果它有空间足够，则重新划分目标以容纳新元素，即将元素附加在末尾； </li><li>如果没有，将分配一个新的底层数组，将原来的元素复制过去，再附加；</li><li>append 返回更新后的切片。 因此需要将 append 的结果用输入的 slice 接收，这个情况后面会说到。</li></ul><p>另外一个appendInt函数描述了这个过程</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">appendInt</span><span class="token punctuation">(</span>x <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">,</span> y <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">var</span> z <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span>    zlen <span class="token operator">:=</span> <span class="token function">len</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span>    <span class="token keyword">if</span> zlen <span class="token operator">&lt;=</span> <span class="token function">cap</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        z <span class="token operator">=</span> x<span class="token punctuation">[</span><span class="token punctuation">:</span>zlen<span class="token punctuation">]</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>        zcap <span class="token operator">:=</span> zlen        <span class="token keyword">if</span> zcap <span class="token operator">&lt;</span> <span class="token number">2</span><span class="token operator">*</span><span class="token function">len</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            zcap <span class="token operator">=</span> <span class="token number">2</span> <span class="token operator">*</span> <span class="token function">len</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span>        <span class="token punctuation">&#125;</span>        z <span class="token operator">=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">,</span> zlen<span class="token punctuation">,</span> zcap<span class="token punctuation">)</span>        <span class="token function">copy</span><span class="token punctuation">(</span>z<span class="token punctuation">,</span> x<span class="token punctuation">)</span> <span class="token comment">// 复制</span>    <span class="token punctuation">&#125;</span>    z<span class="token punctuation">[</span><span class="token function">len</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> y    <span class="token keyword">return</span> z<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p>内置的 copy 函数将一个slice复制到另一个相同类型的 slice；</p></li><li><p>copy函数的第一个参数是要复制的目标slice，第二个参数是源slice；</p></li><li><p>两个slice可以共享同一个底层数组，甚至有重叠也没有问题；</p></li><li><p>copy函数将返回成功复制的元素的个数。</p></li><li><h2 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h2><p>通过在每次扩大数组时直接将长度翻倍从而避免了多次内存分配，也确保了添加单个元素操的平均时间是一个常数时间。也大大提高了内存的使用效率。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">var</span> nums <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">&#123;</span>nums <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> i<span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"cap=%d\t%v\n"</span><span class="token punctuation">,</span> <span class="token function">cap</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">,</span> nums<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://img-blog.csdnimg.cn/df2565fc0dfb410f905eab32866399f8.png" alt="在这里插入图片描述"></p></li><li><p>通常我们并不知道 append 调用是否导致了扩容，因此我们也不能确认新的slice和源slice是否引用的是相同的底层数组。</p></li><li><p>同样，我们不能确认在源的slice上的操作是否会影响到新的slice。所以上面说的，通常是将append 返回的结果直接赋值给输入的 slice变 量</p></li></ul><pre class="line-numbers language-go" data-language="go"><code class="language-go">nums <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>下一篇文章分析一下 growslice 函数的源码</p>]]></content>
      
      
      <categories>
          
          <category> go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go 数据结构之 Slice (一)</title>
      <link href="/posts/52617.html"/>
      <url>/posts/52617.html</url>
      
        <content type="html"><![CDATA[<h2 id="Golang-数据结构之-Slice"><a href="#Golang-数据结构之-Slice" class="headerlink" title="Golang 数据结构之 Slice"></a>Golang 数据结构之 Slice</h2><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>Slice（切片）是抽象在 Array（数组）之上的特殊的数据类型类型，在了解slice之前需要先了解一下Array的情况。</p><h3 id="Array-数组"><a href="#Array-数组" class="headerlink" title="Array 数组"></a>Array 数组</h3><p>Array数组就是 Golang 的基本数据类型中的数字，是一种顺序存储结构。</p><h4 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h4><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>nums <span class="token operator">:=</span> <span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span>nums<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">3</span>fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"nums: %v\n"</span><span class="token punctuation">,</span> nums<span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"nums[2]: %d\n"</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出结果<br><img src="https://img-blog.csdnimg.cn/ada74042c34a4d2bbcc0f680a043a9e4.png" alt="在这里插入图片描述"></p><h4 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h4><p>在使用的时候需要指定长度和存储元素类型。数组在声明后，其元素的初始值（也就是零值）为 0。并且该变量可以直接使用，不需要特殊操作。底层数据存储为一段连续的内存空间，通过固定的索引值（下标）进行检索。<br><img src="https://img-blog.csdnimg.cn/64b6faa8e5e24a27b7e357bebd57a9d0.png" alt="在这里插入图片描述"><br>需要注意的是数组的长度是固定的，它的长度是类型的一部分，因此 [3]int 和 [4]int 在类型上是不同的</p><h3 id="Slice-切片"><a href="#Slice-切片" class="headerlink" title="Slice 切片"></a>Slice 切片</h3><p>Slice 是对 Array 的抽象，Slice 和 Array 不一样，它不需要指定长度。使用更加的灵活，能够自动扩容。</p><h4 id="用法-1"><a href="#用法-1" class="headerlink" title="用法"></a>用法</h4><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>nums <span class="token operator">:=</span> <span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span>nums<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">3</span>slice <span class="token operator">:=</span> nums<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">]</span>fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"slice: %v"</span><span class="token punctuation">,</span> slice<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出结果为<br><img src="https://img-blog.csdnimg.cn/c067d758b2d846d283cab75d8ee5d1ac.png" alt="在这里插入图片描述"></p><h4 id="数据结构-1"><a href="#数据结构-1" class="headerlink" title="数据结构"></a>数据结构</h4><p>它的存储结构这样的，共分为三部分</p><ul><li>array：指向所引用的数组指针，可以说任意元素的指针</li><li>len：长度，当前引用切片的元素个数</li><li>cap：容量，当前引用切片的容量（底层数组的元素总数）<br><img src="https://img-blog.csdnimg.cn/dec0bdb11dad4d1599279fb7ef34be4c.png" alt="在这里插入图片描述"><br>在上述代码中，可观察到 slice := nums[:]，这行代码初始化了 Slice 的 Pointer 指向数组， len 和 cap 都为数组的基础属性，及长度为 4 。</li></ul><h4 id="len-cap"><a href="#len-cap" class="headerlink" title="len  != cap"></a>len  != cap</h4><p>len 可以不等于 cap，但必须大于或等于 len，否则会导致 panic</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>nums <span class="token operator">:=</span> <span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span>nums<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">3</span>slice <span class="token operator">:=</span> nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">:</span><span class="token number">3</span><span class="token punctuation">]</span>fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"slice: %v, len: %d, cap: %d"</span><span class="token punctuation">,</span> slice<span class="token punctuation">,</span> <span class="token function">len</span><span class="token punctuation">(</span>slice<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">cap</span><span class="token punctuation">(</span>slice<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://img-blog.csdnimg.cn/00c2170b76784a2d9ef065c37bfa74f4.png" alt="在这里插入图片描述">数据结构是这样的，只取了 nums 的三个元素的指针<br><img src="https://img-blog.csdnimg.cn/ce64d6d0168b47a78f3c9a2275d0252b.png" alt="在这里插入图片描述"></p><ul><li>len 为所引用元素的个数；</li><li>cap 为所引用的数组元素总个数。</li></ul><h4 id="另外一种创建方式"><a href="#另外一种创建方式" class="headerlink" title="另外一种创建方式"></a>另外一种创建方式</h4><p>创建切片除了上面的方式，还有另外一种不常见的方式，我们简单看一下源码</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// MakeSlice creates a new zero-initialized slice value</span><span class="token comment">// for the specified slice type, length, and capacity.</span><span class="token keyword">func</span> <span class="token function">MakeSlice</span><span class="token punctuation">(</span>typ Type<span class="token punctuation">,</span> <span class="token builtin">len</span><span class="token punctuation">,</span> <span class="token builtin">cap</span> <span class="token builtin">int</span><span class="token punctuation">)</span> Value <span class="token punctuation">&#123;</span><span class="token keyword">if</span> typ<span class="token punctuation">.</span><span class="token function">Kind</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> Slice <span class="token punctuation">&#123;</span><span class="token function">panic</span><span class="token punctuation">(</span><span class="token string">"reflect.MakeSlice of non-slice type"</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token keyword">if</span> <span class="token builtin">len</span> <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token punctuation">&#123;</span><span class="token function">panic</span><span class="token punctuation">(</span><span class="token string">"reflect.MakeSlice: negative len"</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token keyword">if</span> <span class="token builtin">cap</span> <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token punctuation">&#123;</span><span class="token function">panic</span><span class="token punctuation">(</span><span class="token string">"reflect.MakeSlice: negative cap"</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token keyword">if</span> <span class="token builtin">len</span> <span class="token operator">></span> <span class="token builtin">cap</span> <span class="token punctuation">&#123;</span><span class="token function">panic</span><span class="token punctuation">(</span><span class="token string">"reflect.MakeSlice: len > cap"</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span>s <span class="token operator">:=</span> unsafeheader<span class="token punctuation">.</span>Slice<span class="token punctuation">&#123;</span>Data<span class="token punctuation">:</span> <span class="token function">unsafe_NewArray</span><span class="token punctuation">(</span>typ<span class="token punctuation">.</span><span class="token function">Elem</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token punctuation">(</span><span class="token operator">*</span>rtype<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token builtin">cap</span><span class="token punctuation">)</span><span class="token punctuation">,</span> Len<span class="token punctuation">:</span> <span class="token builtin">len</span><span class="token punctuation">,</span> Cap<span class="token punctuation">:</span> <span class="token builtin">cap</span><span class="token punctuation">&#125;</span><span class="token keyword">return</span> Value<span class="token punctuation">&#123;</span>typ<span class="token punctuation">.</span><span class="token punctuation">(</span><span class="token operator">*</span>rtype<span class="token punctuation">)</span><span class="token punctuation">,</span> unsafe<span class="token punctuation">.</span><span class="token function">Pointer</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>s<span class="token punctuation">)</span><span class="token punctuation">,</span> flagIndir <span class="token operator">|</span> <span class="token function">flag</span><span class="token punctuation">(</span>Slice<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>判断传入的 Slice 类型是否合规；</li><li>判断 len ，cap 是否合规，检查 cap 是否大于 len；</li><li>返回申请成功的 Slice 内存地址和相关属性。</li></ul>]]></content>
      
      
      <categories>
          
          <category> go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>什么是自旋锁</title>
      <link href="/posts/52248.html"/>
      <url>/posts/52248.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>阻塞或唤醒一个Java线程需要操作系统切换CPU状态来完成，这种状态转换需要耗费处理器时间。如果同步代码块中的内容过于简单，状态转换消耗的时间有可能比用户代码执行的时间还要长。</p><h2 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h2><p>在有些场景中，同步资源的锁定时间很短，为了这一小段时间去切换线程，线程挂起和恢复现场的花费可能会让系统得不偿失。</p><p>如果机器有多个CPU核心，能够让两个或以上的线程同时并行执行，我们就可以让后面那个请求锁的线程不放弃CPU的执行时间，看看持有锁的线程是否很快就会释放锁。</p><p>为了让当前线程“稍等一下”，我们需让当前线程进行自旋，如果在自旋完成后前面锁定同步资源的线程已经释放了锁，那么当前线程就可以不必阻塞而是直接获取同步资源，从而避免切换线程的开销。这就是自旋锁。</p><h2 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h2><p><img src="https://img-blog.csdnimg.cn/510dac8af97145fd83c7e4c439df73e9.png" alt="在这里插入图片描述"></p><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><p>自旋锁本身是有缺点的，它不能代替阻塞。自旋等待虽然避免了线程切换的开销，但它要占用处理器时间。</p><ul><li>如果锁被占用的时间很短，自旋等待的效果就会非常好；</li><li>如果锁被占用的时间很长，那么自旋的线程只会白浪费处理器资源。</li></ul><p>所以，自旋等待的时间必须要有一定的限度，如果自旋超过了限定次数没有成功获得锁，就应当挂起线程。（这个次数默认是10次，可以配置）</p><h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><p>自旋锁的实现原理同样也是CAS，AtomicInteger中调用unsafe进行自增操作的源码中的do-while循环就是一个自旋操作，如果修改数值失败则通过循环来执行自旋，直至修改成功。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">int</span> getAndAddInt <span class="token punctuation">(</span><span class="token class-name">Object</span> var1<span class="token punctuation">,</span> <span class="token class-name">Long</span> var2<span class="token punctuation">,</span> <span class="token keyword">int</span> var4<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">int</span> var5<span class="token punctuation">;</span><span class="token keyword">do</span> <span class="token punctuation">&#123;</span>var5 <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getIntVolatile</span><span class="token punctuation">(</span>var1<span class="token punctuation">,</span> var2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span> <span class="token keyword">while</span><span class="token punctuation">(</span> <span class="token operator">!</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">compareAndSwapInt</span><span class="token punctuation">(</span>var1<span class="token punctuation">,</span> var2<span class="token punctuation">,</span> var5<span class="token punctuation">,</span> var5 <span class="token operator">+</span> var4<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> var5<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="自适应自旋"><a href="#自适应自旋" class="headerlink" title="自适应自旋"></a>自适应自旋</h2><p>自适应意味着自旋的时间（次数）不固定，而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定。</p><ul><li>如果在同一个锁对象上，自旋等待刚刚成功获得过锁，并且持有锁的线程正在运行中，那么虚拟机就会认为这次自旋也是很有可能再次成功，进而它将允许自旋等待持续相对更长的时间。</li><li>如果对于某个锁，自旋很少成功获得过，那在以后尝试获取这个锁时将可能省略掉自旋过程，直接阻塞线程，避免浪费处理器资源。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 多线程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 锁 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>悲观锁VS乐观锁</title>
      <link href="/posts/32478.html"/>
      <url>/posts/32478.html</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>Java中有很多锁，每种锁因其特性的不同，在适当的场景下的效率也有很大的差别。今天我们对比一下乐观锁和悲观锁，看看他们有什么不同和相同。</p><p>乐观锁与悲观锁是一种广义上的概念，体现了看待线程同步的不同角度。在Java和数据库中都有比较广泛的应用。</p><h3 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h3><p>对于同一个数据的并发操作，悲观锁认为自己在使用数据的时候一定有别的线程来修改数据，因此在获取数据的时候会先加锁，确保数据不会被别的线程修改。Java中，synchronized关键字和Lock的实现类都是悲观锁。<br><img src="https://img-blog.csdnimg.cn/4a396949d1e8496bb91413d287f2bbdb.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/d9d86aa4f8eb4e9d96ed9b3db6ac5088.png" alt="在这里插入图片描述"></p><h3 id="悲观锁调用方式"><a href="#悲观锁调用方式" class="headerlink" title="悲观锁调用方式"></a>悲观锁调用方式</h3><p>分别是 synchronized 和 ReentrantLock </p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// synchronized</span><span class="token keyword">public</span> <span class="token keyword">synchronized</span> <span class="token keyword">void</span> <span class="token function">testMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token comment">// 操作同步资源</span><span class="token punctuation">&#125;</span><span class="token comment">// ReentrantLock</span><span class="token keyword">private</span> <span class="token class-name">ReentrantLock</span> lock <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReentrantLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 需要保证多个线程使用的是同一个锁</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">modifyPublicResources</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>lock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 操作同步资源</span>lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h3><p>乐观锁认为自己在使用数据时不会有别的线程修改数据，所以不会添加锁，只是在更新数据的时候去判断之前有没有别的线程更新了这个数据。如果这个数据没有被更新，当前线程将自己修改的数据成功写入。如果数据已经被其他线程更新，则根据不同的实现方式执行不同的操作（报错或者重试）</p><p><img src="https://img-blog.csdnimg.cn/0f7de6532433403eb66df416a5399138.png" alt="在这里插入图片描述"></p><h3 id="乐观锁调用方式"><a href="#乐观锁调用方式" class="headerlink" title="乐观锁调用方式"></a>乐观锁调用方式</h3><p>乐观锁在Java中是通过使用无锁编程来实现</p><ul><li>最常采用的是CAS算法；</li><li>Java原子类中的递增操作就通过CAS自旋实现的。<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">private</span> <span class="token class-name">AtomicInteger</span> atomicInteger <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AtomicInteger</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 需要保证多个线程使用的是同一个AtomicInteger</span>atomicInteger<span class="token punctuation">.</span><span class="token function">incrementAndGet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//执行自增</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li></ul><h3 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h3><ul><li>悲观锁适合写操作多的场景，先加锁可以保证写操作时数据正确。</li><li>乐观锁适合读操作多的场景，不加锁的特点能够使其读操作的性能大幅提升。</li></ul><h3 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h3><p>悲观锁基本都是在显式的锁定之后再操作同步资源，而乐观锁则直接去操作同步资源。为什么乐观锁能够做到不锁定同步资源也可以正确的实现线程同步呢？主要就是CAS的思想了。</p><h3 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h3><p>CAS全称 Compare And Swap（比较与交换），是一种无锁算法。在不使用锁（没有线程被阻塞）的情况下实现多线程之间的变量同步。java.util.concurrent包中的原子类就是通过CAS来实现了乐观锁。</p><p>CAS算法涉及到三个操作数：</p><ul><li>需要读写的内存值 V。</li><li>进行比较的值 A。</li><li>要写入的新值 B。<br>当且仅当 V 的值等于 A 时，CAS通过原子方式用新值B来更新V的值（“比较+更新”整体是一个原子操作），否则不会执行任何操作。一般情况下，“更新”是一个不断重试的操作。</li></ul><p>之前提到java.util.concurrent包中的原子类，就是通过CAS来实现了乐观锁，那么我们进入原子类AtomicInteger的源码，看一下AtomicInteger的定义：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AtomicInteger</span> <span class="token keyword">extends</span> <span class="token class-name">Number</span> impLements <span class="token class-name"><span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span>Serializable</span> <span class="token punctuation">&#123;</span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">long</span> serialVersionUID <span class="token operator">=</span> <span class="token number">6214790243416807050L</span><span class="token punctuation">;</span><span class="token comment">// setup to use Unsafe. compareAndSwapInt for updates</span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">Unsafe</span> unsafe <span class="token operator">=</span> <span class="token class-name">Unsafe</span><span class="token punctuation">.</span> <span class="token function">getUnsafe</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">long</span> value0ffset<span class="token punctuation">;</span><span class="token keyword">static</span> <span class="token punctuation">&#123;</span><span class="token keyword">try</span> <span class="token punctuation">&#123;</span>value0ffset <span class="token operator">=</span> unsafe<span class="token punctuation">.</span>objectField0ffset<span class="token punctuation">(</span><span class="token class-name">AtomicInteger</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">getDeclaredField</span><span class="token punctuation">(</span><span class="token string">"value"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> ex<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span>ex<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">private</span> <span class="token keyword">volatile</span> <span class="token keyword">int</span> vaLue<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>各属性的含义：</p><ul><li><strong>unsafe：</strong> 获取并操作内存的数据。</li><li><strong>valueOffset：</strong> 存储value在AtomicInteger中的偏移量。</li><li><strong>value：</strong> 存储AtomicInteger的int值，该属性需要借助volatile关键字保证其在线程间是可见的。</li></ul><p>查看AtomicInteger的自增函数incrementAndGet()的源码时，发现自增函数底层调用的是unsafe.getAndAddInt()。但这个方法并不能看出自增过程</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// AtomicInteger 自增方法</span><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">incrementAndGet</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">return</span> unsafe<span class="token punctuation">.</span><span class="token function">getAndAddInt</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> valueOffset<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// Unsafe.class</span><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">getAndAddInt</span><span class="token punctuation">(</span><span class="token class-name">Object</span> var1<span class="token punctuation">,</span> <span class="token keyword">long</span> var2<span class="token punctuation">,</span> <span class="token keyword">int</span> var4<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">int</span> var5<span class="token punctuation">;</span>  <span class="token keyword">do</span> <span class="token punctuation">&#123;</span>      var5 <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getIntVolatile</span><span class="token punctuation">(</span>var1<span class="token punctuation">,</span> var2<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span> <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">compareAndSwapInt</span><span class="token punctuation">(</span>var1<span class="token punctuation">,</span> var2<span class="token punctuation">,</span> var5<span class="token punctuation">,</span> var5 <span class="token operator">+</span> var4<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> var5<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>getAndAddInt()循环获取给定对象o中的偏移量处的值v，然后判断内存值是否等于v。如果相等则将内存值设置为 v + delta，否则返回false，继续循环进行重试，直到设置成功才能退出循环，并且将旧值返回。</p><p>整个“比较+更新”操作封装在compareAndSwapInt()中，在JNI里是借助于一个CPU指令完成的，属于原子操作，可以保证多个线程都能够看到同一个变量的修改值。</p><p>后续JDK通过CPU的cmpxchg指令，去比较寄存器中的 A 和 内存中的值 V。如果相等，就把要写入的新值 B 存入内存中。如果不相等，就将内存值 V 赋值给寄存器中的值 A。然后通过Java代码中的while循环再次调用cmpxchg指令进行重试，直到设置成功为止。</p><p>OpenJDK8 中的 Unsafe.java 源码</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// Unsafe.java</span><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">getAndAddInt</span><span class="token punctuation">(</span><span class="token class-name">Object</span> o<span class="token punctuation">,</span> <span class="token keyword">long</span> offset<span class="token punctuation">,</span> <span class="token keyword">int</span> delta<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>   <span class="token keyword">int</span> v<span class="token punctuation">;</span>   <span class="token keyword">do</span> <span class="token punctuation">&#123;</span>       v <span class="token operator">=</span> <span class="token function">getIntVolatile</span><span class="token punctuation">(</span>o<span class="token punctuation">,</span> offset<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">&#125;</span> <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">compareAndSwapInt</span><span class="token punctuation">(</span>o<span class="token punctuation">,</span> offset<span class="token punctuation">,</span> v<span class="token punctuation">,</span> v <span class="token operator">+</span> delta<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token keyword">return</span> v<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="CAS问题"><a href="#CAS问题" class="headerlink" title="CAS问题"></a>CAS问题</h3><ul><li>ABA问题。CAS需要在操作值的时候检查内存值是否发生变化，没有发生变化才会更新内存值。<ul><li>但是如果内存值原来是A，后来变成了B，然后又变成了A，那么CAS进行检查时会发现值没有发生变化，但是实际上是有变化的。</li><li>JDK从1.5开始提供了AtomicStampedReference类来解决ABA问题，具体操作封装在compareAndSet()中。compareAndSet()首先检查当前引用和当前标志与预期引用和预期标志是否相等，如果都相等，则以原子方式将引用值和标志的值设置为给定的更新值。</li></ul></li><li>循环时间长开销大。CAS操作如果长时间不成功，会导致其一直自旋，给CPU带来非常大的开销。</li><li>只能保证一个共享变量的原子操作。对一个共享变量执行操作时，CAS能够保证原子操作，但是对多个共享变量操作时，CAS是无法保证操作的原子性的。<ul><li>Java从1.5开始JDK提供了AtomicReference类来保证引用对象之间的原子性，可以把多个变量放在一个对象里来进行CAS操作。</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 多线程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 锁 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JDK锁升级过程</title>
      <link href="/posts/51919.html"/>
      <url>/posts/51919.html</url>
      
        <content type="html"><![CDATA[<h2 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h2><h3 id="Java对象头"><a href="#Java对象头" class="headerlink" title="Java对象头"></a>Java对象头</h3><p>synchronized是悲观锁，在操作同步资源之前需要给同步资源先加锁，这把锁就是存在Java对象头里的，对象头主要包括两部分数据：</p><ul><li>Mark Word（标记字段）</li><li>Klass Pointer（类型指针）。</li></ul><p><strong>Mark Word</strong><br>默认存储对象的HashCode，分代年龄和锁标志位信息。这些信息都是与对象自身定义无关的数据，所以Mark Word被设计成一个非固定的数据结构以便在极小的空间内存存储尽量多的数据。它会根据对象的状态复用自己的存储空间，也就是说在运行期间Mark Word里存储的数据会随着锁标志位的变化而变化。</p><p><strong>Klass Point</strong><br>对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。</p><h3 id="Monitor"><a href="#Monitor" class="headerlink" title="Monitor"></a>Monitor</h3><p>Monitor可以理解为一个同步工具或一种同步机制，通常被描述为一个对象。每一个Java对象就有一把看不见的锁，称为内部锁或者Monitor锁。</p><p>Monitor是线程私有的数据结构，每一个线程都有一个可用monitor record列表，同时还有一个全局的可用列表。每一个被锁住的对象都会和一个monitor关联，同时monitor中有一个Owner字段存放拥有该锁的线程的唯一标识，表示该锁被这个线程占用。</p><h2 id="synchronized如何实现线程同步"><a href="#synchronized如何实现线程同步" class="headerlink" title="synchronized如何实现线程同步"></a>synchronized如何实现线程同步</h2><p>synchronized通过Monitor来实现线程同步，Monitor是依赖于底层的操作系统的Mutex Lock（互斥锁）来实现的线程同步。</p><pre class="line-numbers language-none"><code class="language-none">阻塞或唤醒一个Java线程需要操作系统切换CPU状态来完成，这种状态转换需要耗费处理器时间。如果同步代码块中的内容过于简单，状态转换消耗的时间有可能比用户代码执行的时间还要长<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li>这种方式就是synchronized最初实现同步的方式，这就是JDK 6之前synchronized效率低的原因。</li><li>这种依赖于操作系统Mutex Lock所实现的锁我们称之为“重量级锁”，JDK 6中为了减少获得锁和释放锁带来的性能消耗，引入了“偏向锁”和“轻量级锁”。</li></ul><h3 id="存储内容"><a href="#存储内容" class="headerlink" title="存储内容"></a>存储内容</h3><table><thead><tr><th>锁状态</th><th>存储内容</th><th>存储内容</th></tr></thead><tbody><tr><td>无锁</td><td>对象的hashCode、对象分代年龄、是否是偏向锁（0）</td><td>01</td></tr><tr><td>偏向锁</td><td>偏向线程ID、偏向时间戳、对象分代年龄、是否是偏向锁（1）</td><td>01</td></tr><tr><td>轻量级锁</td><td>指向栈中锁记录的指针</td><td>00</td></tr><tr><td>重量级锁</td><td>指向互斥量（重量级锁）的指针</td><td>10</td></tr></tbody></table><h2 id="锁的四种状态"><a href="#锁的四种状态" class="headerlink" title="锁的四种状态"></a>锁的四种状态</h2><p>锁的状态总共有四种，级别由低到高依次为：</p><ul><li>无锁</li><li>偏向锁</li><li>轻量级锁</li><li>重量级锁</li></ul><p>在JDK 1.6后，JVM为了提高锁的获取与释放效率，对synchronized 进行了优化，引入了 偏向锁 和 轻量级锁 ，从此以后锁的状态就有了四种（无锁、偏向锁、轻量级锁、重量级锁），</p><ul><li>四种状态会随着竞争的情况逐渐升级，这是是不可逆的过程，即不可降级；</li><li>只能升级（从低级别到高级别），不能锁降级（高级别到低级别）；</li><li>意味着偏向锁升级成轻量级锁后不能降级成偏向锁；</li><li>这种锁升级却不能降级的策略，目的是为了提高获得锁和释放锁的效率。</li></ul><p><img src="https://img-blog.csdnimg.cn/1dfc5bfb4f094c1696e611a4e5470630.png" alt="在这里插入图片描述"></p><h2 id="无锁"><a href="#无锁" class="headerlink" title="无锁"></a>无锁</h2><p>无锁没有对资源进行锁定，所有的线程都能访问并修改同一个资源，但同时只有一个线程能修改成功。</p><ul><li>无锁的特点就是修改操作在循环内进行，线程会不断的尝试修改共享资源。</li><li>如果没有冲突就修改成功并退出，否则就会继续循环尝试。</li><li>如果有多个线程修改同一个值，必定会有一个线程能修改成功，而其他修改失败的线程会不断重试直到修改成功。</li><li>典型的应用就是CAS乐观锁，无锁无法全面代替有锁，但无锁在某些场景下的性能是非常高的。</li></ul><h2 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h2><p>偏向锁是指一段同步代码一直被一个线程所访问，那么该线程会自动获取锁，降低获取锁的代价。</p><p>在大多数情况下，锁总是由同一线程多次获得，不存在多线程竞争，所以出现了偏向锁。其目标就是在只有一个线程执行同步代码块时能够提高性能。不需要频繁的切换</p><p>当一个线程访问同步代码块并获取锁时，会在Mark Word里存储锁偏向的线程ID。在线程进入和退出同步块时不再通过CAS操作来加锁和解锁，而是检测Mark Word里是否存储着指向当前线程的偏向锁。引入偏向锁是为了在无多线程竞争的情况下尽量减少不必要的轻量级锁执行路径，因为轻量级锁的获取及释放依赖多次CAS原子指令，而偏向锁只需要在置换ThreadID的时候依赖一次CAS原子指令即可。</p><p>偏向锁只有遇到其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁，线程不会主动释放偏向锁。偏向锁的撤销，需要等待全局安全点（在这个时间点上没有字节码正在执行），它会首先暂停拥有偏向锁的线程，判断锁对象是否处于被锁定状态。撤销偏向锁后恢复到无锁（标志位为“01”）或轻量级锁（标志位为“00”）的状态。</p><h2 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h2><p>是指当锁是偏向锁的时候，被另外的线程所访问，偏向锁就会升级为轻量级锁，其他线程会通过自旋的形式尝试获取锁，不会阻塞，从而提高性能。</p><p>在代码进入同步块的时候，如果同步对象锁状态为无锁状态（锁标志位为“01”状态，是否为偏向锁为“0”），虚拟机首先将在当前线程的栈帧中建立一个名为锁记录（Lock Record）的空间，用于存储锁对象目前的Mark Word的拷贝，然后拷贝对象头中的Mark Word复制到锁记录中。</p><p>拷贝成功后，虚拟机将使用CAS操作尝试将对象的Mark Word更新为指向Lock Record的指针，并将Lock Record里的owner指针指向对象的Mark Word。</p><p>如果这个更新动作成功了，那么这个线程就拥有了该对象的锁，并且对象Mark Word的锁标志位设置为“00”，表示此对象处于轻量级锁定状态。</p><p>如果轻量级锁的更新操作失败了，虚拟机首先会检查对象的Mark Word是否指向当前线程的栈帧，如果是就说明当前线程已经拥有了这个对象的锁，那就可以直接进入同步块继续执行，否则说明多个线程竞争锁。</p><p>若当前只有一个等待线程，则该线程通过自旋进行等待。但是当自旋超过一定的次数，或者一个线程在持有锁，一个在自旋，又有第三个来访时，轻量级锁升级为重量级锁。</p><h2 id="重量级锁"><a href="#重量级锁" class="headerlink" title="重量级锁"></a>重量级锁</h2><p>升级为重量级锁时，锁标志的状态值变为“10”，此时Mark Word中存储的是指向重量级锁的指针，此时等待锁的线程都会进入阻塞状态。</p><h2 id="锁的升级过程"><a href="#锁的升级过程" class="headerlink" title="锁的升级过程"></a>锁的升级过程</h2><p><img src="https://img-blog.csdnimg.cn/5ef0ac3a2a034992839d3694edbc22f5.png" alt="在这里插入图片描述"></p><ul><li>无锁是实现了CAS思想，比如乐观锁</li><li>偏向锁通过对比Mark Word解决加锁问题，避免执行CAS操作。</li><li>轻量级锁是通过用CAS操作和自旋来解决加锁问题，避免线程阻塞和唤醒而影响性能。</li><li>重量级锁是将除了拥有锁的线程以外的线程都阻塞。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 多线程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 锁 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis为什么这么快？</title>
      <link href="/posts/61826.html"/>
      <url>/posts/61826.html</url>
      
        <content type="html"><![CDATA[<p>Redis经常被用作做缓存， 一致性要求不高的场景，还可以当做kv存储使用。</p><p>另外， Redis还提供了消息订阅、事务、索引等特性。<br>我们还可以利用集群特性搭建分布式存储服务，实现非强一致性的分布式锁服务。</p><p>Redis用到上述场景， 都有一个共同的优势， 就是处理速度快（高性能）。</p><p>那Redis为什么快呢？</p><h2 id="基于内存实现"><a href="#基于内存实现" class="headerlink" title="基于内存实现"></a>基于内存实现</h2><p>内存读写速度是比磁盘读写快很多倍的。</p><ul><li>Redis是基于内存存储实现的数据库，相对于数据存在磁盘的数据库，就省去磁盘磁盘I/O的消耗。</li><li>MySQL等磁盘数据库，需要建立索引来加快查询效率，而Redis数据存放在内存，直接操作内存，所以就很快。</li></ul><p><img src="https://img-blog.csdnimg.cn/db1e5f90f2124eadbd4f959d80121dd3.png" alt="在这里插入图片描述"></p><h2 id="高效的数据结构"><a href="#高效的数据结构" class="headerlink" title="高效的数据结构"></a>高效的数据结构</h2><p><img src="https://img-blog.csdnimg.cn/61741fdcf7a44569953e1a42c7b5f70a.png" alt="在这里插入图片描述"></p><h4 id="动态字符串"><a href="#动态字符串" class="headerlink" title="动态字符串"></a>动态字符串</h4><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">sdshdr</span> <span class="token punctuation">&#123;</span> <span class="token comment">//SDS简单动态字符串</span>    <span class="token keyword">int</span> len<span class="token punctuation">;</span>    <span class="token comment">//记录buf中已使用的空间</span>    <span class="token keyword">int</span> free<span class="token punctuation">;</span>   <span class="token comment">// buf中空闲空间长度</span>    <span class="token keyword">char</span> buf<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">//存储的实际内容</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="字符串长度存储"><a href="#字符串长度存储" class="headerlink" title="字符串长度存储"></a>字符串长度存储</h4><ul><li><p>在C语言中，要获取一个字符串的长度，需要从头开始遍历，复杂度为O（n）;</p></li><li><p>在Redis中，使用一个len字段记录当前字符串的长度，直接获取即可，时间复杂度为O(1)。</p><h4 id="减少内存重新分配的次数"><a href="#减少内存重新分配的次数" class="headerlink" title="减少内存重新分配的次数"></a>减少内存重新分配的次数</h4></li><li><p>在C语言中，修改一个字符串，需要重新分配内存，修改越频繁，内存分配就越频繁，而分配内存是会消耗性能的。</p></li><li><p>在Redis中，SDS提供了两种优化策略：空间预分配和惰性空间释放。</p><h4 id="空间预分配"><a href="#空间预分配" class="headerlink" title="空间预分配"></a>空间预分配</h4><p>当SDS简单动态字符串修改和空间扩充时，除了分配必需的内存空间，还会额外分配未使用的空间。</p></li><li><p>SDS修改后，len的长度小于1M，那么将额外分配与len相同长度的未使用空间。比如len=100，重新分配后，buf 的实际长度会变为100(已使用空间)+100(额外空间)+1(空字符)=201。</p></li><li><p>SDS修改后, len长度大于1M，那么程序将分配1M的未使用空间。</p><h4 id="惰性空间释放"><a href="#惰性空间释放" class="headerlink" title="惰性空间释放"></a>惰性空间释放</h4></li></ul><p>当SDS缩短时，不是回收多余的内存空间，而是用free记录下多余的空间。后续再有修改操作，直接使用free中的空间，减少内存分配。</p><h4 id="哈希"><a href="#哈希" class="headerlink" title="哈希"></a>哈希</h4><p>Redis 作为一个KV的内存数据库，它使用用一张全局的哈希表来保存所有的键值对。</p><ul><li>这张哈希表，有多个哈希桶组成，哈希桶中的entry元素保存了<em>key和</em>value指针，</li><li>其中<em>key指向了实际的键，</em>value指向了实际的值。<h4 id="跳跃表"><a href="#跳跃表" class="headerlink" title="跳跃表"></a>跳跃表</h4><img src="https://img-blog.csdnimg.cn/41f2f42656bc493e82dcd4a589835823.png" alt="在这里插入图片描述"></li></ul><p>跳跃表是Redis特有的数据结构，它其实就是在链表的基础上，增加多级索引，以提高查找效率。</p><ul><li>每一层都有一条有序的链表，最底层的链表包含了所有的元素；</li><li>跳跃表支持平均 O（logN）,最坏 O（N）复杂度的节点查找；</li><li>还可以通过顺序性操作批量处理节点。</li></ul><h4 id="压缩列表ziplist"><a href="#压缩列表ziplist" class="headerlink" title="压缩列表ziplist"></a>压缩列表ziplist</h4><p>压缩列表ziplist是列表键和字典键的的底层实现之一。它是由一系列特殊编码的内存块构成的列表， 一个ziplist可以包含多个entry， 每个entry可以保存一个长度受限的字符数组或者整数，<br><img src="https://img-blog.csdnimg.cn/27e40c9a123c442daa081a2db3d4ae69.png" alt="在这里插入图片描述"></p><ul><li>zlbytes ：记录整个压缩列表占用的内存字节数</li><li>zltail: 尾节点至起始节点的偏移量</li><li>zllen : 记录整个压缩列表包含的节点数量</li><li>entryX: 压缩列表包含的各个节点</li><li>zlend : 特殊值，用于标记压缩列表末端</li></ul><h2 id="合理的数据编码"><a href="#合理的数据编码" class="headerlink" title="合理的数据编码"></a>合理的数据编码</h2><p>Redis支持多种数据基本类型，每种基本类型对应不同的数据结构，每种数据结构对应不一样的编码。为了提高性能，Redis使用数据结构最适合的编码搭配。</p><p>Redis是使用对象（redisObject）来表示数据库中的键值，当我们在 Redis 中创建一个键值对时，内存中创建两个对象</p><ul><li>一个对象是用做键值对的键对象</li><li>另一个是键值对的值对象。</li></ul><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">redisObject</span><span class="token punctuation">&#123;</span>    <span class="token comment">//类型</span>   <span class="token keyword">unsigned</span> type<span class="token operator">:</span><span class="token number">4</span><span class="token punctuation">;</span>   <span class="token comment">//编码</span>   <span class="token keyword">unsigned</span> encoding<span class="token operator">:</span><span class="token number">4</span><span class="token punctuation">;</span>   <span class="token comment">//指向底层数据结构的指针</span>   <span class="token keyword">void</span> <span class="token operator">*</span>ptr<span class="token punctuation">;</span>    <span class="token comment">//其他</span> <span class="token punctuation">&#125;</span>robj<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>redisObject中，type 对应的是对象类型，包含</p><ul><li>String</li><li>List</li><li>Hash</li><li>Set</li><li>zset</li></ul><p>encoding 对应的是编码</p><ul><li>String：如果存储数字的话，是用int类型的编码;如果存储非数字，小于等于39字节的字符串，是embstr；大于39个字节，则是raw编码。</li><li>List：如果列表的元素个数小于512个，列表每个元素的值都小于64字节（默认），使用ziplist编码，否则使用linkedlist编码</li><li>Hash：哈希类型元素个数小于512个，所有值小于64字节的话，使用ziplist编码,否则使用hashtable编码。</li><li>Set：如果集合中的元素都是整数且元素个数小于512个，使用intset编码，否则使用hashtable编码。</li><li>Zset：当有序集合的元素个数小于128个，每个元素的值小于64字节时，使用ziplist编码，否则使用skiplist（跳跃表）编码</li></ul><h2 id="合理的线程模型"><a href="#合理的线程模型" class="headerlink" title="合理的线程模型"></a>合理的线程模型</h2><h4 id="单线程模型"><a href="#单线程模型" class="headerlink" title="单线程模型"></a>单线程模型</h4><p>Redis是单线程的，是指Redis的网络IO和键值对读写是由一个线程来完成的。<br>但Redis的其他功能，比如持久化、异步删除、集群数据同步等等，实际是由额外的线程执行的。</p><ul><li>Redis的单线程模型，避免了CPU不必要的上下文切换和竞争锁的消耗。</li><li>因为是单线程，如果某个命令执行过长（如hgetall命令），会造成阻塞。</li><li>Redis是面向快速执行场景的内存数据库</li></ul><h4 id="I-O-多路复用"><a href="#I-O-多路复用" class="headerlink" title="I/O 多路复用"></a>I/O 多路复用</h4><p>IO多路复其实就是一种同步IO模型，它实现了一个线程可以监视多个文件句柄；</p><ul><li>一旦某个文件句柄就绪，就能够通知应用程序进行相应的读写操作；</li><li>没有文件句柄就绪时,就会阻塞应用程序，交出cpu。</li></ul><p>多路I/O复用技术可以让单个线程高效的处理多个连接请求，而Redis使用用epoll作为I/O多路复用技术的实现。并且Redis自身的事件处理模型将epoll中的连接、读写、关闭都转换为事件，不在网络I/O上浪费过多的时间。<br><img src="https://img-blog.csdnimg.cn/2452094bab174e888b76415e9bc4bac3.png" alt="在这里插入图片描述"></p><h2 id="虚拟内存机制"><a href="#虚拟内存机制" class="headerlink" title="虚拟内存机制"></a>虚拟内存机制</h2><p>Redis构建了自己的VM机制 ，不会调用系统函数处理，会浪费一定的时间去移动和请求。</p><h4 id="虚拟内存机制-1"><a href="#虚拟内存机制-1" class="headerlink" title="虚拟内存机制"></a>虚拟内存机制</h4><ul><li>虚拟内存机制就是暂时把不经常访问的数据(冷数据)从内存交换到磁盘中，从而腾出宝贵的内存空间用于其它需要访问的数据(热数据)。</li><li>通过VM功能可以实现冷热数据分离，使热数据仍在内存中、冷数据保存到磁盘。这样就可以避免因为内存不足而造成访问速度下降的问题。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 缓存 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis分布式锁如何自动续期</title>
      <link href="/posts/52824.html"/>
      <url>/posts/52824.html</url>
      
        <content type="html"><![CDATA[<h2 id="Redis-实现分布式锁"><a href="#Redis-实现分布式锁" class="headerlink" title="Redis 实现分布式锁"></a>Redis 实现分布式锁</h2><ul><li>指定一个 key 作为锁标记，存入 Redis 中，指定一个 唯一的用户标识作为 value。</li><li>当 key 不存在时才能设置值，确保同一时间只有一个客户端进程获得锁，满足互斥性特性。</li><li>设置一个过期时间，防止因系统异常导致没能删除这个 key，满足防死锁特性。</li><li>当处理完业务之后需要清除这个 key 来释放锁，清除 key 时需要校验 value 值，需要满足只有加锁的人才能释放锁 。</li></ul><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>如果这个锁的过期时间是30秒，但是业务运行超过了30秒，比如40秒，当业务运行到30秒的时候，锁过期了，其他客户端拿到了这个锁，怎么办</p><p>我们可以设置一个合理的过期时间，让业务能够在这个时间内完成业务逻辑，但LockTime的设置原本就很不容易。</p><ul><li>LockTime设置过小，锁自动超时的概率就会增加，锁异常失效的概率也就会增加；</li><li>LockTime设置过大，万一服务出现异常无法正常释放锁，那么出现这种异常锁的时间也就越长。</li></ul><p>我们只能通过经验去配置，一个可以接受的值，基本上是这个服务历史上的平均耗时再增加一定的buff。总体来说，设置一个合理的过期时间并不容易</p><p>我们也可以不设置过期时间，让业务运行结束后解锁，但是如果客户端出现了异常结束了或宕机了，那么这个锁就无法解锁，变成死锁；</p><h2 id="自动续期"><a href="#自动续期" class="headerlink" title="自动续期"></a>自动续期</h2><p>我们可以先给锁设置一个LockTime，然后启动一个守护线程，让守护线程在一段时间后，重新去设置这个锁的LockTime。</p><p>看起来很简单，但实现起来并不容易</p><ol><li>和释放锁的情况一样，我们需要先判断持有锁客户端是否有变化。否则会造成无论谁持有锁，守护线程都会去重新设置锁的LockTime。</li><li>守护线程要在合理的时间再去重新设置锁的LockTime，否则会造成资源的浪费。不能动不动就去续。</li><li>如果持有锁的线程已经处理完业务了，那么守护线程也应该被销毁。不能业务运行结束了，守护者还在那里继续运行，浪费资源。</li></ol><h2 id="看门狗"><a href="#看门狗" class="headerlink" title="看门狗"></a>看门狗</h2><p>Redisson的看门狗机制就是这种机制实现自动续期的<br><img src="https://img-blog.csdnimg.cn/4d78502535604ab18ec0d26bdbb0bfb6.png" alt="在这里插入图片描述"></p><h2 id="Redissson-tryLock"><a href="#Redissson-tryLock" class="headerlink" title="Redissson tryLock"></a>Redissson tryLock</h2><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">tryLock</span><span class="token punctuation">(</span><span class="token keyword">long</span> waitTime<span class="token punctuation">,</span> <span class="token keyword">long</span> leaseTime<span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span> unit<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">long</span> time <span class="token operator">=</span> unit<span class="token punctuation">.</span><span class="token function">toMillis</span><span class="token punctuation">(</span>waitTime<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">long</span> current <span class="token operator">=</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">long</span> threadId <span class="token operator">=</span> <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 1.尝试获取锁</span>        <span class="token class-name">Long</span> ttl <span class="token operator">=</span> <span class="token function">tryAcquire</span><span class="token punctuation">(</span>leaseTime<span class="token punctuation">,</span> unit<span class="token punctuation">,</span> threadId<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// lock acquired</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>ttl <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">// 申请锁的耗时如果大于等于最大等待时间，则申请锁失败.</span>        time <span class="token operator">-=</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> current<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>time <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token function">acquireFailed</span><span class="token punctuation">(</span>threadId<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        current <span class="token operator">=</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">/**         * 2.订阅锁释放事件，并通过 await 方法阻塞等待锁释放，有效的解决了无效的锁申请浪费资源的问题：         * 基于信息量，当锁被其它资源占用时，当前线程通过 Redis 的 channel 订阅锁的释放事件，一旦锁释放会发消息通知待等待的线程进行竞争.         *         * 当 this.await 返回 false，说明等待时间已经超出获取锁最大等待时间，取消订阅并返回获取锁失败.         * 当 this.await 返回 true，进入循环尝试获取锁.         */</span>        <span class="token class-name">RFuture</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">RedissonLockEntry</span><span class="token punctuation">></span></span> subscribeFuture <span class="token operator">=</span> <span class="token function">subscribe</span><span class="token punctuation">(</span>threadId<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// await 方法内部是用 CountDownLatch 来实现阻塞，获取 subscribe 异步执行的结果（应用了 Netty 的 Future）</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>subscribeFuture<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span>time<span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span>MILLISECONDS<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>subscribeFuture<span class="token punctuation">.</span><span class="token function">cancel</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                subscribeFuture<span class="token punctuation">.</span><span class="token function">onComplete</span><span class="token punctuation">(</span><span class="token punctuation">(</span>res<span class="token punctuation">,</span> e<span class="token punctuation">)</span> <span class="token operator">-></span> <span class="token punctuation">&#123;</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>e <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                        <span class="token function">unsubscribe</span><span class="token punctuation">(</span>subscribeFuture<span class="token punctuation">,</span> threadId<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">&#125;</span>                <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token function">acquireFailed</span><span class="token punctuation">(</span>threadId<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// 计算获取锁的总耗时，如果大于等于最大等待时间，则获取锁失败.</span>            time <span class="token operator">-=</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> current<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>time <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token function">acquireFailed</span><span class="token punctuation">(</span>threadId<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>              <span class="token punctuation">&#125;</span>            <span class="token comment">/**             * 3.收到锁释放的信号后，在最大等待时间之内，循环一次接着一次的尝试获取锁             * 获取锁成功，则立马返回 true，             * 若在最大等待时间之内还没获取到锁，则认为获取锁失败，返回 false 结束循环             */</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">long</span> currentTime <span class="token operator">=</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment">// 再次尝试获取锁</span>                ttl <span class="token operator">=</span> <span class="token function">tryAcquire</span><span class="token punctuation">(</span>leaseTime<span class="token punctuation">,</span> unit<span class="token punctuation">,</span> threadId<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment">// lock acquired</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>ttl <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>                <span class="token comment">// 超过最大等待时间则返回 false 结束循环，获取锁失败</span>                time <span class="token operator">-=</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> currentTime<span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>time <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    <span class="token function">acquireFailed</span><span class="token punctuation">(</span>threadId<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>                <span class="token comment">/**                 * 6.阻塞等待锁（通过信号量(共享锁)阻塞,等待解锁消息）：                 */</span>                currentTime <span class="token operator">=</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>ttl <span class="token operator">>=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> ttl <span class="token operator">&lt;</span> time<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    <span class="token comment">//如果剩余时间(ttl)小于wait time ,就在 ttl 时间内，从Entry的信号量获取一个许可(除非被中断或者一直没有可用的许可)。</span>                    <span class="token function">getEntry</span><span class="token punctuation">(</span>threadId<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getLatch</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">tryAcquire</span><span class="token punctuation">(</span>ttl<span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span>MILLISECONDS<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>                    <span class="token comment">//则就在wait time 时间范围内等待可以通过信号量</span>                    <span class="token function">getEntry</span><span class="token punctuation">(</span>threadId<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getLatch</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">tryAcquire</span><span class="token punctuation">(</span>time<span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span>MILLISECONDS<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>                <span class="token comment">// 更新剩余的等待时间(最大等待时间-已经消耗的阻塞时间)</span>                time <span class="token operator">-=</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> currentTime<span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>time <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    <span class="token function">acquireFailed</span><span class="token punctuation">(</span>threadId<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">finally</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// 7.无论是否获得锁,都要取消订阅解锁消息</span>            <span class="token function">unsubscribe</span><span class="token punctuation">(</span>subscribeFuture<span class="token punctuation">,</span> threadId<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token function">tryLockAsync</span><span class="token punctuation">(</span>waitTime<span class="token punctuation">,</span> leaseTime<span class="token punctuation">,</span> unit<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol><li>尝试获取锁，返回 null 则说明加锁成功，返回一个数值，则说明已经存在该锁，ttl 为锁的剩余存活时间。</li><li>如果此时客户端 2 进程获取锁失败，那么使用客户端 2 的线程 id（其实本质上就是进程 id）通过 Redis 的 channel 订阅锁释放的事件。如果等待的过程中一直未等到锁的释放事件通知，当超过最大等待时间则获取锁失败，返回 false，也就是第 39 行代码。如果等到了锁的释放事件的通知，则开始进入一个不断重试获取锁的循环。</li><li>循环中每次都先试着获取锁，并得到已存在的锁的剩余存活时间。如果在重试中拿到了锁，则直接返回。如果锁当前还是被占用的，那么等待释放锁的消息，具体实现使用了信号量 Semaphore 来阻塞线程，当锁释放并发布释放锁的消息后，信号量的 release() 方法会被调用，此时被信号量阻塞的等待队列中的一个线程就可以继续尝试获取锁了。</li><li>当锁正在被占用时，等待获取锁的进程并不是通过一个 while(true) 死循环去获取锁，而是利用了 Redis 的发布订阅机制,通过 await 方法阻塞等待锁的进程，有效的解决了无效的锁申请浪费资源的问题。</li></ol><h2 id="看门狗如何自动续期"><a href="#看门狗如何自动续期" class="headerlink" title="看门狗如何自动续期"></a>看门狗如何自动续期</h2><p>Redisson看门狗机制， 只要客户端加锁成功，就会启动一个 Watch Dog。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">private</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span> <span class="token class-name">RFuture</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Long</span><span class="token punctuation">></span></span> <span class="token function">tryAcquireAsync</span><span class="token punctuation">(</span><span class="token keyword">long</span> leaseTime<span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span> unit<span class="token punctuation">,</span> <span class="token keyword">long</span> threadId<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>leaseTime <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token function">tryLockInnerAsync</span><span class="token punctuation">(</span>leaseTime<span class="token punctuation">,</span> unit<span class="token punctuation">,</span> threadId<span class="token punctuation">,</span> <span class="token class-name">RedisCommands</span><span class="token punctuation">.</span>EVAL_LONG<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token class-name">RFuture</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Long</span><span class="token punctuation">></span></span> ttlRemainingFuture <span class="token operator">=</span> <span class="token function">tryLockInnerAsync</span><span class="token punctuation">(</span>commandExecutor<span class="token punctuation">.</span><span class="token function">getConnectionManager</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getCfg</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getLockWatchdogTimeout</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span>MILLISECONDS<span class="token punctuation">,</span> threadId<span class="token punctuation">,</span> <span class="token class-name">RedisCommands</span><span class="token punctuation">.</span>EVAL_LONG<span class="token punctuation">)</span><span class="token punctuation">;</span>    ttlRemainingFuture<span class="token punctuation">.</span><span class="token function">onComplete</span><span class="token punctuation">(</span><span class="token punctuation">(</span>ttlRemaining<span class="token punctuation">,</span> e<span class="token punctuation">)</span> <span class="token operator">-></span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>e <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">// lock acquired</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>ttlRemaining <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token function">scheduleExpirationRenewal</span><span class="token punctuation">(</span>threadId<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> ttlRemainingFuture<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol><li>leaseTime 必须是 -1 才会开启 Watch Dog 机制，如果需要开启 Watch Dog 机制就必须使用默认的加锁时间为 30s。</li><li>如果你自己自定义时间，超过这个时间，锁就会自定释放，并不会自动续期。</li></ol><h2 id="续期原理"><a href="#续期原理" class="headerlink" title="续期原理"></a>续期原理</h2><p>续期原理其实就是用lua脚本，将锁的时间重置为30s</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">scheduleExpirationRenewal</span><span class="token punctuation">(</span><span class="token keyword">long</span> threadId<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">ExpirationEntry</span> entry <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ExpirationEntry</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">ExpirationEntry</span> oldEntry <span class="token operator">=</span> EXPIRATION_RENEWAL_MAP<span class="token punctuation">.</span><span class="token function">putIfAbsent</span><span class="token punctuation">(</span><span class="token function">getEntryName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> entry<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>oldEntry <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        oldEntry<span class="token punctuation">.</span><span class="token function">addThreadId</span><span class="token punctuation">(</span>threadId<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>        entry<span class="token punctuation">.</span><span class="token function">addThreadId</span><span class="token punctuation">(</span>threadId<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">renewExpiration</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">protected</span> <span class="token class-name">RFuture</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Boolean</span><span class="token punctuation">></span></span> <span class="token function">renewExpirationAsync</span><span class="token punctuation">(</span><span class="token keyword">long</span> threadId<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> commandExecutor<span class="token punctuation">.</span><span class="token function">evalWriteAsync</span><span class="token punctuation">(</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token class-name">LongCodec</span><span class="token punctuation">.</span>INSTANCE<span class="token punctuation">,</span> <span class="token class-name">RedisCommands</span><span class="token punctuation">.</span>EVAL_BOOLEAN<span class="token punctuation">,</span>            <span class="token string">"if (redis.call('hexists', KEYS[1], ARGV[2]) == 1) then "</span> <span class="token operator">+</span>                <span class="token string">"redis.call('pexpire', KEYS[1], ARGV[1]); "</span> <span class="token operator">+</span>                <span class="token string">"return 1; "</span> <span class="token operator">+</span>            <span class="token string">"end; "</span> <span class="token operator">+</span>            <span class="token string">"return 0;"</span><span class="token punctuation">,</span>        <span class="token class-name">Collections</span><span class="token punctuation">.</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Object</span><span class="token punctuation">></span></span><span class="token function">singletonList</span><span class="token punctuation">(</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>        internalLockLeaseTime<span class="token punctuation">,</span> <span class="token function">getLockName</span><span class="token punctuation">(</span>threadId<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol><li><p>Watch Dog 机制其实就是一个后台定时任务线程，获取锁成功之后，会将持有锁的线程放入到一个 RedissonLock.EXPIRATION_RENEWAL_MAP里面，然后每隔 10 秒 （internalLockLeaseTime / 3） 检查一下，如果客户端 还持有锁 key（判断客户端是否还持有 key，其实就是遍历 EXPIRATION_RENEWAL_MAP 里面线程 id 然后根据线程 id 去 Redis 中查，如果存在就会延长 key 的时间），那么就会不断的延长锁 key 的生存时间。</p></li><li><p>如果服务宕机了，Watch Dog 机制线程也就没有了，此时就不会延长 key 的过期时间，到了 30s 之后就会自动过期了，其他线程就可以获取到锁。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 缓存 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式锁 </tag>
            
            <tag> 自动续期 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Boot是如何实现自动装配的</title>
      <link href="/posts/1513.html"/>
      <url>/posts/1513.html</url>
      
        <content type="html"><![CDATA[<h2 id="什么是自动装配？"><a href="#什么是自动装配？" class="headerlink" title="什么是自动装配？"></a>什么是自动装配？</h2><p>自动装配就是通过注解或者一些简单的配置就能在 Spring Boot 的帮助下实现某块功能。</p><p>Spring Boot 定义了一套接口规范，这套规范规定：SpringBoot 在启动时会扫描外部引用 jar 包中的META-INF/spring.factories文件，将文件中配置的类型信息加载到 Spring 容器，并执行类中定义的各种操作。</p><p>对于外部 jar 来说，只需要按照 Spring Boot 定义的标准，就能将自己的功能装置进 Spring Boot。</p><p>在Spring Boot 中，如果我们需要引入第三方依赖，我们直接引入一个 starter 即可。比如想要在项目中使用 redis 的话，直接在项目中引入对应的 starter 即可。</p><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-starter-data-redis<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>引入 starter 之后，通过少量注解和一些简单的配置就能使用第三方组件提供的功能了。</p><h2 id="如何实现自动装配"><a href="#如何实现自动装配" class="headerlink" title="如何实现自动装配"></a>如何实现自动装配</h2><p> SpringBoot 的核心注解是 SpringBootApplication。<br>@SpringBootApplication注解包含</p><ul><li>@Configuration：允许在上下文中注册额外的 bean 或导入其他配置类</li><li>@EnableAutoConfiguration：启用 SpringBoot 的自动配置机制</li><li>@ComponentScan：扫描被@Component (@Service,@Controller)注解的 bean，注解默认会扫描启动类所在的包下所有的类 ，可以自定义不扫描某些 bean</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Target</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span><span class="token class-name">ElementType</span><span class="token punctuation">.</span>TYPE<span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token annotation punctuation">@Retention</span><span class="token punctuation">(</span><span class="token class-name">RetentionPolicy</span><span class="token punctuation">.</span>RUNTIME<span class="token punctuation">)</span><span class="token annotation punctuation">@Documented</span><span class="token annotation punctuation">@Inherited</span><span class="token annotation punctuation">@SpringBootConfiguration</span><span class="token annotation punctuation">@ComponentScan</span><span class="token annotation punctuation">@EnableAutoConfiguration</span><span class="token keyword">public</span> <span class="token annotation punctuation">@interface</span> <span class="token class-name">SpringBootApplication</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token annotation punctuation">@Target</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span><span class="token class-name">ElementType</span><span class="token punctuation">.</span>TYPE<span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token annotation punctuation">@Retention</span><span class="token punctuation">(</span><span class="token class-name">RetentionPolicy</span><span class="token punctuation">.</span>RUNTIME<span class="token punctuation">)</span><span class="token annotation punctuation">@Documented</span><span class="token annotation punctuation">@Configuration</span> <span class="token keyword">public</span> <span class="token annotation punctuation">@interface</span> <span class="token class-name">SpringBootConfiguration</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>从源码中可以知道，最关键的注解是</p><ul><li><p>@Import(EnableAutoConfigurationImportSelector.class)，借助EnableAutoConfigurationImportSelector，@EnableAutoConfiguration可以帮助Spring Boot应用将所有符合条件的@Configuration配置都加载到当前SpringBoot创建并使用的IoC容器。</p></li><li><p>同时借助于Spring框架原有的一个工具类：SpringFactoriesLoader，@EnableAutoConfiguration就可以实现智能的自动配置。</p></li><li><p>SpringFactoriesLoader中加载配置,SpringFactoriesLoader属于Spring框架私有的一种扩展方案，其主要功能就是从指定的配置文件META-INF/spring.factories加载配置,</p></li><li><p>即根据@EnableAutoConfiguration的完整类名org.springframework.boot.autoconfigure.EnableAutoConfiguration作为查找的Key,获取对应的一组@Configuration类</p></li></ul><p>@EnableAutoConfiguration作用就是从classpath中搜寻所有的META-INF/spring.factories配置文件，并将其中org.springframework.boot.autoconfigure.EnableutoConfiguration对应的配置项通过反射（Java Refletion）实例化为对应的标注了@Configuration的JavaConfig形式的IoC容器配置类，然后汇总为一个并加载到IoC容器。</p><p>这些功能配置类要生效的话，会去classpath中找是否有该类的依赖类（也就是pom.xml必须有对应功能的jar包才行）并且配置类里面注入了默认属性值类，功能类可以引用并赋默认值。</p><p>生成功能类的原则是自定义优先，没有自定义时才会使用自动装配类。</p><p>生效需要的条件：</p><ul><li>spring.factories里面有这个类的配置类（一个配置类可以创建多个围绕该功能的依赖类）</li><li>pom.xml里面需要有对应的jar包</li></ul><h2 id="案例-Redis"><a href="#案例-Redis" class="headerlink" title="案例 - Redis"></a>案例 - Redis</h2><p>1、从spring-boot-autoconfigure.jar/META-INF/spring.factories中获取redis的相关配置类全限定名（有120多个的配置类）RedisAutoConfiguration，一般一个功能配置类围绕该功能，负责管理创建多个相关的功能类，比如RedisAutoConfiguration负责：JedisConnectionFactory、RedisTemplate、StringRedisTemplate这3个功能类的创建</p><p><img src="https://img-blog.csdnimg.cn/38b0ee1058104232a1aaa885ec5bd9f3.png" alt="在这里插入图片描述"></p><p>2、RedisAutoConfiguration配置类生效的一个条件是在classpath路径下有RedisOperations类存在，因此springboot的自动装配机制会会去classpath下去查找对应的class文件。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Configuration</span><span class="token annotation punctuation">@ConditionalOnClass</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span><span class="token class-name">RedisOperations</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token annotation punctuation">@EnableConfigurationProperties</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span><span class="token class-name">RedisProperties</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token annotation punctuation">@Import</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span><span class="token class-name">LettuceConnectionConfiguration</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> <span class="token class-name">JedisConnectionConfiguration</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">RedisAutoConfiguration</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>3、pom.xml中有对应的jar包,就能匹配到对应依赖class，</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token generics"><span class="token punctuation">&lt;</span>dependency<span class="token punctuation">></span></span><span class="token generics"><span class="token punctuation">&lt;</span>groupId<span class="token punctuation">></span></span>org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>boot<span class="token operator">&lt;</span><span class="token operator">/</span>groupId<span class="token operator">></span><span class="token generics"><span class="token punctuation">&lt;</span>artifactId<span class="token punctuation">></span></span>spring<span class="token operator">-</span>boot<span class="token operator">-</span>starter<span class="token operator">-</span>data<span class="token operator">-</span>redis<span class="token operator">&lt;</span><span class="token operator">/</span>artifactId<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>dependency<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>4、匹配成功，这个功能配置类才会生效，同时会注入默认的属性配置类@EnableConfigurationProperties(RedisProperties.class)<br><img src="https://img-blog.csdnimg.cn/4c06c2d7589f4efea3bb2d4e6fb3e2d0.png" alt="在这里插入图片描述"></p><p>5、Redis功能配置里面会根据条件生成最终的<br>JedisConnectionFactory、RedisTemplate,并提供了默认的配置形式<br>@ConditionalOnMissingBean(name = “redisTemplate”)</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Configuration</span><span class="token annotation punctuation">@ConditionalOnClass</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span><span class="token class-name">RedisOperations</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token annotation punctuation">@EnableConfigurationProperties</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span><span class="token class-name">RedisProperties</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token annotation punctuation">@Import</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span><span class="token class-name">LettuceConnectionConfiguration</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> <span class="token class-name">JedisConnectionConfiguration</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">RedisAutoConfiguration</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token class-name">RedisAutoConfiguration</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token punctuation">&#125;</span>    <span class="token annotation punctuation">@Bean</span>    <span class="token annotation punctuation">@ConditionalOnMissingBean</span><span class="token punctuation">(</span>        name <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token string">"redisTemplate"</span><span class="token punctuation">&#125;</span>    <span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token class-name">RedisTemplate</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Object</span><span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">></span></span> <span class="token function">redisTemplate</span><span class="token punctuation">(</span><span class="token class-name">RedisConnectionFactory</span> redisConnectionFactory<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">UnknownHostException</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">RedisTemplate</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Object</span><span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">></span></span> template <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">RedisTemplate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        template<span class="token punctuation">.</span><span class="token function">setConnectionFactory</span><span class="token punctuation">(</span>redisConnectionFactory<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> template<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token annotation punctuation">@Bean</span>    <span class="token annotation punctuation">@ConditionalOnMissingBean</span>    <span class="token keyword">public</span> <span class="token class-name">StringRedisTemplate</span> <span class="token function">stringRedisTemplate</span><span class="token punctuation">(</span><span class="token class-name">RedisConnectionFactory</span> redisConnectionFactory<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">UnknownHostException</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">StringRedisTemplate</span> template <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringRedisTemplate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        template<span class="token punctuation">.</span><span class="token function">setConnectionFactory</span><span class="token punctuation">(</span>redisConnectionFactory<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> template<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>6、最终创建好的默认装配类，会通过功能配置类里面的 @Bean注解，注入到IOC当中</p><p>7、用户使用，当用户在配置文件中自定义时候就会覆盖默认的配置@ConditionalOnMissingBean(name = “redisTemplate”)</p>]]></content>
      
      
      <categories>
          
          <category> 框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring Boot </tag>
            
            <tag> 自动装配 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一致性哈希算法</title>
      <link href="/posts/27281.html"/>
      <url>/posts/27281.html</url>
      
        <content type="html"><![CDATA[<h2 id="什么是一致性哈希算法"><a href="#什么是一致性哈希算法" class="headerlink" title="什么是一致性哈希算法"></a>什么是一致性哈希算法</h2><p>一致性哈希算法在1997年由麻省理工学院提出的一种分布式哈希（DHT）实现算法，设计目标是为了解决因特网中的热点(Hot spot)问题，初衷和CARP十分类似。</p><p>一致性哈希修正了CARP使用的简 单哈希算法带来的问题，使得分布式哈希（DHT）可以在P2P环境中真正得到应用。</p><p>一致性hash算法提出了在动态变化的Cache环境中，判定哈希算法好坏的四个定义：</p><ul><li>平衡性(Balance)</li><li>单调性(Monotonicity)</li><li>分散性(Spread)</li><li>负载(Load)</li></ul><h2 id="实现机制"><a href="#实现机制" class="headerlink" title="实现机制"></a>实现机制</h2><p>一致哈希是一种特殊的哈希算法。在使用一致哈希算法后，哈希表槽位数（大小）的改变平均只需要对 K/n 个关键字重新映射，其中K是关键字的数量， n是槽位数量。</p><p>然而在传统的哈希表中，添加或删除一个槽位的几乎需要对所有关键字进行重新映射。</p><p>一致性哈希是将整个哈希值空间组织成一个虚拟的圆环，如假设哈希函数H的值空间为0-2^32-1（哈希值是32位无符号整形），整个哈希空间环如下：<br><img src="https://img-blog.csdnimg.cn/7958afb12f8d4876987917da477e3ae7.png" alt="在这里插入图片描述"><br>整个圆形按顺时针方向组织，0和2^32-1在零点中方向重合。把服务器按照IP或主机名作为关键字进行哈希，这样就能确定其在哈希环的位置。<br><img src="https://img-blog.csdnimg.cn/aad9c57c736645fc837bc5b63e072678.png" alt="在这里插入图片描述"><br>我们就可以使用哈希函数H计算值为key的数据在哈希环的具体位置h，根据h确定在环中的具体位置，从此位置沿顺时针滚动，遇到的第一台服务器就是其定位到的服务器。</p><p>例如我们有1、2、3、4四个数据对象，经过哈希计算后，落到环空间上的位置，再顺时针滚动即可定位到服务器位置</p><p><img src="https://img-blog.csdnimg.cn/755c37355a284d0ea67890c043ae6270.png" alt="在这里插入图片描述"></p><h2 id="容错和扩展"><a href="#容错和扩展" class="headerlink" title="容错和扩展"></a>容错和扩展</h2><p>一致性哈希算法对于节点的增减都只需重定位换空间的一小部分即可，具有较好的容错性和可扩展性</p><h3 id="容错性"><a href="#容错性" class="headerlink" title="容错性"></a>容错性</h3><p>如果某个节点宕机了，比如A节点宕机了，那么，数据1对应的节点保存到B中<br>所以，某个节点宕机后，干扰的只有前面的数据（原数据被保存到顺时针的下一个服务器），而不会干扰到其他的数据。<br><img src="https://img-blog.csdnimg.cn/a35a4d79bfa04671802f10ee14a679d4.png" alt="在这里插入图片描述"></p><h3 id="扩展性"><a href="#扩展性" class="headerlink" title="扩展性"></a>扩展性</h3><p>假如增加一台服务器D，原本数据2是保存到B中，但由于增加了D节点，数据2被保存到D中。干扰的也只有B而已，其他数据不会受到影响。</p><p><img src="https://img-blog.csdnimg.cn/cc978523b30a4c9d86ffa2f498264b2a.png" alt="在这里插入图片描述"></p><h2 id="虚拟节点"><a href="#虚拟节点" class="headerlink" title="虚拟节点"></a>虚拟节点</h2><p>上面讲述的是节点较多和节点分布较为均衡的情况，如果节点较少就会出现节点分布不均衡造成数据倾斜问题。<br><img src="https://img-blog.csdnimg.cn/f34538edd4a940f4bd496ff7521c5201.png" alt="在这里插入图片描述"><br>这样大多数数据都会落到节点A上面，造成倾斜问题</p><p>为了解决这种数据存储不平衡的问题，一致性哈希算法引入了虚拟节点机制，即对每个节点计算多个哈希值，每个计算结果位置都放置在对应节点中，这些节点称为虚拟节点。</p><p>具体做法可以在服务器IP或主机名的后面增加编号来实现，例如上面的情况，可以为每个服务节点增加4个虚拟节点，于是可以分为 </p><ul><li>C#D，映射到D节点的虚拟节点</li><li>B#A，映射到A节点的虚拟节点</li><li>E#D，映射到D节点的虚拟节点</li><li>F#A，映射到A节点的虚拟节点</li></ul><p>这样就可以保证各个节点的数据比较均匀了，例如，数据7保存到虚拟节点C#D，实际上数据保存到D中。这样，就能解决服务节点少时数据不平均的问题。<br><img src="https://img-blog.csdnimg.cn/fb707441265c4120adeae19768b0d878.png" alt="在这里插入图片描述"><br>在实际应用中，通常将虚拟节点数设置为32甚至更大，因此即使很少的服务节点也能做到相对均匀的数据分布。</p>]]></content>
      
      
      <categories>
          
          <category> 分布式微服务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 哈希 </tag>
            
            <tag> 集群 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>生产者-消费者模型</title>
      <link href="/posts/60936.html"/>
      <url>/posts/60936.html</url>
      
        <content type="html"><![CDATA[<h2 id="什么是生产者消费者模型"><a href="#什么是生产者消费者模型" class="headerlink" title="什么是生产者消费者模型"></a>什么是生产者消费者模型</h2><p>生产者 - 消费者模型（ Producer-consumer problem） 是一个非常经典的多线程并发协作的模型，在分布式系统里非常常见。<br><img src="https://img-blog.csdnimg.cn/523ef8e8b8be4722b1ba88c49bbd671d.png" alt="在这里插入图片描述"></p><p>这个模型由两类线程和一个缓冲区组成来组成</p><ul><li>生产者线程：生产数据，并把数据放在这个队列里面</li><li>缓冲区：存放生产者的数据的地方</li><li>消费者线程：从队列里面取数据，消费数据</li></ul><p>运行流程</p><ul><li>生产者和消费者在同一时间段内共用同一个存储空间</li><li>生产者往存储空间中添加产品</li><li>消费者从存储空间中取走产品</li><li>当存储空间为空时，消费者阻塞，当存储空间满时，生产者阻塞。</li></ul><h2 id="为什么要用生产者消费者模型"><a href="#为什么要用生产者消费者模型" class="headerlink" title="为什么要用生产者消费者模型"></a>为什么要用生产者消费者模型</h2><p>在多线程世界里，生产者就是生产数据的线程，消费者就是消费数据的线程。在多线程开发当中</p><ul><li>如果生产者处理速度很快，而消费者处理速度很慢，那么生产者就必须等待消费者处理完，才能继续生产数据。</li><li>如果消费者的处理能力大于生产者，那么消费者就必须等待生产者。为了解决这个问题于是引入了生产者和消费者模式。</li></ul><h2 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h2><h3 id="wait-和notify-方法的实现"><a href="#wait-和notify-方法的实现" class="headerlink" title="wait()和notify()方法的实现"></a>wait()和notify()方法的实现</h3><ul><li><p>wait方法：执行该方法的对象释放同步锁，JVM把该线程存放到等待池中，等待其他线程唤醒</p></li><li><p>notify方法：唤醒在等待池中的等待的任意一个线程，把线程转移到锁池中</p></li><li><p>notifyAll方法：唤醒在等待池中等待的所有线程，把线程转移到锁池中</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">WaitTest</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> buffCount <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">String</span> lock <span class="token operator">=</span> <span class="token string">"lock"</span><span class="token punctuation">;</span>    <span class="token keyword">class</span> <span class="token class-name">Producer</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span> <span class="token punctuation">&#123;</span>        <span class="token annotation punctuation">@Override</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>                    <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>                <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>lock<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    <span class="token keyword">while</span> <span class="token punctuation">(</span>count <span class="token operator">==</span> buffCount<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                        <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>                            lock<span class="token punctuation">.</span><span class="token function">wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token punctuation">&#125;</span>                    <span class="token punctuation">&#125;</span>                    count<span class="token operator">++</span><span class="token punctuation">;</span>                    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"-生产者生产，数量为:"</span> <span class="token operator">+</span> count<span class="token punctuation">)</span><span class="token punctuation">;</span>                    lock<span class="token punctuation">.</span><span class="token function">notifyAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">class</span> <span class="token class-name">Consumer</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span> <span class="token punctuation">&#123;</span>        <span class="token annotation punctuation">@Override</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>                    <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>                <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>lock<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    <span class="token keyword">while</span> <span class="token punctuation">(</span>count <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                        <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>                            lock<span class="token punctuation">.</span><span class="token function">wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token punctuation">&#125;</span>                    <span class="token punctuation">&#125;</span>                    count<span class="token operator">--</span><span class="token punctuation">;</span>                    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"-消费者消费，数量为："</span><span class="token operator">+</span> count<span class="token punctuation">)</span><span class="token punctuation">;</span>                    lock<span class="token punctuation">.</span><span class="token function">notifyAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">WaitTest</span> waitTest <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">WaitTest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>waitTest<span class="token punctuation">.</span><span class="token keyword">new</span> <span class="token class-name">Producer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>waitTest<span class="token punctuation">.</span><span class="token keyword">new</span> <span class="token class-name">Consumer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>waitTest<span class="token punctuation">.</span><span class="token keyword">new</span> <span class="token class-name">Producer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>waitTest<span class="token punctuation">.</span><span class="token keyword">new</span> <span class="token class-name">Consumer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>waitTest<span class="token punctuation">.</span><span class="token keyword">new</span> <span class="token class-name">Producer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>waitTest<span class="token punctuation">.</span><span class="token keyword">new</span> <span class="token class-name">Consumer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h3 id="使用ReentrantLock实现"><a href="#使用ReentrantLock实现" class="headerlink" title="使用ReentrantLock实现"></a>使用ReentrantLock实现</h3><p>juc并发包中的 Lock 框架是锁的一个抽象，通过对lock的lock()方法和unlock()方法实现了对锁的显示控制，而synchronize()则是对锁的隐性控制。</p><p>可重入锁，也叫做递归锁，指的是同一线程的外层函数获得锁之后 ，内层递归函数仍然有获取该锁的代码，但不受影响</p><p>简单来说，该锁维护这一个与获取锁相关的计数器，如果拥有锁的某个线程再次得到锁，那么获取计数器就加1，函数调用结束计数器就减1，然后锁需要被释放两次才能获得真正释放。</p><p>已经获取锁的线程进入其他需要相同锁的同步代码块不会被阻塞。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">LockTest</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> buffCount <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">Lock</span> lock <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReentrantLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//创建两个条件变量，一个为缓冲区非满，一个为缓冲区非空</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">Condition</span> notFull <span class="token operator">=</span> lock<span class="token punctuation">.</span><span class="token function">newCondition</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">Condition</span> notEmpty <span class="token operator">=</span> lock<span class="token punctuation">.</span><span class="token function">newCondition</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">class</span> <span class="token class-name">Producer</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span> <span class="token punctuation">&#123;</span>        <span class="token annotation punctuation">@Override</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>                    <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>               lock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>                    <span class="token keyword">while</span> <span class="token punctuation">(</span>count <span class="token operator">==</span> buffCount<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                        <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>                            notFull<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token punctuation">&#125;</span>                    <span class="token punctuation">&#125;</span>                    count<span class="token operator">++</span><span class="token punctuation">;</span>                    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"-生产者生产，数量为:"</span> <span class="token operator">+</span> count<span class="token punctuation">)</span><span class="token punctuation">;</span>                    notEmpty<span class="token punctuation">.</span><span class="token function">signal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span> <span class="token keyword">finally</span> <span class="token punctuation">&#123;</span>                    lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">class</span> <span class="token class-name">Consumer</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span> <span class="token punctuation">&#123;</span>        <span class="token annotation punctuation">@Override</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>                    <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>                lock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>                    <span class="token keyword">while</span> <span class="token punctuation">(</span>count <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                        <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>                            notEmpty<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token punctuation">&#125;</span>                    <span class="token punctuation">&#125;</span>                    count<span class="token operator">--</span><span class="token punctuation">;</span>                    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"-消费者消费，数量为："</span><span class="token operator">+</span> count<span class="token punctuation">)</span><span class="token punctuation">;</span>                    notFull<span class="token punctuation">.</span><span class="token function">signal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span> <span class="token keyword">finally</span> <span class="token punctuation">&#123;</span>                    lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">LockTest</span> lockTest <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LockTest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>lockTest<span class="token punctuation">.</span><span class="token keyword">new</span> <span class="token class-name">Producer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>lockTest<span class="token punctuation">.</span><span class="token keyword">new</span> <span class="token class-name">Consumer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>lockTest<span class="token punctuation">.</span><span class="token keyword">new</span> <span class="token class-name">Producer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>lockTest<span class="token punctuation">.</span><span class="token keyword">new</span> <span class="token class-name">Consumer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>lockTest<span class="token punctuation">.</span><span class="token keyword">new</span> <span class="token class-name">Producer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>lockTest<span class="token punctuation">.</span><span class="token keyword">new</span> <span class="token class-name">Consumer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="使用阻塞队列BlockingQueue实现"><a href="#使用阻塞队列BlockingQueue实现" class="headerlink" title="使用阻塞队列BlockingQueue实现"></a>使用阻塞队列BlockingQueue实现</h3><p>BlockingQueue即阻塞队列，拥有队列先进先出的特性，在某些情况下对阻塞队列的访问可能会造成阻塞。被阻塞的情况主要有如下两种:</p><ul><li>当队列满了的时候进行入队列操作</li><li>当队列空了的时候进行出队列操作</li></ul><p>阻塞队列是线程安全的，因为：</p><ul><li>当一个线程对已经满了的阻塞队列进行入队操作时会阻塞，除非有另外一个线程进行了出队操作，</li><li>当一个线程对一个空的阻塞队列进行出队操作时也会阻塞，除非有另外一个线程进行了入队操作。</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">BlockingQueueTest</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">BlockingQueue</span> blockingQueue <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedBlockingQueue</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">class</span> <span class="token class-name">Producer</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span> <span class="token punctuation">&#123;</span>        <span class="token annotation punctuation">@Override</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>                    <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>                <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>                    blockingQueue<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    count<span class="token operator">++</span><span class="token punctuation">;</span>                    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"-生产者生产，数量为:"</span> <span class="token operator">+</span> count<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">class</span> <span class="token class-name">Consumer</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span> <span class="token punctuation">&#123;</span>        <span class="token annotation punctuation">@Override</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>                    <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>                <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>                    blockingQueue<span class="token punctuation">.</span><span class="token function">take</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    count<span class="token operator">--</span><span class="token punctuation">;</span>                    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"-消费者消费，数量为："</span><span class="token operator">+</span> count<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">BlockingQueueTest</span> blockingQueueTest <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BlockingQueueTest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>blockingQueueTest<span class="token punctuation">.</span><span class="token keyword">new</span> <span class="token class-name">Producer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>blockingQueueTest<span class="token punctuation">.</span><span class="token keyword">new</span> <span class="token class-name">Consumer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>blockingQueueTest<span class="token punctuation">.</span><span class="token keyword">new</span> <span class="token class-name">Producer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>blockingQueueTest<span class="token punctuation">.</span><span class="token keyword">new</span> <span class="token class-name">Consumer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>blockingQueueTest<span class="token punctuation">.</span><span class="token keyword">new</span> <span class="token class-name">Producer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>blockingQueueTest<span class="token punctuation">.</span><span class="token keyword">new</span> <span class="token class-name">Consumer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="信号量Semaphore的实现"><a href="#信号量Semaphore的实现" class="headerlink" title="信号量Semaphore的实现"></a>信号量Semaphore的实现</h3><p>Semaphore（信号量）是用来控制同时访问特定资源的线程数量，它通过协调各个线程，以保证合理的使用公共资源，在操作系统中是一个非常重要的问题，用来解决哲学家就餐问题。</p><p>Java中的Semaphore维护了一个许可集，一开始先设定这个许可集的数量，可以使用acquire()方法获得一个许可，当许可不足时会被阻塞，release()添加一个许可。</p><p>在下列代码中，还加入了另外一个mutex信号量，维护生产者消费者之间的同步关系，保证生产者和消费者之间的交替进行</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SemaphoreTest</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token comment">//创建三个信号量</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">Semaphore</span> notFull <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Semaphore</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">Semaphore</span> notEmpty <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Semaphore</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">Semaphore</span> mutex <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Semaphore</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">class</span> <span class="token class-name">Producer</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span> <span class="token punctuation">&#123;</span>        <span class="token annotation punctuation">@Override</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>                    <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>                <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>                    notFull<span class="token punctuation">.</span><span class="token function">acquire</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//获取许可</span>                    mutex<span class="token punctuation">.</span><span class="token function">acquire</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    count<span class="token operator">++</span><span class="token punctuation">;</span>                    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"-生产者生产，数量为:"</span> <span class="token operator">+</span> count<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span><span class="token keyword">finally</span> <span class="token punctuation">&#123;</span>                    mutex<span class="token punctuation">.</span><span class="token function">release</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//释放</span>                    notEmpty<span class="token punctuation">.</span><span class="token function">release</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">class</span> <span class="token class-name">Consumer</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span> <span class="token punctuation">&#123;</span>        <span class="token annotation punctuation">@Override</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>                    <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>                <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>                    notEmpty<span class="token punctuation">.</span><span class="token function">acquire</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    mutex<span class="token punctuation">.</span><span class="token function">acquire</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    count<span class="token operator">--</span><span class="token punctuation">;</span>                    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"-消费者消费，数量为："</span><span class="token operator">+</span> count<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span> <span class="token keyword">finally</span> <span class="token punctuation">&#123;</span>                    mutex<span class="token punctuation">.</span><span class="token function">release</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    notFull<span class="token punctuation">.</span><span class="token function">release</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">SemaphoreTest</span> semaphoreTest <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SemaphoreTest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>semaphoreTest<span class="token punctuation">.</span><span class="token keyword">new</span> <span class="token class-name">Producer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>semaphoreTest<span class="token punctuation">.</span><span class="token keyword">new</span> <span class="token class-name">Consumer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>semaphoreTest<span class="token punctuation">.</span><span class="token keyword">new</span> <span class="token class-name">Producer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>semaphoreTest<span class="token punctuation">.</span><span class="token keyword">new</span> <span class="token class-name">Consumer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>semaphoreTest<span class="token punctuation">.</span><span class="token keyword">new</span> <span class="token class-name">Producer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>semaphoreTest<span class="token punctuation">.</span><span class="token keyword">new</span> <span class="token class-name">Consumer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="管道输入输出流实现"><a href="#管道输入输出流实现" class="headerlink" title="管道输入输出流实现"></a>管道输入输出流实现</h3><p>在java的io包下，PipedOutputStream和PipedInputStream分别是管道输出流和管道输入流。<br>它们的作用是让多线程可以通过管道进行线程间的通讯。在使用管道通信时，必须将PipedOutputStream和PipedInputStream配套使用。</p><ul><li>先创建一个管道输入流和管道输出流，然后将输入流和输出流进行连接，</li><li>用生产者线程往管道输出流中写入数据，消费者在管道输入流中读取数据，</li><li>这样就可以实现了不同线程间的相互通讯，</li><li>但是这种方式在生产者和生产者、消费者和消费者之间不能保证同步，也就是说在一个生产者和一个消费者的情况下是可以生产者和消费者之间交替运行的，多个生成者和多个消费者者之间则不行</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">PipedTest</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">PipedInputStream</span>  pis <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PipedInputStream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">PipedOutputStream</span> pos <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PipedOutputStream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>            pis<span class="token punctuation">.</span><span class="token function">connect</span><span class="token punctuation">(</span>pos<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">class</span> <span class="token class-name">Producer</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span> <span class="token punctuation">&#123;</span>        <span class="token annotation punctuation">@Override</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">int</span> num <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">255</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"生产者生产了一个数字，该数字为： "</span> <span class="token operator">+</span> num<span class="token punctuation">)</span><span class="token punctuation">;</span>                    pos<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span>                    pos<span class="token punctuation">.</span><span class="token function">flush</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span> <span class="token keyword">finally</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>                    pos<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    pis<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">class</span> <span class="token class-name">Consumer</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span> <span class="token punctuation">&#123;</span>        <span class="token annotation punctuation">@Override</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">int</span> num <span class="token operator">=</span> pis<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"消费者消费了一个数字，该数字为："</span> <span class="token operator">+</span> num<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span> <span class="token keyword">finally</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>                    pos<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    pis<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">PipedTest</span> pipedTest <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PipedTest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>pipedTest<span class="token punctuation">.</span><span class="token keyword">new</span> <span class="token class-name">Producer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>pipedTest<span class="token punctuation">.</span><span class="token keyword">new</span> <span class="token class-name">Consumer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 多线程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 生产者 </tag>
            
            <tag> 消费者 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring AOP是怎么实现的</title>
      <link href="/posts/1224.html"/>
      <url>/posts/1224.html</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Spring的AOP实现是通过动态代理实现的。如果我们为Spring的一个bean配置了AOP切面，那么Spring在创建这个bean的时候，实际上创建的是这个bean的一个代理对象，我们后续对bean中方法的调用，实际上调用的是代理类重写的代理方法。</p><p>而Spring的AOP使用了两种动态代理，分别是</p><ul><li>JDK的动态代理；</li><li>CGLib的动态代理。</li></ul><h3 id="JDK动态代理"><a href="#JDK动态代理" class="headerlink" title="JDK动态代理"></a>JDK动态代理</h3><p>Spring默认使用JDK的动态代理实现AOP，类如果实现了接口，Spring就会使用这种方式实现动态代理。JDK实现动态代理需要两个组件</p><ul><li>首先第一个就是InvocationHandler接口。我们在使用JDK的动态代理时，需要编写一个类，去实现这个接口，然后重写invoke方法，这个方法其实就是我们提供的代理方法。</li><li>然后JDK动态代理需要使用的第二个组件就是Proxy这个类，我们可以通过这个类的newProxyInstance方法，返回一个代理对象。生成的代理类实现了原来那个类的所有接口，并对接口的方法进行了代理，我们通过代理对象调用这些方法时，底层将通过反射，调用我们实现的invoke方法。</li></ul><h3 id="CGLib动态代理"><a href="#CGLib动态代理" class="headerlink" title="CGLib动态代理"></a>CGLib动态代理</h3><p>JDK的动态代理存在限制，那就是被代理的类必须是一个实现了接口的类，代理类需要实现相同的接口，代理接口中声明的方法。</p><ul><li>若需要代理的类没有实现接口，此时JDK的动态代理将没有办法使用，于是Spring会使用CGLib的动态代理来生成代理对象。</li><li>CGLib直接操作字节码，生成类的子类，重写类的方法完成代理。</li></ul><h2 id="JDK的动态代理"><a href="#JDK的动态代理" class="headerlink" title="JDK的动态代理"></a>JDK的动态代理</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>  JDK的动态代理是基于反射实现。JDK通过反射，生成一个代理类，这个代理类实现了原来那个类的全部接口，并对接口中定义的所有方法进行了代理。当我们通过代理对象执行原来那个类的方法时，代理类底层会通过反射机制，回调我们实现的InvocationHandler接口的invoke方法。并且这个代理类是Proxy类的子类</p><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul><li>JDK动态代理是JDK原生的，不需要任何依赖即可使用；</li><li>通过反射机制生成代理类的速度要比CGLib操作字节码生成代理类的速度更快；<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3></li><li>如果要使用JDK动态代理，被代理的类必须实现了接口，否则无法代理；</li><li>JDK动态代理无法为没有在接口中定义的方法实现代理，假设我们有一个实现了接口的类，我们为它的一个不属于接口中的方法配置了切面，Spring仍然会使用JDK的动态代理，但是由于配置了切面的方法不属于接口，为这个方法配置的切面将不会被织入。</li><li>JDK动态代理执行代理方法时，需要通过反射机制进行回调，此时方法执行的效率比较低；</li></ul><h2 id="CGLib动态代理-1"><a href="#CGLib动态代理-1" class="headerlink" title="CGLib动态代理"></a>CGLib动态代理</h2><h3 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h3><p>CGLib实现动态代理的原理是，底层采用了ASM字节码生成框架，直接对需要代理的类的字节码进行操作，生成这个类的一个子类，并重写了类的所有可以重写的方法，在重写的过程中，将我们定义的额外的逻辑（切面）织入到方法中，对方法进行了增强。</p><p>通过字节码操作生成的代理类，和我们自己编写并编译后的类没有什么区别。</p><h3 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h3><ul><li>使用CGLib代理的类，不需要实现接口，因为CGLib生成的代理类是直接继承自需要被代理的类；</li><li>CGLib生成的代理类是原来那个类的子类，这就意味着这个代理类可以为原来那个类中，所有能够被子类重写的方法进行代理；</li><li>CGLib生成的代理类，和我们自己编写并编译的类没有太大区别，对方法的调用和直接调用普通类的方式一致，所以CGLib执行代理方法的效率要高于JDK的动态代理；</li></ul><h3 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h3><ul><li>由于CGLib的代理类使用的是继承，这也就意味着如果需要被代理的类是一个final类，则无法使用CGLib代理；</li><li>由于CGLib实现代理方法的方式是重写父类的方法，所以无法对final方法，或者private方法进行代理，因为子类无法重写这些方法；</li><li>CGLib生成代理类的方式是通过操作字节码，这种方式生成代理类的速度要比JDK通过反射生成代理类的速度更慢；</li></ul>]]></content>
      
      
      <categories>
          
          <category> 框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BIO、NIO、AIO的区别</title>
      <link href="/posts/34072.html"/>
      <url>/posts/34072.html</url>
      
        <content type="html"><![CDATA[<h2 id="同步与异步"><a href="#同步与异步" class="headerlink" title="同步与异步"></a>同步与异步</h2><p>同步和异步指的是一个执行流程中每个方法是否必须依赖前一个方法完成后才可以继续执行。假设我们现在有两个方法：方法一和方法二。</p><ul><li>同步指的是调用一旦开始，调用者必须等到方法调用返回后，才能继续后续的行为。即方法二一定要等到方法一执行完成后才可以执行。</li><li>异步指的是调用立刻返回，调用者不必等待方法内的代码执行结束，就可以继续后续的行为。即执行方法一的时候，直接交给其他线程执行，不由主线程执行，也就不会阻塞主线程，所以方法二不必等到方法一完成即可开始执行。</li></ul><p>同步与异步关注的是方法的执行方是主线程还是其他线程，主线程的话需要等待方法执行完成，其他线程的话无需等待立刻返回方法调用，主线程可以直接执行接下来的代码。<br>同步与异步是从多个线程之间的协调来实现效率差异。</p><h2 id="阻塞与非阻塞"><a href="#阻塞与非阻塞" class="headerlink" title="阻塞与非阻塞"></a>阻塞与非阻塞</h2><p>阻塞与非阻塞指的是单个线程内遇到同步等待时，是否在原地不做任何操作。</p><ul><li>阻塞指的是遇到同步等待后，一直在原地等待同步方法处理完成。</li><li>非阻塞指的是遇到同步等待，不在原地等待，先去做其他的操作，过一会再来观察同步方法是否完成。</li></ul><p>阻塞与非阻塞关注的是线程是否在原地等待。</p><h2 id="BIO"><a href="#BIO" class="headerlink" title="BIO"></a>BIO</h2><p>BIO全称是Blocking IO，是同步阻塞模式。</p><ul><li>线程发起IO请求后，一直阻塞IO，直到缓冲区数据就绪后，再进入下一步操作。</li><li>网络通信都是请求一应答的方式，</li></ul><p>虽然简化了上层的应用开发，但在性能和可靠性方面存在着巨大瓶颈，如果每个请求都需要新建一个线程来专门处理，那么在高并发的场景下，服务器的资源很快就会被耗尽。</p><h2 id="NIO"><a href="#NIO" class="headerlink" title="NIO"></a>NIO</h2><p>NIO全称是Non-Blocking IO ，是同步非阻塞的IO模型。</p><ul><li>线程发起io请求后，立即返回（非阻塞io）。</li><li>同步指的是必须等待IO缓冲区内的数据就绪</li><li>而非阻塞指的是，线程不原地等待IO缓冲区，可以先做一些其他操作，但是要定时轮询检查IO缓冲区数据是否就绪。</li></ul><p>Java中的NIO 是new IO的意思。其实是NIO加上IO多路复用技术。普通的NIO是线程轮询查看一个IO缓冲区是否就绪，而Java中的new IO指的是线程轮询地去查看一堆IO缓冲区中哪些就绪，这是一种IO多路复用的思想。</p><p>IO多路复用模型中，将检查IO数据是否就绪的任务，交给系统级别的select或epoll模型，由系统进行监控，减轻用户线程负担。</p><p>NIO主要有buffer、channel、selector三种技术的整合</p><ul><li>通过零拷贝的buffer取得数据，每一个客户端通过channel在selector（多路复用器）上进行注册。</li><li>服务端不断轮询channel来获取客户端的信息。</li><li>channel上有connect,accept（阻塞）、read（可读）、write(可写)四种状态标识。</li><li>所以一个服务端可接收无限多的channel。不需要新开一个线程。大大提升了性能。<h2 id="AIO"><a href="#AIO" class="headerlink" title="AIO"></a>AIO</h2>AIO是真正意义上的异步非阻塞IO模型。</li><li>在NIO实现中，需要用户线程定时轮询，去检查IO缓冲区数据是否就绪，占用应用程序线程资源，其实轮询相当于还是阻塞的，并非真正解放当前线程，因为它还是需要去查询哪些IO就绪。</li><li>而真正的理想的异步非阻塞IO应该让内核系统完成，用户线程只需要告诉内核，当缓冲区就绪后，通知我或者执行我交给你的回调函数。</li><li>AIO可以做到真正的异步的操作，但实现起来比较复杂。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 多线程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 同步/异步 </tag>
            
            <tag> IO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java反射机制</title>
      <link href="/posts/30031.html"/>
      <url>/posts/30031.html</url>
      
        <content type="html"><![CDATA[<h2 id="什么是反射"><a href="#什么是反射" class="headerlink" title="什么是反射"></a>什么是反射</h2><p>在程序的运行状态中，</p><ul><li>可以构造任意一个类的对象，</li><li>可以了解任意一个对象所属的类，</li><li>可以了解任意一个类的成员变量和方法，</li><li>可以调用任意一个对象的属性和方法。</li></ul><p>这种动态获取程序信息以及动态调用对象的功能称为 Java 语言的反射机制。反射被视为动态语言的关键。</p><h2 id="两种表现类型"><a href="#两种表现类型" class="headerlink" title="两种表现类型"></a>两种表现类型</h2><p>Java程序中的对象在运行时可以表现为两种类型，即</p><ul><li>编译时类型</li><li>运行时类型</li></ul><p>例如 User user = new Admin(); 这行代码将会生成一个user变量，该变量的编译时类型为User，运行时类型为Admin。</p><h2 id="为什么要反射"><a href="#为什么要反射" class="headerlink" title="为什么要反射"></a>为什么要反射</h2><p>有时，程序在运行时接收到外部传入的一个对象，该对象的编译时类型是Object，但程序又需要调用该对象的运行时类型的方法。这就要求程序需要在运行时发现对象和类的真实信息，而解决这个问题有以下两种做法：</p><ul><li>第一种做法是假设在编译时和运行时都完全知道类型的具体信息，在这种情况下，可以先使用instanceof运算符进行判断，再利用强制类型转换将其转换成其运行时类型的变量即可。</li><li>第二种做法是编译时根本无法预知该对象和类可能属于哪些类，程序只依靠运行时信息来发现该对象和类的真实信息，这就必须使用反射。</li></ul><p>通过反射机制，在程序运行时，我们可以实现如下的操作：</p><ul><li>通过反射获得任意一个类的Class对象，并通过这个对象查看这个类的信息；</li><li>通过反射创建任意一个类的实例，并访问该实例的成员；</li><li>通过反射机制生成一个类的动态代理类或动态代理对象。</li></ul><h2 id="反射常用类概述"><a href="#反射常用类概述" class="headerlink" title="反射常用类概述"></a>反射常用类概述</h2><ul><li><strong>Class：</strong> Class 类的实例表示正在运行的 Java 应用程序中的类和接口；</li><li><strong>Constructor：</strong> 关于类的单个构造方法的信息以及对它的权限访问；</li><li><strong>Field：</strong> Field 提供有关类或接口的单个字段的信息，以及对它的动态访问权限；</li><li><strong>Method：</strong> Method 提供关于类或接口上单独某个方法的信息。</li></ul><p>字节码文件想要运行都是要被虚拟机加载的，每加载一种类，Java 虚拟机都会为其创建一个 Class 类型的实例，并关联起来。</p><h2 id="反射的使用场景"><a href="#反射的使用场景" class="headerlink" title="反射的使用场景"></a>反射的使用场景</h2><p>Java 的反射机制，主要用来编写一些通用性较高的代码或者编写框架的时候使用。</p><p>通过反射的概念，我们可以知道，在程序的运行状态中，对于任意一个类，通过反射都可以动态获取其信息以及动态调用对象。</p><p>例如，很多框架都可以通过配置文件，来让开发者指定使用不同的类，开发者只需要关心配置，不需要关心代码的具体实现，具体实现都在框架的内部，通过反射就可以动态生成类的对象，调用这个类下面的一些方法。</p><p>Java的反射机制在实际项目中应用广泛，常见的应用场景有：</p><ul><li>使用JDBC时，如果要创建数据库的连接，则需要先通过反射机制加载数据库的驱动程序；</li><li>多数框架都支持注解/XML配置，从配置中解析出来的类是字符串，需要利用反射机制实例化；</li><li>面向切面编程（AOP）的实现方案，是在程序运行时创建目标对象的代理类，这必须由反射机制来实现。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 反射 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL如何避免幻读</title>
      <link href="/posts/39079.html"/>
      <url>/posts/39079.html</url>
      
        <content type="html"><![CDATA[<h2 id="事务的并发问题"><a href="#事务的并发问题" class="headerlink" title="事务的并发问题"></a>事务的并发问题</h2><ol><li>脏读：事务A读取了事务B更新的数据，然后B回滚操作，那么A读取到的数据是脏数据</li><li>不可重复读：事务A多次读取同一数据，事务B在事务A多次读取的过程中，对数据作了更新并提交，导致事务A多次读取同一数据时，结果不一致。</li><li>幻读：A事务读取了B事务已经提交的新增数据。注意和不可重复读的区别，这里是新增，不可重复读是更改（或删除）。select某记录是否存在，不存在，准备插入此记录，但执行 insert 时发现此记录已存在，无法插入，此时就发生了幻读。</li></ol><h2 id="MySQL如何实现避免幻读"><a href="#MySQL如何实现避免幻读" class="headerlink" title="MySQL如何实现避免幻读"></a>MySQL如何实现避免幻读</h2><ul><li>在快照读读情况下，MySQL通过MVCC来避免幻读。</li><li>在当前读读情况下，MySQL通过next-key来避免幻读</li></ul><h2 id="什么是MVCC"><a href="#什么是MVCC" class="headerlink" title="什么是MVCC"></a>什么是MVCC</h2><p>MVCC全称是多版本并发控制的简称(multi version concurrent control)。MySQL把每个操作都定义成一个事务，每开启一个事务，系统的事务版本号自动递增。每行记录都有两个隐藏列：创建版本号和删除版本号</p><p>MVCC多版本并发控制是MySQL中基于乐观锁理论实现隔离级别的方式，用于读已提交和可重复读取隔离级别的实现。</p><p>在MySQL中，会在表中每一条数据后面添加两个字段：最近修改该行数据的事务ID，指向该行（undolog表中）回滚段的指针。</p><p>Read View判断行的可见性，创建一个新事务时，copy一份当前系统中的活跃事务列表。意思是，当前不应该被本事务看到的其他事务id列表。已提交读隔离级别下的事务在每次查询的开始都会生成一个独立的ReadView,而可重复读隔离级别则在第一次读的时候生成一个ReadView，之后的读都复用之前的ReadView。</p><ul><li><p>select：事务每次只能读到创建版本号小于等于此次系统版本号的记录，同时行的删除版本号不存在或者大于当前事务的版本号。</p></li><li><p>update：插入一条新记录，并把当前系统版本号作为行记录的版本号，同时保存当前系统版本号到原有的行作为删除版本号。</p></li><li><p>delete：把当前系统版本号作为行记录的删除版本号</p></li><li><p>insert：把当前系统版本号作为行记录的版本号</p></li></ul><h2 id="什么是next-key锁"><a href="#什么是next-key锁" class="headerlink" title="什么是next-key锁"></a>什么是next-key锁</h2><p>InnoDB 采用 Next-Key Lock 解决幻读问题。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">insert into test<span class="token punctuation">(</span>xid<span class="token punctuation">)</span> values <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>, <span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span>, <span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span>, <span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">)</span>, <span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在这条语句执行后，由于xid上是有索引的，该算法总是会去锁住索引记录<br>现在，该索引可能被锁住的范围如下：(-∞, 1], (1, 3], (3, 5], (5, 8], (8, 11], (11, +∞)。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token keyword">select</span> * from <span class="token builtin class-name">test</span> where <span class="token function">id</span> <span class="token operator">=</span> <span class="token number">8</span> <span class="token keyword">for</span> update<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这条语句执行后会锁住的范围：(5, 8], (8, 11]。<br>除了锁住8所在的范围，还会锁住下一个范围，所谓Next-Key。</p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 幻读 </tag>
            
            <tag> MVCC </tag>
            
            <tag> next-key </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RabbitMQ的死信队列</title>
      <link href="/posts/37640.html"/>
      <url>/posts/37640.html</url>
      
        <content type="html"><![CDATA[<h2 id="什么是死信"><a href="#什么是死信" class="headerlink" title="什么是死信"></a>什么是死信</h2><p>在 RabbitMQ 中充当主角的就是消息，在不同场景下，消息会有不同地表现。<br>死信就是消息在特定场景下的一种表现形式，这些场景包括：</p><ul><li>消息被拒绝访问，即 RabbitMQ返回 nack 的信号时</li><li>消息的 TTL 过期时</li><li>消息队列达到最大长度</li><li>消息不能入队时。</li></ul><p>上述场景经常产生死信，即消息在这些场景中时，被称为死信。</p><h2 id="什么是死信队列"><a href="#什么是死信队列" class="headerlink" title="什么是死信队列"></a>什么是死信队列</h2><p>死信队列就是用于储存死信的消息队列，在死信队列中，有且只有死信构成，不会存在其余类型的消息。</p><p>死信队列在 RabbitMQ 中并不会单独存在，往往死信队列都会绑定这一个普通的消息队列，当所绑定的消息队列中，有消息变成死信了，那么这个消息就会重新被交换机路由到指定的死信队列中去，我们可以通过对这个死信队列进行监听，从而手动的去对这一消息进行补偿。</p><p>那么，我们到底如何来使用死信队列呢？</p><h2 id="死信队列基本使用"><a href="#死信队列基本使用" class="headerlink" title="死信队列基本使用"></a>死信队列基本使用</h2><p>在 RabbitMQ 中，死信队列的标识为 x-dead-letter-exchange ，通过观察死信队列的标识，我们不难发现，其标识最后为 exchange ，即 RabbitMQ 中的交换机，RabbitMQ 中的死信队列就是由死信交换机而得出的。</p><p>要想使用死信队列，我们需要首先声明一个普通的消息队列，并将死信队列的标识绑定到这个普通的消息队列上， 这个过程需要我们在生产端进行配置，代码如下所示：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// 使用 ConnectionFactory 创建了一个客户端连接 RabbitMQ Server 的连接。</span><span class="token class-name">ConnectionFactory</span> connectionFactory <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConnectionFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>connectionFactory<span class="token punctuation">.</span><span class="token function">setHost</span><span class="token punctuation">(</span><span class="token string">"xx"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>connectionFactory<span class="token punctuation">.</span><span class="token function">setPort</span><span class="token punctuation">(</span><span class="token string">"5672"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>connectionFactory<span class="token punctuation">.</span><span class="token function">setVirtualHost</span><span class="token punctuation">(</span><span class="token string">"/"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">Connection</span> connection <span class="token operator">=</span> connectionFactory<span class="token punctuation">.</span><span class="token function">newConnection</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 使用建立好的连接，来创建了一个频道 channel 。</span><span class="token class-name">Channel</span> channel <span class="token operator">=</span> connection<span class="token punctuation">.</span><span class="token function">createChanel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 声明了一个普通队列的额外参数的 Map ，</span><span class="token comment">// 这个 Map 的 key 就是死信队列的标识，value 就是我们后续声明的真正的死信交换机的名称。</span><span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">></span></span> argumentsMap <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>argumentsMap<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"x-dead-letter-exchange"</span><span class="token punctuation">,</span> <span class="token string">"dlx_exchange"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">/*使用 channel 的 exchangeDeclare 方法和 queueDeclare 方法，分别声明了一个名为 dlx_common_exchange 的交换机和名为 dlx_common_queue 的普通消息队列，之所以名称中有 common ，是因为要对这个交换机和队列做一个标识，表示该交换机和队列是绑定了死信队列的。*/</span>channel<span class="token punctuation">.</span><span class="token function">exchangeDeclare</span><span class="token punctuation">(</span><span class="token string">"dlx_common_exchange"</span><span class="token punctuation">,</span> <span class="token string">"direct"</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>channel<span class="token punctuation">.</span><span class="token function">queueDeclare</span><span class="token punctuation">(</span><span class="token string">"dlx_common_queue"</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> argumentsMap<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">/*使用 channel 的 queueBind 方法来讲声明的普通交换机和消息队列进行绑定，并且制定了 routingKey ，这样消息就可以经 dlx_common_exchange 根据 routingKey 来路由到 dlx_common_queue 中。*/</span>channel<span class="token punctuation">.</span><span class="token function">queueBind</span><span class="token punctuation">(</span><span class="token string">"dlx_common_queue"</span><span class="token punctuation">,</span> <span class="token string">"dlx_common_exchange"</span><span class="token punctuation">,</span> routingKey<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>声明了要绑定死信队列的普通队列之后，最后我们需要声明真正的死信队列</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// 使用 chanel 的 exchangeDeclare 方法来声明了一个名为 dlx_exchange 的交换机。</span>channel<span class="token punctuation">.</span><span class="token function">exchangeDeclare</span><span class="token punctuation">(</span><span class="token string">"dlx_exchange"</span><span class="token punctuation">,</span> <span class="token string">"direct"</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 使用 channel 的 queueDeclare 方法来声明了一个名为 dlx_queue 的队列。</span>channel<span class="token punctuation">.</span><span class="token function">queueDeclare</span><span class="token punctuation">(</span><span class="token string">"dlx_queue"</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 使用 channel 的 queueBind 方法，来将 dlx_exchange 的交换机与 dlx_queue 队列进行了绑定。</span>channel<span class="token punctuation">.</span><span class="token function">queueBind</span><span class="token punctuation">(</span><span class="token string">"dlx_queue"</span><span class="token punctuation">,</span> <span class="token string">"dlx_exchange"</span><span class="token punctuation">,</span> routingKey<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="MQ处理消息失败了怎么办"><a href="#MQ处理消息失败了怎么办" class="headerlink" title="MQ处理消息失败了怎么办"></a>MQ处理消息失败了怎么办</h2><p>在生产环境中，使用MQ的时候设计两个队列：</p><ul><li>一个是业务队列，专门用来处理消息；</li><li>一个是死信队列。用来处理异常情况。</li></ul><p>比如说消费消息的时候，数据库故障了，此时无法将数据落盘，那么消费者每次消费一条消息，尝试落盘持久化的时候，都会遇到数据库报错。此时消费者就可以把这条消息拒绝访问，或者标志位处理失败！</p><ul><li>一旦标志这条消息处理失败了之后，MQ就会把这条消息转入提前设置好的一个死信队列中。</li><li>在数据库故障期间，所有消息全部处理失败，全部会转入死信队列。</li><li>然后消费者会专门有一个后台线程，监控数据库是否正常，能否请求的，不停的监视。</li><li>一旦发现对方恢复正常，这个后台线程就从死信队列消费出来处理失败的订单，重新处理逻辑</li><li>死信队列的使用，其实就是MQ在生产实践中非常重要的一环，也就是架构设计必须要考虑的。<br><img src="https://img-blog.csdnimg.cn/8a20d6e5492041dd9a6e0b02a6aef248.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5rGf5rqq5rC0,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></li></ul>]]></content>
      
      
      <categories>
          
          <category> 消息队列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RabbitMQ </tag>
            
            <tag> 死信队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>红黑树是什么</title>
      <link href="/posts/60670.html"/>
      <url>/posts/60670.html</url>
      
        <content type="html"><![CDATA[<h2 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h2><p>红黑树是一种接近平衡的二叉搜索树，它能够保证任意一个节点左右子树的高度差不会超过较低子树的高度，也就是两棵子树的高度比值不会超过 2 倍。这样我们可以使搜索的时间复杂度更接近 O (logN)。为了保证树的平衡，我们需要在添加或删除元素的时候不断的调整树的结构，使每个节点的左右子树上的节点个数尽可能相等。</p><h2 id="红黑树的性质"><a href="#红黑树的性质" class="headerlink" title="红黑树的性质"></a>红黑树的性质</h2><ul><li>每个节点不是红色就是黑色；</li><li>根节点永远是黑色；</li><li>红色节点的子节点必须是黑色；</li><li>任意一个节点到每个叶子节点的路径上都包含相同数量的黑色节点；</li><li>每次添加新节点都默认为红色。</li></ul><h2 id="红黑树调整的方式"><a href="#红黑树调整的方式" class="headerlink" title="红黑树调整的方式"></a>红黑树调整的方式</h2><p>如果每次添加节点都设置为红色，当父节点已经是红色时，会违背上面的第 3 条性质，这时候我们需要按照一定的方法去调整树，调整的方式有三种：</p><ul><li>改变节点颜色</li><li>左旋</li><li>右旋。</li></ul><h4 id="变色"><a href="#变色" class="headerlink" title="变色"></a>变色</h4><p>改变节点颜色如下图，我们依次做了以下尝试：</p><ul><li>①默认红色：违反性质 3；</li><li>②默认黑色：违反性质 4；</li><li>③默认红色，将父节点和父节点的兄弟节点改为黑色，满足全部 5 条性质。</li></ul><h4 id="左旋"><a href="#左旋" class="headerlink" title="左旋"></a>左旋</h4><p>拎起左旋节点的右子节点，使左旋节点向左下沉，成为右子节点的左子节点，右子节点上升成为其父节点。</p><h4 id="右旋"><a href="#右旋" class="headerlink" title="右旋"></a>右旋</h4><p>拎起右旋节点的左子节点，使右旋节点向右下沉，成为左子节点的右子节点，左子节点上升成为其父节点。</p><h2 id="红黑树的插入操作"><a href="#红黑树的插入操作" class="headerlink" title="红黑树的插入操作"></a>红黑树的插入操作</h2><p>插入元素会导致原本平衡的红黑树失去平衡，还会导致红黑树五大特性的不满足。因此插入后我们需要做调整，使其重新成为一个红黑树。</p><h4 id="寻找插入位置"><a href="#寻找插入位置" class="headerlink" title="寻找插入位置"></a>寻找插入位置</h4><p>把元素插进红黑树的第一步是找到要插入的位置。寻找位置的方法其实也比较简单：</p><ul><li>①如果是空树，直接插入到跟节点；</li><li>②如果与当前节点的 key 值相等，则更新当前节点的 value 值；</li><li>③如果比当前节点的 key 值大，则继续寻找当前节点的右子节点；</li><li>④如果比当前节点的 key 值小，则继续寻找当前节点的左子节点；</li><li>⑤如果当前节点为 null（或 nil 节点），则插入在当前节点的父节点下。</li></ul><h2 id="自平衡"><a href="#自平衡" class="headerlink" title="自平衡"></a>自平衡</h2><p>红黑树的自平衡较为复杂</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">static</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> <span class="token class-name">TreeNode</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> <span class="token function">balanceInsertion</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> root<span class="token punctuation">,</span> <span class="token class-name">TreeNode</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> x<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    x<span class="token punctuation">.</span>red <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">TreeNode</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> xp<span class="token punctuation">,</span> xpp<span class="token punctuation">,</span> xppl<span class="token punctuation">,</span> xppr<span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">//false条件：当前节点存在父节点</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>xp <span class="token operator">=</span> x<span class="token punctuation">.</span>parent<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">//父节点为空，当前节点是根节点，直接设置根节点为黑色后返回</span>            x<span class="token punctuation">.</span>red <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> x<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">//false条件：且父节点是红色，且存在爷爷节点</span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>xp<span class="token punctuation">.</span>red <span class="token operator">||</span> <span class="token punctuation">(</span>xpp <span class="token operator">=</span> xp<span class="token punctuation">.</span>parent<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>            <span class="token keyword">return</span> root<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>xp <span class="token operator">==</span> <span class="token punctuation">(</span>xppl <span class="token operator">=</span> xpp<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">//false条件：且叔叔节点为空，或者是黑色；</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>xppr <span class="token operator">=</span> xpp<span class="token punctuation">.</span>right<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> xppr<span class="token punctuation">.</span>red<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                xppr<span class="token punctuation">.</span>red <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>                xp<span class="token punctuation">.</span>red <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>                xpp<span class="token punctuation">.</span>red <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>                x <span class="token operator">=</span> xpp<span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>                <span class="token comment">//true条件：当前节点是其父节点的右子节点；</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">==</span> xp<span class="token punctuation">.</span>right<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    <span class="token comment">// 左旋父节点</span>                    root <span class="token operator">=</span> <span class="token function">rotateLeft</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> x <span class="token operator">=</span> xp<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token comment">// 爷爷节点不存在则结束，存在则将指针指向父节点</span>                    xpp <span class="token operator">=</span> <span class="token punctuation">(</span>xp <span class="token operator">=</span> x<span class="token punctuation">.</span>parent<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">?</span> <span class="token keyword">null</span> <span class="token operator">:</span> xp<span class="token punctuation">.</span>parent<span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>                <span class="token comment">// true条件：父节点不为空</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>xp <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    <span class="token comment">// 父节点变为黑色</span>                    xp<span class="token punctuation">.</span>red <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>                    <span class="token comment">// true条件：祖父节点不为空</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>xpp <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                        <span class="token comment">// 祖父节点变为红色</span>                        xpp<span class="token punctuation">.</span>red <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>                        <span class="token comment">// 右旋祖父节点</span>                        root <span class="token operator">=</span> <span class="token function">rotateRight</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> xpp<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">&#125;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>            <span class="token comment">//false条件：且叔叔节点为空，或者是黑色；</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>xppl <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> xppl<span class="token punctuation">.</span>red<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token comment">// 当前节点的父节点以及左叔父节点都是红色 则颜色变为黑色</span>                xppl<span class="token punctuation">.</span>red <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>                xp<span class="token punctuation">.</span>red <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>                <span class="token comment">// 黑节点的父节点必须红色</span>                xpp<span class="token punctuation">.</span>red <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>                x <span class="token operator">=</span> xpp<span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>                <span class="token comment">//true条件：当前节点是其父节点的左子节点；</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">==</span> xp<span class="token punctuation">.</span>left<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    <span class="token comment">// 右旋父节点</span>                    root <span class="token operator">=</span> <span class="token function">rotateRight</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> x <span class="token operator">=</span> xp<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token comment">// 指针指向父节点</span>                    xpp <span class="token operator">=</span> <span class="token punctuation">(</span>xp <span class="token operator">=</span> x<span class="token punctuation">.</span>parent<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">?</span> <span class="token keyword">null</span> <span class="token operator">:</span> xp<span class="token punctuation">.</span>parent<span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>                <span class="token comment">// true条件：父节点不为空</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>xp <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    <span class="token comment">// 父节点变为黑色</span>                    xp<span class="token punctuation">.</span>red <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>                    <span class="token comment">// true条件：祖父节点不为空</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>xpp <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                        <span class="token comment">// 祖父节点变为红色</span>                        xpp<span class="token punctuation">.</span>red <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>                        <span class="token comment">//  右旋祖父节点</span>                        root <span class="token operator">=</span> <span class="token function">rotateLeft</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> xpp<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">&#125;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="红黑树的删除操作"><a href="#红黑树的删除操作" class="headerlink" title="红黑树的删除操作"></a>红黑树的删除操作</h2><p>删除操作可能触发的情况分为有子节点和无子节点</p><ul><li>没有子节点的情况非常简单，直接删除后执行自平衡即可；</li><li>有子节点的时候我们要先找到替换节点，如果只有一个子节点，这个节点就是替换节点；</li><li>如果有两个子节点，要找到左子树的最大节点或右子树的最小节点作为替换节点。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 红黑树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>select、poll和epoll的区别</title>
      <link href="/posts/51404.html"/>
      <url>/posts/51404.html</url>
      
        <content type="html"><![CDATA[<h2 id="进程所能打开的最大连接数"><a href="#进程所能打开的最大连接数" class="headerlink" title="进程所能打开的最大连接数"></a>进程所能打开的最大连接数</h2><h4 id="select"><a href="#select" class="headerlink" title="select"></a>select</h4><p>单个进程所能打开的最大连接数有FD_ SETSIZE宏定义， 其大小是32个整数的大小(在32位的机器上，大小就是32<em>32，同理64位机器上FD_ SETSIZE为32</em>64) </p><p>tips：我们可以对进行修改，然后重新编译内核，但是性能可能会受到影响，这需要进一步的测试。</p><h4 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h4><p>poll本质上和select没有区别，但是它没有最大连接数的限制，原因是它是基于链表来存储的</p><h4 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h4><p>虽然连接数有上限，但是很大，1G内存的机器上可以打开10万左右的连接，2G内存的机器可以打开20万左右的连接</p><h2 id="FD剧增后带来的IO效率问题"><a href="#FD剧增后带来的IO效率问题" class="headerlink" title="FD剧增后带来的IO效率问题"></a>FD剧增后带来的IO效率问题</h2><h4 id="select-1"><a href="#select-1" class="headerlink" title="select"></a>select</h4><p>因为每次调用时都会对连接进行线性遍历，所以随着FD的增加会造成遍历<br>速度慢的“线性下降性能问题”。</p><h4 id="poll-1"><a href="#poll-1" class="headerlink" title="poll"></a>poll</h4><p>由于poll与select的本质是一样的，所有poll有着和select一样的问题</p><h4 id="epoll-1"><a href="#epoll-1" class="headerlink" title="epoll"></a>epoll</h4><p>因为epoll内核中实现是根据每个fd上的callback函数来实现的，只有活跃的socket才会主动调用calback,所以在活跃socket较少的情况下，使用epoll没有前面两者的线性下降的性能问题，但是所有socket都很活跃的情况下，可能会有性能问题。</p><h2 id="消息传递方式"><a href="#消息传递方式" class="headerlink" title="消息传递方式"></a>消息传递方式</h2><h4 id="select-2"><a href="#select-2" class="headerlink" title="select"></a>select</h4><p>内核需要将消息传递到用户空间，都需要内核拷贝动作</p><h4 id="poll-2"><a href="#poll-2" class="headerlink" title="poll"></a>poll</h4><p>与select一样</p><h4 id="epoll-2"><a href="#epoll-2" class="headerlink" title="epoll"></a>epoll</h4><p>epoll通过内核和用户空间共享一块内存来 实现的</p><h2 id="select和epoll的区别。"><a href="#select和epoll的区别。" class="headerlink" title="select和epoll的区别。"></a>select和epoll的区别。</h2><p>select 函数监视的文件描述符分3类，分别是writefds、readfds、和exceptfds。调用后select函数会阻塞，直到有描述符就绪（有数据 可读、可写、或者有except），或者超时（timeout指定等待时间，如果立即返回设为null即可），函数返回。当select函数返回后，可以通过遍历fdset，来找到就绪的描述符。</p><p>select目前几乎在所有的平台上支持，其良好跨平台支持也是它的一个优点。select的一个缺点在于单个进程能够监视的文件描述符的数量存在最大限制，在Linux上一般为1024，可以通过修改宏定义甚至重新编译内核的方式提升这一限制，但是这样也会造成效率的降低。</p><p>内核需要传递消息到用户空间，需要内存拷贝</p><p>相对于select和poll来说，epoll更加灵活，没有描述符限制。epoll使用一个文件描述符管理多个描述符，将用户关系的文件描述符的事件存放到内核的一个事件表中，这样在用户空间和内核空间的copy只需一次。</p><p>epoll能打开的FD的上限远大于1024（1G的内存上能监听约10万个端口）。</p><p>效率提升，不是轮询的方式，不会随着FD数目的增加效率下降。只有活跃可用的FD才会调用callback函数；即Epoll最大的优点就在于它只管你“活跃”的连接，而跟连接总数无关，因此在实际的网络环境中，Epoll的效率就会远远高于select和poll。</p><h2 id="epoll的两种模式"><a href="#epoll的两种模式" class="headerlink" title="epoll的两种模式"></a>epoll的两种模式</h2><p>epoll对文件描述符的操作有两种模式：</p><ul><li>LT（level trigger）默认模式</li><li>ET（edge trigger）</li></ul><h3 id="LT模式"><a href="#LT模式" class="headerlink" title="LT模式"></a>LT模式</h3><p>当epoll_wait检测到描述符事件发生并将此事件通知应用程序，应用程序可以不立即处理该事件。下次调用epoll_wait时，会再次响应应用程序并通知此事件。</p><p>LT(level triggered)是缺省的工作方式，并且同时支持block和no-block socket。<br>在这种做法中，内核告诉你一个文件描述符是否就绪了，然后你可以对这个就绪的fd进行IO操作。如果你不作任何操作，内核还是会继续通知你的。</p><h3 id="ET模式"><a href="#ET模式" class="headerlink" title="ET模式"></a>ET模式</h3><p>当epoll_wait检测到描述符事件发生并将此事件通知应用程序，应用程序必须立即处理该事件。如果不处理，下次调用epoll_wait时，不会再次响应应用程序并通知此事件。</p><p>ET(edge-triggered)是高速工作方式，只支持no-block socket。</p><p>在这种模式下，当描述符从未就绪变为就绪时，内核通过epoll告诉你然后它会假设你知道文件描述符已经就绪，并且不会再为那个文件描述符发送更多的就绪通知，直到你做了某些操作导致那个文件描述符不再为就绪状态了</p><ul><li>比如，你在发送，接收或者接收请求，或者发送接收的数据少于一定量时导致了一个EWOULDBLOCK 错误</li></ul><p>如果一直不对这个fd作IO操作(从而导致它再次变成未就绪)，内核不会发送更多的通知(only once)。</p><ul><li>ET模式在很大程度上减少了epoll事件被重复触发的次数，因此效率要比LT模式高。</li><li>epoll工作在ET模式的时候，必须使用非阻塞套接口，以避免由于一个文件句柄的阻塞读/阻塞写操作把处理多个文件描述符的任务饿死。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IO流 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IO多路复用</title>
      <link href="/posts/36405.html"/>
      <url>/posts/36405.html</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>IO多路复用是一种同步IO模型，实现一个线程可以监视多个文件句柄</p><ul><li>一旦某个文件句柄就绪，就能够通知应用程序进行相应的读写操作；</li><li>没有文件句柄就绪时会阻塞应用程序，交出cpu；</li><li>多路是指网络连接，复用指的是同一个线程。</li></ul><h2 id="三种实现方式"><a href="#三种实现方式" class="headerlink" title="三种实现方式"></a>三种实现方式</h2><h3 id="select"><a href="#select" class="headerlink" title="select"></a>select</h3><ul><li>时间复杂度O(n)，它仅仅知道了，有I/O事件发生了，却并不知道是哪那几个流（可能有一个，多个，甚至全部），</li><li>只能无差别轮询所有流，找出能读出数据，或者写入数据的流，对他们进行操作。</li><li>所以select具有O(n)的无差别轮询复杂度，同时处理的流越多，无差别轮询时间就越长。<h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">int</span> select <span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">,</span> fd_set <span class="token operator">*</span>readfds<span class="token punctuation">,</span> fd_set <span class="token operator">*</span>writefds<span class="token punctuation">,</span>             fd_set <span class="token operator">*</span>exceptfds<span class="token punctuation">,</span> struct timeval <span class="token operator">*</span>timeout<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li></ul><p>select 函数监视的文件描述符分3类，分别是writefds、readfds、和exceptfds。<br>调用后select函数会阻塞，直到有：</p><ul><li>描述符就绪（有数据可读、可写、或者有except）</li><li>超时（timeout指定等待时间，如果立即返回设为null即可）</li><li>函数返回。</li></ul><p>当select函数返回后，可以通过遍历fdset，来找到就绪的描述符。</p><h4 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h4><ul><li>良好的跨平台支持，select目前几乎在所有的平台上支持。</li><li>单个进程能够监视的文件描述符的数量存在最大限制，在Linux上一般为1024可以修改限制，但是这样也会造成效率的降低。</li></ul><h3 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h3><p>时间复杂度O(n)，poll本质上和select没有区别，它将用户传入的数组拷贝到内核空间，然后查询每个fd对应的设备状态， </p><ul><li>没有最大连接数的限制，原因是它是基于链表来存储的。</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">int</span> poll <span class="token punctuation">(</span>struct pollfd <span class="token operator">*</span>fds<span class="token punctuation">,</span> unsigned <span class="token keyword">int</span> nfds<span class="token punctuation">,</span> <span class="token keyword">int</span> timeout<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h4><p>poll使用一个 pollfd的指针实现。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">struct pollfd <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> fd<span class="token punctuation">;</span>            <span class="token comment">/* file descriptor */</span>    <span class="token keyword">short</span> events<span class="token punctuation">;</span>      <span class="token comment">/* requested events to watch */</span>    <span class="token keyword">short</span> revents<span class="token punctuation">;</span>     <span class="token comment">/* returned events witnessed */</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="优缺点-1"><a href="#优缺点-1" class="headerlink" title="优缺点"></a>优缺点</h4><p>pollfd结构包含了要监视的event和发生的event，不再使用select“参数-值”传递的方式。</p><ul><li>pollfd并没有最大数量限制（但是数量过大后性能也是会下降）</li><li>和select函数一样，poll返回后，需要轮询pollfd来获取就绪的描述符。</li></ul><h3 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h3><p>时间复杂度O(1)，epoll可以理解为event poll，不同于忙轮询和无差别轮询，epoll会把哪个流发生了怎样的I/O事件通知我们。</p><ul><li>epoll实际上是事件驱动（每个事件关联上fd）的，此时对这些流的操作都是有意义的。</li></ul><h4 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h4><p>epoll操作过程需要三个接口，分别如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">int</span> <span class="token function">epoll_create</span><span class="token punctuation">(</span><span class="token keyword">int</span> size<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">epoll_ctl</span><span class="token punctuation">(</span><span class="token keyword">int</span> epfd<span class="token punctuation">,</span> <span class="token keyword">int</span> op<span class="token punctuation">,</span> <span class="token keyword">int</span> fd<span class="token punctuation">,</span> struct epoll_event <span class="token operator">*</span>event<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">epoll_wait</span><span class="token punctuation">(</span><span class="token keyword">int</span> epfd<span class="token punctuation">,</span> struct epoll_event <span class="token operator">*</span> events<span class="token punctuation">,</span>                <span class="token keyword">int</span> maxevents<span class="token punctuation">,</span> <span class="token keyword">int</span> timeout<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">int</span> <span class="token function">epoll_create</span><span class="token punctuation">(</span><span class="token keyword">int</span> size<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>创建一个epoll的句柄，size用来告诉内核这个监听的数目一共有多大，这个参数不同于select()中的第一个参数，给出最大监听的fd+1的值</li><li>参数size并不是限制了epoll所能监听的描述符最大个数，只是对内核初始分配内部数据结构的一个建议。</li><li>当创建好epoll句柄后，它就会占用一个fd值，在使用完epoll后，必须调用close()关闭，否则可能导致fd被耗尽。</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">int</span> <span class="token function">epoll_ctl</span><span class="token punctuation">(</span><span class="token keyword">int</span> epfd<span class="token punctuation">,</span> <span class="token keyword">int</span> op<span class="token punctuation">,</span> <span class="token keyword">int</span> fd<span class="token punctuation">,</span> struct epoll_event <span class="token operator">*</span>event<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>函数是对指定描述符fd执行op操作。</p><ul><li>epfd：是epoll_create()的返回值。</li><li>op：表示op操作，用三个宏来表示，分别添加、删除和修改对fd的监听事件。<ul><li>添加EPOLL_CTL_ADD，</li><li>删除EPOLL_CTL_DEL，</li><li>修改EPOLL_CTL_MOD。</li></ul></li><li>fd：是需要监听的fd（文件描述符）</li><li>epoll_event：是告诉内核需要监听什么事，</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">int</span> <span class="token function">epoll_wait</span><span class="token punctuation">(</span><span class="token keyword">int</span> epfd<span class="token punctuation">,</span> struct epoll_event <span class="token operator">*</span> events<span class="token punctuation">,</span>                <span class="token keyword">int</span> maxevents<span class="token punctuation">,</span> <span class="token keyword">int</span> timeout<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>等待epfd上的io事件，最多返回maxevents个事件。</p><ul><li>参数events用来从内核得到事件的集合</li><li>maxevents告之内核这个events有多大，这个maxevents的值不能大于创建epoll_create()时的size，</li><li>参数timeout是超时时间（毫秒，0会立即返回，-1将不确定，也有说法说是永久阻塞）。该函数返回需要处理的事件数目，如返回0表示已超时。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IO流 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分布式事务之两阶段提交</title>
      <link href="/posts/47910.html"/>
      <url>/posts/47910.html</url>
      
        <content type="html"><![CDATA[<h2 id="两阶段提交协议"><a href="#两阶段提交协议" class="headerlink" title="两阶段提交协议"></a>两阶段提交协议</h2><ul><li>两阶段提交协议把分布式事务分为两个阶段，一个是准备阶段，另一个是提交阶段；</li><li>准备阶段和提交阶段都是由事务管理器发起的；</li><li>我们可以将事务管理器称为协调者，将资源管理器称为参与者。</li></ul><h2 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h2><h4 id="准备阶段："><a href="#准备阶段：" class="headerlink" title="准备阶段："></a>准备阶段：</h4><p>协调者向参与者发起指令，参与者评估自己的状态，如果参与者评估指令可以完成，则会写redo或者undo日志（Write-Ahead Log的一种），然后锁定资源，执行操作，但是并不提交。<br><img src="https://img-blog.csdnimg.cn/7f5ba60ae0344ac6af22a614986d0f71.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5rGf5rqq5rC0,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><h4 id="提交阶段："><a href="#提交阶段：" class="headerlink" title="提交阶段："></a>提交阶段：</h4><ul><li>如果每个参与者明确返回准备成功，也就是预留资源和执行操作成功，则协调者向参与者发起提交指令，参与者提交资源变更的事务，释放锁定的资源；</li><li>如果任何一个参与者明确返回准备失败，也就是预留资源或者执行操作失败，则协调者向参与者发起中止指令，参与者取消已经变更的事务，执行undo日志，释放锁定的资源。<img src="https://img-blog.csdnimg.cn/c4705696bb2f461aa55698bbd4fc8b19.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5rGf5rqq5rC0,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></li></ul><h2 id="存在问题"><a href="#存在问题" class="headerlink" title="存在问题"></a>存在问题</h2><p>两阶段提交协议在准备阶段锁定资源，这是一个非常损耗资源的操作，能保证强一致性，但是实现起来复杂、成本较高、不够灵活，更重要的是它有一些致命的问题</p><h4 id="阻塞："><a href="#阻塞：" class="headerlink" title="阻塞："></a>阻塞：</h4><p>从上面的描述来看，对于任何一次指令都必须收到明确的响应，才会继续进行下一步，否则处于阻塞状态，占用的资源被一直锁定，不会被释放。</p><h4 id="单点故障："><a href="#单点故障：" class="headerlink" title="单点故障："></a>单点故障：</h4><p>如果协调者宕机，参与者没有协调者指挥，则会一直阻塞，尽管可以通过选举新的协调者替代原有协调者，但是如果协调者在发送一个提交指令后宕机，而提交指令仅仅被一个参与者接收，并且参与者接收后也宕机，则新上任的协调者无法处理这种情况。</p><h4 id="脑裂："><a href="#脑裂：" class="headerlink" title="脑裂："></a>脑裂：</h4><p>协调者发送提交指令，有的参与者接收到并执行了事务，有的参与者没有接收到事务就没有执行事务，多个参与者之间是不一致的。</p><h4 id="数据状态不确定"><a href="#数据状态不确定" class="headerlink" title="数据状态不确定"></a>数据状态不确定</h4><p>协调者再发出commit消息之后宕机，而唯一接收到这条消息的参与者同时也宕机了。那么即使协调者通过选举协议产生了新的协调者，这条事务的状态也是不确定的，没人知道事务是否被已经提交。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>上面的问题发生的概论比较小，但都需要人工干预处理，没有自动化的解决方案，因此两阶段提交协议在正常情况下能保证系统的强一致性，但是在出现异常的情况下，当前处理的操作处于错误状态，需要人工干预解决，因此可用性不够好。</p>]]></content>
      
      
      <categories>
          
          <category> 分布式微服务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式事务 </tag>
            
            <tag> 数据一致性 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分布式事务之三阶段提交</title>
      <link href="/posts/38474.html"/>
      <url>/posts/38474.html</url>
      
        <content type="html"><![CDATA[<p>三阶段提交协议是两阶段提交协议的改进版本，它通过超时机制解决了阻塞的问题，并且把两个阶段增加为三个阶段。</p><h2 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h2><h4 id="询问阶段"><a href="#询问阶段" class="headerlink" title="询问阶段"></a>询问阶段</h4><p>协调者询问参与者是否可以完成指令，协调者只需要回答是或不是，而不需要做真正的操作，这个阶段超时会导致中止。<br><img src="https://img-blog.csdnimg.cn/94897bae453343b6ac1c56b83a55d314.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5rGf5rqq5rC0,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><h4 id="准备阶段"><a href="#准备阶段" class="headerlink" title="准备阶段"></a>准备阶段</h4><ul><li>如果在询问阶段所有参与者都返回可以执行操作，则协调者向参与者发送预执行请求，然后参与者写redo和undo日志，执行操作但是不提交操作；</li><li>如果在询问阶段任意参与者返回不能执行操作的结果，则协调者向参与者发送中止请求，这里的逻辑与两阶段提交协议的准备阶段是相似的。<br><img src="https://img-blog.csdnimg.cn/b04e26303c904cb9b78826d5b597b186.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5rGf5rqq5rC0,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></li></ul><h4 id="提交阶段"><a href="#提交阶段" class="headerlink" title="提交阶段"></a>提交阶段</h4><ul><li><p>如果每个参与者在准备阶段返回准备成功，也就是说预留资源和执行操作成功，则协调者向参与者发起提交指令，参与者提交资源变更的事务，释放锁定的资源；</p></li><li><p>如果任何参与者返回准备失败，也就是说预留资源或者执行操作失败，则协调者向参与者发起中止指令，参与者取消已经变更的事务，执行 undo 日志，释放锁定的资源，这里的逻辑与两阶段提交协议的提交阶段一致。<br><img src="https://img-blog.csdnimg.cn/1cdb4a63102844b5aa07b1aec7ca680d.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5rGf5rqq5rC0,size_20,color_FFFFFF,t_70,g_se,x_16" alt="三阶段提交协议的成功场景示意图如下图所示："></p><h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2></li><li><p>增加了一个询问阶段，询问阶段可以确保尽可能早地发现无法执行操作而需要中止的行为，但是它并不能发现所有这种行为，只会减少这种情况的发生。</p></li><li><p>在准备阶段以后，协调者和参与者执行的任务中都增加了超时，一旦超时，则协调者和参与者都会继续提交事务，默认为成功，这也是根据概率统计超时后默认为成功的正确性最大。</p></li><li><p>三阶段提交协议与两阶段提交协议相比，具有如上优点，但是一旦发生超时，系统仍然会发生不一致，只不过这种情况很少见，好处是至少不会阻塞和永远锁定资源。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 分布式微服务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式事务 </tag>
            
            <tag> 数据一致性 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RabbitMQ 如何保证消息不会被重复消费</title>
      <link href="/posts/13025.html"/>
      <url>/posts/13025.html</url>
      
        <content type="html"><![CDATA[<p>所有的消息队列都要保证同一条消息不会被重复消费</p><ul><li>举个例子：假设有个系统，消费一条往数据库里插入一条，要是你一个消息重复两次，你不就插入了两条，这数据就错了</li><li>所以消费到第二次的时候，自己判断一下已经消费过了，直接扔了，就保留了一条数据</li></ul><p>一条数据重复出现两次，数据库里就只有一条数据，这就保证了系统的幂等性幂等性。</p><ul><li>一个请求重复多次，需要确保对应的数据是不会改变的，不能出错。<h2 id="为什么会重复消费"><a href="#为什么会重复消费" class="headerlink" title="为什么会重复消费"></a>为什么会重复消费</h2>（1）生产者重复发送消息：生产者在往消息队列发送消息时，发生了网络抖动，生产者没有收到确认信号，但是实际上消息队列已经收到了消息，超过一定时间后生产者会重新发送消息，这时一条消息被发送了两次；<br>（2）消费者重复接受消息：消费者成功消费消息后，发生了网络抖动，消息队列没有收到确认信号，超过一段时间后会重新给消费者投递相同的消息，同一条消息即存在被消费两次的可能。</li></ul><h2 id="如何解决"><a href="#如何解决" class="headerlink" title="如何解决"></a>如何解决</h2><p>通用解决方案是在消息实体中添加全局唯一的id，例如 msg_id（消息ID），在代码中保证消息的幂等性，</p><ul><li>消费者在收到消息之后，根据 msg_id 从缓存或者数据库中查询是否存在已有消息；</li><li>如果不存在已有消息，那么消费之后，将 msg_id 对应的消息实体或者序列化对象写入缓存或者数据库；</li><li>如果存在已有消息，说明这条消息已被消费过，丢弃消息并且打一条告警日志。</li></ul><p>并且可以根据重复消费的容忍程度以及性能要求选择使用缓存还是使用数据库，</p><ul><li>如果对判断的速度要求高，可以使用 Redis 作为缓存；</li><li>如果对判断的稳定性和鲁棒性要求高，使用数据库存储消息实体，同时将 msg_id 作为数据库表的唯一键，插入重复记录一定会抛出异常，避免数据库因为并发问题产生脏数据，保证了消息消费的不可重复性。</li></ul><h2 id="结合业务分析"><a href="#结合业务分析" class="headerlink" title="结合业务分析"></a>结合业务分析</h2><ul><li>如果是对数据库进行写库，先根据主键查一下，如果这数据都有了，就不写入</li><li>如果是写redis，那没问题了，反正每次都是set，天然幂等性。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 消息队列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RabbitMQ </tag>
            
            <tag> 重复消费 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RabbitMQ如何保证消息顺序消费</title>
      <link href="/posts/56438.html"/>
      <url>/posts/56438.html</url>
      
        <content type="html"><![CDATA[<h2 id="为什么要顺序消费"><a href="#为什么要顺序消费" class="headerlink" title="为什么要顺序消费"></a>为什么要顺序消费</h2><p>保证消息的顺序消费是生产业务场景下经常面临的挑战，例如电商的下单逻辑，在用户下单之后，会发送创建订单和扣减库存的消息，我们需要保证扣减库存在创建订单之后执行。</p><ul><li>处理业务逻辑后，向MQ发送一条消息，再由消费者从 MQ 中获取 消息落盘到MySQL 中。</li><li>在这个过程中，可能会有增删改的操作，比如执行顺序是增加、修改、删除。</li><li>消费者可能换了顺序给执行成删除、修改、增加，所以我们要保证消息的顺序消费</li></ul><h2 id="为什么会不按顺序消费"><a href="#为什么会不按顺序消费" class="headerlink" title="为什么会不按顺序消费"></a>为什么会不按顺序消费</h2><p>对于 RabbitMQ 来说，导致上面顺序错乱的原因通常是消费者是集群部署，不同的消费者消费到了同一订单的不同的消息。</p><ul><li>如消费者1执行了增加，消费者2执行了修改，消费者C执行了删除</li><li>但是消费者C执行比消费者B快，消费者B又比消费者A快，就会导致消费消息的时候顺序错乱</li><li>本该顺序是增加、修改、删除，变成了删除、修改、增加.<br><img src="https://img-blog.csdnimg.cn/77a568c090d24eb68f041cd17126220b.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5rGf5rqq5rC0,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></li></ul><h2 id="如何解决"><a href="#如何解决" class="headerlink" title="如何解决"></a>如何解决</h2><p>RabbitMQ 的问题是由于不同的消息都发送到了同一个 queue 中，多个消费者都消费同一个 queue 的消息。</p><ul><li>我们可以给 RabbitMQ 创建多个 queue，每个消费者固定消费一个 queue 的消息，</li><li>生产者发送消息的时候，同一个类型的消息发送到同一个 queue 中</li><li>由于同一个 queue 的消息是一定会保证有序的，那么同一个订单号的消息就只会被一个消费者顺序消费，从而保证了消息的顺序性。<br><img src="https://img-blog.csdnimg.cn/d8c2d643644646f9be78cf4884a828ff.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5rGf5rqq5rC0,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></li></ul>]]></content>
      
      
      <categories>
          
          <category> 消息队列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RabbitMQ </tag>
            
            <tag> 顺序消费 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TCP的粘包和拆包</title>
      <link href="/posts/7157.html"/>
      <url>/posts/7157.html</url>
      
        <content type="html"><![CDATA[<h2 id="什么是粘包和拆包"><a href="#什么是粘包和拆包" class="headerlink" title="什么是粘包和拆包"></a>什么是粘包和拆包</h2><p>一个完整的业务数据包可能会被TCP拆分成多个包进行发送，也有可能把多个小的包封装成一个大的数据包发送，这个就是TCP的拆包和粘包问题。</p><h4 id="第一种情况-正常"><a href="#第一种情况-正常" class="headerlink" title="第一种情况(正常)"></a>第一种情况(正常)</h4><p>接收端正常收到两个数据包，即没有发生拆包和粘包的现象；</p><p><img src="https://img-blog.csdnimg.cn/0dd185d80ed7419c99f241e13d97b33c.png" alt="在这里插入图片描述"></p><h4 id="第二种情况"><a href="#第二种情况" class="headerlink" title="第二种情况"></a>第二种情况</h4><p>接收端只收到一个数据包，由于TCP是不会出现丢包的，所以这一个数据包中包含了发送端发送的两个数据包的信息，这种现象即为粘包。</p><p>这种情况由于接收端不知道这两个数据包的界限，所以对于接收端来说很难处理。<br><img src="https://img-blog.csdnimg.cn/5b0e17395ab0423a8b2c275fcf8de9eb.png" alt="在这里插入图片描述"></p><h4 id="第三种情况"><a href="#第三种情况" class="headerlink" title="第三种情况"></a>第三种情况</h4><p>接收端收到了两个数据包，但是这两个数据包要么是不完整的，要么就是多出来一块，这种情况即发生了拆包和粘包。<br><img src="https://img-blog.csdnimg.cn/2ebf028e7f7a404490314f5d6f41cd86.png" alt="在这里插入图片描述"><br>这两种情况如果不加特殊处理，对于接收端同样是不好处理的<br><img src="https://img-blog.csdnimg.cn/0b1efe60580848bca400bf9e802a7fef.png" alt="在这里插入图片描述"></p><h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><ol><li><p>应用程序写入的数据大于套接字缓冲区大小，这将会发生拆包。</p></li><li><p>应用程序写入数据小于套接字缓冲区大小，网卡将应用多次写入的数据发送到网络上，这将会发生粘包。</p></li><li><p>进行MSS（最大报文长度）大小的TCP分段，当TCP报文长度-TCP头部长度&gt;MSS的时候将发生拆包。</p></li><li><p>接收方法不及时读取套接字缓冲区数据，这将发生粘包。</p></li></ol><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><ol><li><p>发送端给每个数据包添加包首部，首部中应该至少包含数据包的长度，这样接收端在接收到数据后，通过读取包首部的长度字段，便知道每一个数据包的实际长度了。</p></li><li><p>发送端将每个数据包封装为固定长度（不够的可以通过补0填充），这样接收端每次从接收缓冲区中读取固定长度的数据就自然而然的把每个数据包拆分开来。</p></li><li><p>可以在数据包之间设置边界，如添加特殊符号，这样，接收端通过这个边界就可以将不同的数据包拆分开。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TCP/IP </tag>
            
            <tag> 粘包拆包 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于RedLock的分布式锁</title>
      <link href="/posts/38691.html"/>
      <url>/posts/38691.html</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>在单个主节点的架构上实现分布式锁，是无法保证高可用的，在生产环境上，我们的Redis都是以集群部署的；</p><p>那么如果Redis实现分布式锁的是一个主从集群，可能会发生什么情况呢？<br><img src="https://img-blog.csdnimg.cn/df7cdf3ffafb4a0aab070ad0ab176867.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5rGf5rqq5rC0,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><ul><li>如果进程A在主节点上加锁成功，然后这个主节点宕机了，则从节点将会晋升为主节点。</li><li>若此时进程B在新的主节点上加锁成功，之后原主节点重启，成为了从节点，系统中将同时出现两把锁，这是违背锁的唯一性原则的。</li></ul><h2 id="RedLock实现"><a href="#RedLock实现" class="headerlink" title="RedLock实现"></a>RedLock实现</h2><p>如果要保证分布式锁的高可用，则需要采用多个节点的实现方案。</p><p>Redis的官方给出的建议是采用RedLock算法的实现方案。该算法基于多个Redis节点</p><h4 id="基本流程"><a href="#基本流程" class="headerlink" title="基本流程"></a>基本流程</h4><ul><li>集群中的节点相互独立，不存在主从复制或者集群协调机制；</li><li>加锁：以相同的KEY向N个实例加锁，只要超过一半节点成功，则认定加锁成功；</li><li>解锁：向所有的实例发送DEL命令，进行解锁；<br><img src="https://img-blog.csdnimg.cn/6f1b548a5a5549dd8bc90cfff64a715b.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5rGf5rqq5rC0,size_16,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><h4 id="算法流程"><a href="#算法流程" class="headerlink" title="算法流程"></a>算法流程</h4></li></ul><ol><li><p>获取当前时间戳</p></li><li><p>client尝试按照顺序使用相同的key,value获取所有redis服务的锁，在获取锁的过程中的获取时间比锁过期时间短很多，这是为了不要过长时间等待已经关闭的redis服务。并且试着获取下一个redis实例。比如：TTL为5s,设置获取锁最多用1s，所以如果一秒内无法获取锁，就放弃获取这个锁，从而尝试获取下个锁</p></li><li><p>client通过获取所有能获取的锁后的时间减去第一步的时间，这个时间差要小于TTL时间并且至少有超过一半的redis实例成功获取锁，才算真正的获取锁成功</p></li><li><p>如果成功获取锁，则锁的真正有效时间是 TTL减去第三步的时间差 的时间；比如：TTL 是5s,获取所有锁用了2s,则真正锁有效时间为3s(其实应该再减去时钟漂移);</p></li><li><p>如果客户端由于某些原因获取锁失败，便会开始解锁所有redis实例；因为可能已经获取了小于一半的redis实例的锁，必须释放，否则影响其他client获取锁</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 缓存 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
            <tag> 分布式锁 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis实现分布式锁</title>
      <link href="/posts/2566.html"/>
      <url>/posts/2566.html</url>
      
        <content type="html"><![CDATA[<h2 id="什么是分布式锁"><a href="#什么是分布式锁" class="headerlink" title="什么是分布式锁"></a>什么是分布式锁</h2><p>分布式锁其实可以理解为:控制分布式系统有序的去对共享资源进行操作,通过互斥来保持一致性</p><h2 id="为什么要分布式锁"><a href="#为什么要分布式锁" class="headerlink" title="为什么要分布式锁"></a>为什么要分布式锁</h2><p>当多个线程需要并发修改一个数据时，为了避免竞争，在单机的情况下，加synchronized或者Lock即可实现互斥</p><p>但在分布式的环境下，当多个server并发修改同一个资源时，为了避免竞争就需要使用分布式锁。</p><p>那为什么不能使用Java自带的锁（synchronized或者Lock）呢？</p><ul><li>因为Java中的锁是面向多线程设计的，它只局限于当前的实例。</li><li>而多个server实际上是多进程，是不同的实例，所以Java自带的锁机制在这个场景下是无效的。</li></ul><h2 id="如何实现分布式锁"><a href="#如何实现分布式锁" class="headerlink" title="如何实现分布式锁"></a>如何实现分布式锁</h2><p>采用Redis实现分布式锁，就是在Redis里存一份代表锁的数据，通常用随机字符串即可。</p><h3 id="加锁："><a href="#加锁：" class="headerlink" title="加锁："></a>加锁：</h3><h4 id="第一种方式"><a href="#第一种方式" class="headerlink" title="第一种方式"></a>第一种方式</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">setnx key value<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这种方式的缺点是容易产生死锁，因为客户端有可能忘记解锁，或者解锁失败。</p><h4 id="第二种方式"><a href="#第二种方式" class="headerlink" title="第二种方式"></a>第二种方式</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">setnx key valueexpire key seconds<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>给锁增加了过期时间，避免出现死锁。但这两个命令不是原子的，第二步可能会失败，依然无法避免死锁问题。</p><h4 id="第三种方式"><a href="#第三种方式" class="headerlink" title="第三种方式"></a>第三种方式</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">set key value nx ex seconds <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>通过“set…nx…”命令，将加锁、过期命令编排到一起，它们是原子操作了，可以避免死锁。</p><h3 id="解锁："><a href="#解锁：" class="headerlink" title="解锁："></a>解锁：</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">del key<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>解锁就是删除代表锁的那份数据，直接删除redis上面的数据。</p><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>上述方法看起来没有问题，但实际是有隐患的<br><img src="https://img-blog.csdnimg.cn/4678bef1efc04094b02729431c2069d8.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5rGf5rqq5rC0,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><ol><li>进程A在任务没有执行完毕时，锁已经到期被释放了。</li><li>等进程A的任务执行结束后，A会尝试释放锁，但是，它的锁已经过期不存在了，它此时释放的可能是其他线程的锁，比如B进程；</li><li>红框时间内，两个进程同时操作数据，极有可能出现线程安全的问题；</li></ol><h3 id="如何解决"><a href="#如何解决" class="headerlink" title="如何解决"></a>如何解决</h3><p>在加锁时就要给锁设置一个标识，加锁进程要记住这个标识。</p><ul><li>当进程解锁的时候，进行判断，是自己持有的锁才能释放</li><li>否则无法释放。可以为key设置一个随机字符串，来充当进程的标识。</li></ul><p>但是解锁的时候，判断、释放，这两步需要保证原子性，否则第二步失败的话，就会出现死锁，但判断和删除命令不是原子的。</p><p>在Redis中可以使用Lua脚本，通过Lua脚本将两个命令编排在一起，而整个Lua脚本的执行是原子的。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"># 加锁set key random<span class="token operator">-</span>value nx ex seconds # 解锁<span class="token keyword">if</span> redis<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token string">"get"</span><span class="token punctuation">,</span>KEYS<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">==</span> ARGV<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> then    <span class="token keyword">return</span> redis<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token string">"del"</span><span class="token punctuation">,</span>KEYS<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">else</span>    <span class="token keyword">return</span> <span class="token number">0</span>end<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 缓存 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
            <tag> 分布式锁 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL的执行计划(三)</title>
      <link href="/posts/32865.html"/>
      <url>/posts/32865.html</url>
      
        <content type="html"><![CDATA[<p>书接上回 <a href="https://blog.csdn.net/upstream480/article/details/120615700">MySQL的执行计划(二)</a></p><h2 id="执行计划中的列"><a href="#执行计划中的列" class="headerlink" title="执行计划中的列"></a>执行计划中的列</h2><h3 id="possible-keys"><a href="#possible-keys" class="headerlink" title="possible_keys"></a>possible_keys</h3><p>显示在查询中使用了哪些索引<br><img src="https://img-blog.csdnimg.cn/75296e9e4b8f420498f3a01f1015d330.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5rGf5rqq5rC0,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><h3 id="key"><a href="#key" class="headerlink" title="key"></a>key</h3><ul><li>实际使用的索引，如果为NULL，则没有使用索引；</li><li>查询中如果使用了覆盖索引，则该索引仅出现在key列中。<br><img src="https://img-blog.csdnimg.cn/bbf4082c4e8447c8b4ac51dab855ed62.png" alt="在这里插入图片描述"></li><li>possible_keys列表明哪一个索引有助于更高效的查询；</li><li>key是possible_keys的子集；</li><li>而key列表明实际优化采用了哪一个索引可以更加高效。</li></ul><h3 id="key-len"><a href="#key-len" class="headerlink" title="key_len"></a>key_len</h3><p>表示索引中使用的字节数，查询中使用的索的长度（最大可能长度），并非实际使用长度，理论上长度越短越好。</p><ul><li>key_len是根据表定义计算而得的，不是通过表内查询出来的</li><li>这个字段可以评估组合索引是否完全被使用，这也是我们优化sql时，评估索引的重要指标</li></ul><h3 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h3><ul><li>表示在key列记录的索引中查找值，所用的列或常量const。</li></ul><h3 id="rows"><a href="#rows" class="headerlink" title="rows"></a>rows</h3><p>估算出找到所需行而要读取的行数<br><img src="https://img-blog.csdnimg.cn/f6c9cad466c64e429d039525b18704dc.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5rGf5rqq5rC0,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>这个数字是内嵌循环关联计划里的循环数，它不是最终从表中读取出来的行数，而是MySQL为了找到符合查询的那些行而必须读取行的平均数，只能作为一个相对数来进行衡量。</p><ul><li>估算该sql返回结果集需要扫描读取的行数，这个值相关重要；</li><li>索引优化之后，扫描读取的行数越多，说明要么是索引设置不对，要么是字段传入的类型之类的问题，说明要优化空间越大</li></ul><h3 id="filtered"><a href="#filtered" class="headerlink" title="filtered"></a>filtered</h3><ul><li>返回结果的行数占读取行数的百分比，值越大越好；</li><li>百分比越高，说明需要查询到数据越准确；</li><li>百分比越小，说明查询到的数据量大，而结果集很少。</li></ul><h3 id="extra"><a href="#extra" class="headerlink" title="extra"></a>extra</h3><p>额外信息</p><p><strong>Using index</strong><br>表示SQL中使用了覆盖索引。<br><img src="https://img-blog.csdnimg.cn/e759b9b2122e427f9744249ce088b986.png" alt="在这里插入图片描述"></p><p><strong>Using where</strong><br>许多where条件里是涉及索引中的列，当它读取索引时，就能被存储引擎检验，因此不是所有带·where子句的查询都会显示“Using where”。<br><img src="https://img-blog.csdnimg.cn/4347858fe7c64a4da610448b50cdcfa8.png" alt="在这里插入图片描述"></p><p><strong>Using temporary</strong></p><ul><li>对查询结果排序时，使用了一个临时表，常见于order by 和group by<br><img src="https://img-blog.csdnimg.cn/0ba88e162d504c368a7be2cf126e2308.png" alt="在这里插入图片描述"></li></ul><p><strong>Using filesort</strong></p><ul><li>对数据使用了一个外部的索引排序，而不是按照表内的索引进行排序读取；</li><li>MySQL无法利用索引完成的排序操作成为“文件排序”。<br><img src="https://img-blog.csdnimg.cn/93c3a906083f4366af3623533e092f44.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5rGf5rqq5rC0,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
            <tag> 执行计划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis-有序集合的数据结构</title>
      <link href="/posts/22919.html"/>
      <url>/posts/22919.html</url>
      
        <content type="html"><![CDATA[<h2 id="集合概念"><a href="#集合概念" class="headerlink" title="集合概念"></a>集合概念</h2><h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><p>Set类似于Java中的HashSet 。Redis中的set类型是一种无序集合，集合中的元<br>素没有先后顺序，并且不可重复。</p><p>当需要存储一个列表数据，又不不能出现重复数据时，Set 是一个很好的选择，并且set提供了判断某个成员是否在一个Set集合内的接口，List是没有这种接口的</p><p>可以基于set轻易实现交集、并集、差集的操作。Redis 可以非常方便的实现如共同关注、共同粉丝、共同喜好等功能。这个过程也就是求交集的过程。</p><h3 id="Zset"><a href="#Zset" class="headerlink" title="Zset"></a>Zset</h3><p>和Set相比，sorted set增加了一个权重参数score, 使得集合中的元素能够按score<br>进行有序排列，还可以通过score的范围来获取元素的列表。有点像是Java中HashMap和TreeSet的结合体。</p><p>其有两种实现方式，分别是ziplist和skiplist</p><h2 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h2><p>当有序集合保存的元素数量小于128个或者有序集合保存的所有元素的长度小于64字节时，Zset选用ziplist实现，其他情况选用skiplist实现；</p><h3 id="ziplist-压缩列表"><a href="#ziplist-压缩列表" class="headerlink" title="ziplist - 压缩列表"></a>ziplist - 压缩列表</h3><p>ziplist，顾名思义压缩列表，每个集合元素使用两个紧挨在一起的压缩列表节点来保存，第一个节点保存元素的value，第二个元素保存元素的score；<br><img src="https://img-blog.csdnimg.cn/c4876263c60945998016ba6c5f3e7889.png" alt="在这里插入图片描述"></p><h3 id="skiplist-跳表"><a href="#skiplist-跳表" class="headerlink" title="skiplist - 跳表"></a>skiplist - 跳表</h3><p>跳表(skip List)是一种随机化的数据结构，基于并联的链表，实现简单，插入、删除、查找的复杂度均为logn。</p><p>简单说来跳表也是链表的一种，只不过它在链表的基础上增加了跳跃功能，正是这个跳跃的功能，使得在查找元素时，跳表能够提供logn的时间复杂度</p><p>普通链表<br><img src="https://img-blog.csdnimg.cn/92511fe8120b48a1af0a80a8a2c0f349.png" alt="在这里插入图片描述"></p><p>在普通链表中，如果我们要查找某个元素，那么需要从头开始逐个进行比较，直到找到包含数据的那个节点，或者找完所有的节点（没找到）。</p><ul><li>这样的话，时间复杂度为O(n)；</li><li>当我们要插入新数据的时候，也要经历同样的查找过程，从而确定插入位置</li></ul><p>跳表</p><p><img src="https://img-blog.csdnimg.cn/01ce37da07c940b6b717e644c524d5f4.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5rGf5rqq5rC0,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><p>假如我们每相邻两个节点增加一个指针，让指针指向下下个节点，如上图，比如节点是1 - 2 - 3 - 4 - 5，增加节点1 - 3 - 5</p><p>这样形成一个新的链表，但它包含的节点个数只有原来的一半1，3，5</p><ul><li>当我们想查找数据的时候，可以先沿着这个新链表进行查找。当碰到比待查数据大的节点时，再回到原来的链表中进行查找。</li><li>比如查找3，之间可用从1指向3，即可跳过2，当数据量大的时候，只需要查询原有数据量的一半</li></ul><p>利用同样的方式，我们可以在上层新产生的链表上，继续为每相邻的两个节点增加一个指针，从而产生第三层链表。<br><img src="https://img-blog.csdnimg.cn/9e80530dd5324377ae5aa097a26751a4.png" alt="在这里插入图片描述"><br>依次类推，当链表足够长的时候，这种多层链表的查找方式能让我们跳过很多下层节点，大大加快查找的速度。</p><p>skiplist正是受这种多层链表的想法的启发而设计出来的。实际上，按照上面生成链表的方式，上面每一层链表的节点个数，是下面一层的节点个数的一半，这样查找过程就非常类似于一个二分查找，使得查找的时间复杂度可以降低到O(log n)。</p><h3 id="存在问题"><a href="#存在问题" class="headerlink" title="存在问题"></a>存在问题</h3><p>这种数据结构可用加快查询速度，但是在插入删除数据是就会出现问题</p><ul><li>新插入一个节点之后，就会打乱上下相邻两层链表上节点个数严格的2:1的对应关系。</li><li>如果要维持这种对应关系，就必须把新插入的节点后面的所有节点（也包括新插入的节点）重新进行调整，这会让时间复杂度重新蜕化成O(n)。</li><li>删除数据也有同样的问题。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 缓存 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
            <tag> 有序集合 </tag>
            
            <tag> 跳表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL的执行计划(二)</title>
      <link href="/posts/4291.html"/>
      <url>/posts/4291.html</url>
      
        <content type="html"><![CDATA[<p>书接上回：<a href="https://blog.csdn.net/upstream480/article/details/120615005">MySQL执行计划(一)</a></p><h2 id="执行计划中的列"><a href="#执行计划中的列" class="headerlink" title="执行计划中的列"></a>执行计划中的列</h2><h3 id="type"><a href="#type" class="headerlink" title="type"></a>type</h3><p>type列指代访问类型，是MySQL决定如何查找表中的行。</p><p>是SQL查询优化中一个很重要的指标，拥有很多值，依次从最差到最优：</p><h4 id="ALL"><a href="#ALL" class="headerlink" title="ALL"></a>ALL</h4><p>全表扫描，性能最差，在写SQL时尽量避免此种情况的出现，也就是避免是</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://img-blog.csdnimg.cn/e83044a80d254d0fb5fc9357bb7e521c.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5rGf5rqq5rC0,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><h4 id="index"><a href="#index" class="headerlink" title="index"></a>index</h4><p>全索引查询，和全表查询的ALL类似，但是扫描表时按索引次序进行（遍历索引树），而不是按行扫描</p><p>index与ALL虽然都是读全表，但index是从索引中读取，而ALL是从硬盘读取。<br>显然，index性能上明显优于ALL，所有，合理的添加索引将有助于提升性能。</p><p>举例如下：<br><img src="https://img-blog.csdnimg.cn/2fabd07cdb3d4966b999143de1a18214.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5rGf5rqq5rC0,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><h4 id="range"><a href="#range" class="headerlink" title="range"></a>range</h4><p>只查询给定范围的行，使用一个索引来选择行。</p><ul><li>key列显示使用了那个索引；</li><li>一般就是在where语句中出现了bettween、&lt;、&gt;、in等的查询；</li><li>这种索引列上的范围扫描比全索引扫描index要好。<img src="https://img-blog.csdnimg.cn/623618fb584d447e96dd743f8d47c7ee.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5rGf5rqq5rC0,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><h4 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h4>非唯一性索引扫描，返回匹配某个单独值的所有行。本质是也是一种索引访问，它返回所有匹配某个单独值的行，然而它可能会找到多个符合条件的行，所以它属于查找和扫描的混合体。</li></ul><p>此类型只有当使用非唯一索引或者唯一索引的非唯一性前缀时，才会发生。<br><img src="https://img-blog.csdnimg.cn/0d76d82b62b14e6dbdb453d2a7e561c0.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5rGf5rqq5rC0,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><h4 id="eq-ref"><a href="#eq-ref" class="headerlink" title="eq_ref"></a>eq_ref</h4><ul><li>唯一索引扫描</li><li>主要用于主键或唯一索引扫描。</li></ul><h4 id="const"><a href="#const" class="headerlink" title="const"></a>const</h4><ul><li>通过索引一次就能找到，const用于比较primary key 或者unique索引。</li><li>因为只需匹配一行数据，所有很快。</li><li>将主键置于where列表中，mysql就能将该查询转换为一个const。<br><img src="https://img-blog.csdnimg.cn/accbeada941a4b16ada04d80985d3232.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5rGf5rqq5rC0,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></li></ul><h4 id="system"><a href="#system" class="headerlink" title="system"></a>system</h4><ul><li>表只有一行记录，这是const类型的特例，比较少见。</li></ul><p>下一篇<br><a href="https://blog.csdn.net/upstream480/article/details/120616953">MySQL执行计划(三)</a></p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
            <tag> 执行计划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL的执行计划(一)</title>
      <link href="/posts/53351.html"/>
      <url>/posts/53351.html</url>
      
        <content type="html"><![CDATA[<h2 id="什么是执行计划"><a href="#什么是执行计划" class="headerlink" title="什么是执行计划"></a>什么是执行计划</h2><p>执行计划，就是一条SQL语句，在数据库中实际执行的时候，一步步的分别都做了什么事情</p><p>EXPLAIN命令是查看查询优化器是如何决定执行查询的主要方法，从它的查询结果中我们可以知道：</p><ul><li>一个SQL语句每一步是如何执行的；</li><li>都做了哪些事，分为哪几步；</li><li>有没有用到索引；</li><li>哪些字段用到了什么样的索引，是否有一些可优化的地方等。</li></ul><p>查看执行计划，只需在查询中的SELECT关键字之前增加EXPLAIN即可</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">语法：<span class="token keyword">EXPLAIN</span> <span class="token operator">+</span> <span class="token keyword">SELECT</span>查询语句示例：<span class="token keyword">EXPLAIN</span> <span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> <span class="token punctuation">`</span><span class="token keyword">user</span><span class="token punctuation">`</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>使用EXPLAIN时，会返回执行计划中每一步的信息，它会返回一行或多行信息，显示出执行计划中的每一部分和执行的次序。</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">EXPLAIN</span> <span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> <span class="token punctuation">`</span><span class="token keyword">user</span><span class="token punctuation">`</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://img-blog.csdnimg.cn/65163a07c98048638d4dfab62c0045a8.png" alt="在这里插入图片描述"></p><h2 id="执行计划中的列"><a href="#执行计划中的列" class="headerlink" title="执行计划中的列"></a>执行计划中的列</h2><p><img src="https://img-blog.csdnimg.cn/bb0128492f804b059e162e8af194fd0a.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5rGf5rqq5rC0,size_15,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><h3 id="Id"><a href="#Id" class="headerlink" title="Id"></a>Id</h3><p>id是一个编号，用于标识SELECT查询的序列号，表示执行SQL查询过程中SELECT子句或操作表的顺序。</p><ul><li>如果在SQL语句中没有子查询或关联查询，那么id列为1</li><li>否则，内层的SELECT语句一般会顺序编号；</li></ul><p>Id列可能会存在三种情况，以下一一列举：</p><h4 id="Id相同"><a href="#Id相同" class="headerlink" title="Id相同"></a>Id相同</h4><p>只有普通的查询，没有子查询，则Id相同为1</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">EXPLAIN</span> <span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> <span class="token punctuation">`</span><span class="token keyword">user</span><span class="token punctuation">`</span><span class="token punctuation">,</span><span class="token punctuation">`</span><span class="token keyword">comment</span><span class="token punctuation">`</span> <span class="token keyword">WHERE</span> <span class="token punctuation">`</span><span class="token keyword">comment</span><span class="token punctuation">`</span><span class="token punctuation">.</span>user_id <span class="token operator">=</span> <span class="token punctuation">`</span><span class="token keyword">user</span><span class="token punctuation">`</span><span class="token punctuation">.</span>id<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://img-blog.csdnimg.cn/057a89f6b571498fbefb5f821a4145a2.png" alt="在这里插入图片描述"></p><h4 id="Id不同"><a href="#Id不同" class="headerlink" title="Id不同"></a>Id不同</h4><p>存在子查询，id的序号会递增，id值越大优先级越高，越先被执行。</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">EXPLAIN</span> <span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> <span class="token punctuation">`</span><span class="token keyword">user</span><span class="token punctuation">`</span> <span class="token keyword">WHERE</span> id <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">SELECT</span> user_id <span class="token keyword">FROM</span> <span class="token punctuation">`</span><span class="token keyword">comment</span><span class="token punctuation">`</span> <span class="token keyword">WHERE</span> entity_type <span class="token operator">=</span> <span class="token number">2</span> <span class="token keyword">LIMIT</span> <span class="token number">1</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="https://img-blog.csdnimg.cn/310ff579697e43a497a2a7970fc28bb4.png" alt="在这里插入图片描述"></p><h4 id="Id相同和不同"><a href="#Id相同和不同" class="headerlink" title="Id相同和不同"></a>Id相同和不同</h4><p>id如果相同，认为是一组，从从上往下执行。<br>在所有组中，id值越大，优先级越高，越先执行。</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">EXPLAIN</span> <span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> <span class="token punctuation">`</span><span class="token keyword">user</span><span class="token punctuation">`</span> <span class="token keyword">WHERE</span> id <span class="token operator">IN</span> <span class="token punctuation">(</span><span class="token keyword">SELECT</span> user_id <span class="token keyword">FROM</span> <span class="token punctuation">`</span><span class="token keyword">comment</span><span class="token punctuation">`</span> <span class="token keyword">WHERE</span> entity_type <span class="token operator">=</span> <span class="token number">2</span> <span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="https://img-blog.csdnimg.cn/03a08fc0cd824c5181da896aabfb1815.png" alt="在这里插入图片描述"></p><h3 id="select-type列"><a href="#select-type列" class="headerlink" title="select_type列"></a>select_type列</h3><p>select_type列表示对应行的查询类型，是简单查询还是复杂查询</p><ul><li>主要用于区分普通查询、联合查询、子查询等复杂的查询。<br><img src="https://img-blog.csdnimg.cn/522f97c08a8d423a881a4973d547b41d.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5rGf5rqq5rC0,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><h3 id="table"><a href="#table" class="headerlink" title="table"></a>table</h3>table列表示对应行正在执行的哪张表，指代对应表名</li><li>如果SQL中定义了别名，则会显示该表的别名</li></ul><h3 id="partitions"><a href="#partitions" class="headerlink" title="partitions"></a>partitions</h3><ul><li>查询涉及到的分区。</li></ul><p>下一篇</p><p><a href="https://blog.csdn.net/upstream480/article/details/120615700">MySQL执行计划(二)</a></p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
            <tag> 执行计划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL的日志文件</title>
      <link href="/posts/37943.html"/>
      <url>/posts/37943.html</url>
      
        <content type="html"><![CDATA[<h2 id="二进制日志-binlog"><a href="#二进制日志-binlog" class="headerlink" title="二进制日志-binlog"></a>二进制日志-binlog</h2><p>二进制日志-binlog，它是 MySQL 重要的日志模块，在 Server 层实现</p><p>binlog 以二进制形式，将所有修改数据的 query 记录到日志文件中，包括：</p><ul><li>query 语句</li><li>执行时间</li><li>相关事务信息</li></ul><p>binlog 的开启，通过在配置文件 my.cnf 中，显式指定参数 log-bin=file_name</p><ul><li>statement记录的是SQL语句，最后会有COMMIT。</li><li>row记录的实际操作的数据记录，最后会有一个XID event。<h3 id="binlog的三种工作模式"><a href="#binlog的三种工作模式" class="headerlink" title="binlog的三种工作模式"></a>binlog的三种工作模式</h3><h4 id="Row-level："><a href="#Row-level：" class="headerlink" title="Row level："></a>Row level：</h4>日志中会记录每一行数据被修改的情况，然后在slave端对相同的数据进行修改。</li><li>优点：能清楚的记录每一行数据修改的细节</li><li>缺点：数据量太大<h4 id="Statement-level（默认）"><a href="#Statement-level（默认）" class="headerlink" title="Statement level（默认）"></a>Statement level（默认）</h4>每一条被修改数据的sql都会记录到master的bin-log中，slave在复制的时候sql进程会解析成和原来master端执行过的相同的sql再次执行。在主从同步中一般是不建议用statement模式的，因为会有些语句不支持，比如语句中包含UUID函数，以及LOAD DATA IN FILE语句等</li><li>优点：解决了 Row level下的缺点，不需要记录每一行的数据变化，减少bin-log日志量，节约磁盘IO，提高新能</li><li>缺点：容易出现主从复制不一致<h3 id="Mixed（混合模式）"><a href="#Mixed（混合模式）" class="headerlink" title="Mixed（混合模式）"></a>Mixed（混合模式）</h3>结合了Row level和Statement level的优点，但结构也更复杂。<h3 id="binlog的结构"><a href="#binlog的结构" class="headerlink" title="binlog的结构"></a>binlog的结构</h3></li><li><strong>timestamp</strong> 事件开始的执行时间，固定4字节展示是新纪元(epoch time)以来的秒数</li><li><strong>Event</strong> Type 指明该事件的类型</li><li><strong>server_ id</strong> 服务器的server ID</li><li><strong>Event size</strong> 该事件的长度</li><li><strong>Next_ log pos</strong> 固定4字节下一个event的开始位置</li><li><strong>Flag</strong>   固定2字节event flags</li><li><strong>Fixed part</strong> 每种Event Type对应结构体固定的结构部分</li><li><strong>Variable part</strong> 每种Event Type对应结构体可变的结构部分</li></ul><h2 id="重做日志-redo-log"><a href="#重做日志-redo-log" class="headerlink" title="重做日志-redo log"></a>重做日志-redo log</h2><p>redo log是存储引擎 InnoDB 生成的日志，主要为了保证数据的可靠性。redo log 记录了 InnoDB 所做的所有物理变更和事务信息。<br>由两部分组成：</p><ul><li>一是内存中的重做日志缓冲（redo log buffer），其是易失的；</li><li>二是重做日志文件（redo log file），它是持久的</li></ul><h2 id="binlog和redolog的区别"><a href="#binlog和redolog的区别" class="headerlink" title="binlog和redolog的区别"></a>binlog和redolog的区别</h2><ol><li>redolog是在InnoDB存储引擎层产生，而binlog是MySQL数据库的上层服务层产生的。</li><li>两种日志记录的内容形式不同。MySQL的binlog是逻辑日志，其记录是对应的SQL语句，对应的事务。而innodb存储引擎层面的重做日志是物理日志，是关于每个页（Page）的更改的物理情况。</li><li>两种日志与记录写入磁盘的时间点不同，binlog日志只在事务提交完成后进行一次写入。而innodb存储引擎的重做日志在事务进行中不断地被写入，并日志不是随事务提交的顺序进行写入的。</li><li>binlog不是循环使用，在写满或者重启之后，会生成新的binlog文件，redolog是循环使用。</li><li>binlog可以作为恢复数据使用，主从复制搭建，redolog作为异常宕机或者介质故障后的数据恢复使用。</li></ol><h2 id="回滚日志-undo-log"><a href="#回滚日志-undo-log" class="headerlink" title="回滚日志-undo log"></a>回滚日志-undo log</h2><p>重做日志记录了事务的行为，可以很好地通过其对页进行“重做”操作。<br>但是事务有时还需要进行回滚操作，这时就需要undo。因此在对数据库进行修改时，InnoDB存储引擎不但会产生redo，还会产生一定量的undo。这样如果用户执行的事务或语句由于某种原因失败了，又或者用户用一条ROLLBACK语句请求回滚，就可以利用这些undo信息将数据回滚到修改之前的样子。</p><p>redo存放在重做日志文件中，与redo不同，undo存放在数据库内部的一个特殊段（segment）中，这个段称为undo段（undo segment），undo段位于共享表空间内。</p><h2 id="错误日志-error-log"><a href="#错误日志-error-log" class="headerlink" title="错误日志-error log"></a>错误日志-error log</h2><p>错误日志，记录 MySQL 每次启动关闭的详细信息，以及运行过程中比较严重的警告和错误信息。</p><h2 id="慢查询日志-slow-query-log"><a href="#慢查询日志-slow-query-log" class="headerlink" title="慢查询日志-slow query log"></a>慢查询日志-slow query log</h2><p>慢查询日志，记录 MySQL 中执行时间较长的 query，包括执行时间、执行时长、执行用户、主机等信息。</p><p>慢查询日志默认是关闭的，可以通过配置 slow_query_log 进行开启。慢查询的阈值和存储路径，通过配置参数 long_query_time 和 slow_query_log_file 实现。</p><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">slow_query_log = 1                              #开启慢查询long_query_time = 1                             #设置慢查询阈值为1sslow_query_log_file = /mysql/log/mysql-slow.log #设置慢查询日志存储路径<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
            <tag> 日志 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java的IO流</title>
      <link href="/posts/33363.html"/>
      <url>/posts/33363.html</url>
      
        <content type="html"><![CDATA[<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="同步和异步"><a href="#同步和异步" class="headerlink" title="同步和异步"></a>同步和异步</h3><p>同步和异步是通信机制</p><ul><li><strong>同步</strong>：同步IO是用户线程发起IO请求后需要等待或轮询内核IO操作完成后才能继续执行。</li><li><strong>异步</strong>：异步IO是用户线程发起IO请求后可以继续执行，当内核IO操作完成后会通知用户线程，或调用用户线程注册的回调函数。</li></ul><h2 id="阻塞和非阻塞"><a href="#阻塞和非阻塞" class="headerlink" title="阻塞和非阻塞"></a>阻塞和非阻塞</h2><p>阻塞和非阻塞是调用状态</p><ul><li><strong>阻塞</strong>：阻塞IO是IO操作需要彻底完成后才能返回用户空间。</li><li><strong>非阻塞</strong>：非阻塞IO是IO操作调用后立即返回一个状态值，无需等IO操作彻底完成。</li></ul><h2 id="BIO"><a href="#BIO" class="headerlink" title="BIO"></a>BIO</h2><p>BIO是同步阻塞式IO，是JDK1.4 之前的IO模型。</p><ul><li>服务器实现模式为一个连接请求对应一个线程，服务器需要为每一个客户端请求创建一个线程，如果这个连接不做任何事会造成不必要的线程开销。</li><li>可以通过线程池改善，这种IO称为伪异步IO。适用连接数目少且服务器资源多的场景。</li></ul><h2 id="NIO"><a href="#NIO" class="headerlink" title="NIO"></a>NIO</h2><p>NIO是同步非阻塞IO，JDK1.4引入。服务器实现模式为多个连接请求对应一个线程，客户端连接请求会注册到一个多路复用器Selector，Selector 轮询到连接有IO请求时才启动一个线程处理。适用连接数目多且连接时间短的场景。</p><ul><li>同步是指线程还是要不断接收客户端连接并处理数据</li><li>非阻塞是指如果一个管道没有数据，不需要等待，可以轮询下一个管道。</li></ul><p>核心组件<br><img src="https://img-blog.csdnimg.cn/998e97c315244aa8a478105aac7f055b.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5rGf5rqq5rC0,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><h4 id="Selector"><a href="#Selector" class="headerlink" title="Selector"></a>Selector</h4><p>多路复用器，轮询检查多个Channel的状态，判断注册事件是否发生，即判断<br>Channel是否处于可读或可写状态。使用前需要将Channel注册到Selector，注册后会得到一个SelectionKey，通过SelectionKey获取Channel和Selector相关信息。</p><h4 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h4><p>双向通道，替换了BIO 中的Stream流，不能直接访问数据，要通过Buffer来读写数据，也可以和其他Channel交互。<br><img src="https://img-blog.csdnimg.cn/edee367f257d4e99bed4bd022bd46dd6.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5rGf5rqq5rC0,size_17,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><h4 id="Buffer"><a href="#Buffer" class="headerlink" title="Buffer"></a>Buffer</h4><p><img src="https://img-blog.csdnimg.cn/f0d063ff0fac40a88dfc149007f61bf0.png" alt="在这里插入图片描述"></p><p>缓冲区，本质是一块可读写数据的内存，用来简化数据读写。<br>Buffer三个重要属性：</p><ul><li>position下次读写数据的位置</li><li>limit 本次读写的极限位置</li><li>capacity 最大容量<ul><li>flip将写转为读，底层实现原理把position置0，并把limit设为当前的position值</li><li>clear将读转为写模式(用于读完全部数据的情况，把position置0，limit设为capacity)</li><li>compact将读转为写模式(用于存在未读数据的情况，让position指向未读数据的下一个)</li><li>通道方向和Buffer方向相反，读数据相当于向Buffer写，写数据相当于从Buffer读</li></ul></li></ul><p>使用步骤</p><ul><li>向Buffer写数据，调用flip方法转为读模式；</li><li>从Buffer中读数据，调用clear或compact方法清空缓冲区；</li></ul><h2 id="AIO"><a href="#AIO" class="headerlink" title="AIO"></a>AIO</h2><p>异步非阻塞IO，JDK1.7引入，服务器实现模式为一个有效请求对应一个线程，客户端的IO请求都是由操作系统先完成IO操作后再通知服务器应用来直接使用准备好的数据。适用连接数目多且连接时间长的场景。</p><ul><li>异步是指服务端线程接收到客户端管道后就交给底层处理IO通信，自己可以做其他事情</li><li>非阻塞是指客户端有数据才会处理，处理好再通知服务器。</li></ul><h4 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h4><ul><li>通过Future的get方法进行阻塞式调用</li><li>实现CompletionHandler接口，重写请求成功的回调方法completed 和请求失败回调方法failed </li></ul>]]></content>
      
      
      <categories>
          
          <category> 多线程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IO流 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Bean的作用域和生命周期</title>
      <link href="/posts/48887.html"/>
      <url>/posts/48887.html</url>
      
        <content type="html"><![CDATA[<h2 id="Spring-Bean的作用域"><a href="#Spring-Bean的作用域" class="headerlink" title="Spring Bean的作用域"></a>Spring Bean的作用域</h2><p>Spring 为Bean定义了5种作用域，分别为：</p><ul><li>singleton (单例)</li><li>prototype (原型)</li><li>request</li><li>session </li><li>global session</li></ul><h3 id="singleton-单例模式（多线程下不安全）"><a href="#singleton-单例模式（多线程下不安全）" class="headerlink" title="singleton-单例模式（多线程下不安全）"></a>singleton-单例模式（多线程下不安全）</h3><ul><li>Spring loC容器中只会存在一 个共享的Bean实例，无论有多少个Bean引用它，始终指向同一个对象。</li><li>该模式在多线程下是不安全的。Singleton 作用域是Spring中的缺省作用域，也可以显示的将Bean定义为singleton模式</li></ul><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>userDao<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span> <span class="token punctuation">"</span>com.ioc.UserDaolmpl<span class="token punctuation">"</span></span> <span class="token attr-name">scope</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span> <span class="token punctuation">"</span>singleton<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="prototype-原型模式（每次使用时创建）"><a href="#prototype-原型模式（每次使用时创建）" class="headerlink" title="prototype-原型模式（每次使用时创建）"></a>prototype-原型模式（每次使用时创建）</h3><ul><li> 每次通过Spring容器获取prototype定义的bean时，容器都将创建一个新的Bean实例，每个Bean实例都有自己的属性和状态，而singleton全局只有一个对象。</li><li>一般来说,对有状态的bean使用prototype作用域，而对无状态的bean使用singleton作用域。</li></ul><h3 id="Request-（一次-request-创建一个实例）"><a href="#Request-（一次-request-创建一个实例）" class="headerlink" title="Request （一次 request 创建一个实例）"></a>Request （一次 request 创建一个实例）</h3><ul><li>在一次Http请求中，容器会返回该Bean的同一实例。 而对不同的Http请求则会产生新的Bean,而且该bean仅在当前Http Request 内有效</li><li>当前Http请求结束，该bean实例也将会被销毁。</li></ul><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span> <span class="token punctuation">"</span>loginAction<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.userLogin<span class="token punctuation">"</span></span> <span class="token attr-name">scope</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span> <span class="token punctuation">"</span>request<span class="token punctuation">'</span><span class="token punctuation">"</span></span><span class="token punctuation">/></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="session"><a href="#session" class="headerlink" title="session"></a>session</h3><ul><li>在一次Http Session中，容器会返回该Bean的同一实例。</li><li>而对不同的Session请求则会创建新的实例，该bean实例仅在当前Session 内有效。</li><li>同Http请求相同，每一次session请求创建新的实例，而不同的实例之间不共享属性，且实例仅在自己的session请求内有效，请求结束，则实例将被销毁。</li></ul><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span> userPreference<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span> com.ioc.UserPreference<span class="token punctuation">"</span></span> <span class="token attr-name">scope</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span> <span class="token punctuation">"</span>session<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="global-Session"><a href="#global-Session" class="headerlink" title="global Session"></a>global Session</h3><p>在一个全局的Http Session 中，容器会返回该Bean的同一个实例，仅在使用portlet context时有效。</p><h2 id="Spring-Bean的生命周期"><a href="#Spring-Bean的生命周期" class="headerlink" title="Spring Bean的生命周期"></a>Spring Bean的生命周期</h2><ol><li><p><strong>实例化</strong>一个Bean,也就是我们常说的new。</p></li><li><p><strong>IOC依赖注入</strong>，按照 Spring上下文对实例化的Bean进行配置，也就是IOC依赖注入。</p></li><li><p><strong>setBeanName实现</strong>，如果这个Bean已经实现了BeanNameAware接口，会调用它实现的setBeanName(String)方法，此处传递的就是Spring配置文件中Bean的id值</p></li><li><p><strong>BeanFactoryAware实现</strong>，如果这个Bean已经实现了BeanFactoryAware 接口，会调用它实现的setBeanFactory，setBeanFactory(BeanFactory)传递的是Spring工厂自身(可以用这个方式来获取其它Bean，只需在Spring配置文件中配置一个普通的Bean就可以)。</p></li></ol><ol start="5"><li><p><strong>ApplicationContextAware实现</strong>，如果这个 Bean已经实现了ApplicationContextAware接口，会调用<br>setApplicationContext(ApplicationContext)方法,传入Spring.上下文(同样这个方式也可以实现步骤4的内容，但比4更好,因为ApplicationContext是BeanFactory的子接口，有更多的实现方法)</p></li><li><p><strong>postProcessBeforelnitialization接口实现初始化预处理</strong>，如果这个Bean关联了BeanPostProcessor接口，将会调用postProcessBeforelnitialization(Object obj, String s)方法，BeanPostProcessor 经常被用作是Bean内容的更改，并且由于这个是在Bean初始化结束时调用那个的方法，也可以被应用于内存或缓存技术。</p></li><li><p><strong>init-method</strong>，如果 Bean在Spring配置文件中配置了init-method属性会自动调用其配置的初始化方法。</p></li><li><p><strong>postProcessAfterlnitialization</strong>，如果这个 Bean关联了BeanPostProcessor 接口，将会调用<br>postProcessAfterlnitialization(Object obj, String s)方法。<br>注:以上工作完成以后就可以应用这个Bean了,那这个Bean是一个Singleton的，所以一<br>般情况下我们调用同一个id的Bean会是在内容地址相同的实例，当然在Spring配置文件中<br>也可以配置非Singleton。</p></li><li><p><strong>Destroy过期自动清理阶段</strong>，当Bean不再需要时，会经过清理阶段,如果Bean实现了DisposableBean这个接口，会调用那个其实现的destroy()方法;</p></li><li><p><strong>destroy-method自配置清理</strong>，最后，如果这个Bean的Spring配置中配置了destroy-method属性,会自动调用其配置的销毁方法。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>限流算法有哪些？</title>
      <link href="/posts/32405.html"/>
      <url>/posts/32405.html</url>
      
        <content type="html"><![CDATA[<p>在开发高并发系统时，有三把利器用来保护系统：</p><ul><li>缓存</li><li>降级</li><li>限流</li></ul><p>那么何为限流呢？顾名思义，限流就是限制流量，那又有那些限流算法呢？</p><h2 id="计数器算法"><a href="#计数器算法" class="headerlink" title="计数器算法"></a>计数器算法</h2><p>计数器限流算法，是指在指定的时间周期内累加访问次数,达到设定的需值时，触发限流策略。<br>下一个时间周期进行访问时，访问次数清零。此算法无论在单机还是分布式环境下实现都非常简单，使用redis的incr原子自增性,再结合key的过期时间，即可轻松实现。<br><img src="https://img-blog.csdnimg.cn/acd8164f89de46bfa67b8fff1149c755.png" alt="在这里插入图片描述"></p><ul><li>设置一个计数器计数器，每当一个请求过来的时候，计数器就加1，如果计数器的值大于100并且该请求与第一个 请求的间隔时间还在1分钟之内，那么说明请求数过多；</li><li>如果该请求与第一个请求的间隔时间大于1分钟，且计数器的值还在限流范围内，那么就重置 计数器</li></ul><p>这个算法实现简单，但是有一个十分致命的问题，那就是临界问题<br><img src="https://img-blog.csdnimg.cn/57e92cf031304c1a9d6a4644a9f0c322.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5rGf5rqq5rC0,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><h3 id="临界问题"><a href="#临界问题" class="headerlink" title="临界问题"></a>临界问题</h3><p>在第一个时间周期结束前的一秒进来100个请求，在第二个时间周期开始后一秒，进来100个请求，那么这个系统在两秒之内处理了200个请求，没有达到我们要求的限流</p><p>我们规定的是1分钟最多100个请求，也就是每秒大约1.7个请求，用户通过在时间窗口的重置节点处突发请求，可以瞬间超过我们的速率限制。用户有可能通过算法的这个漏洞，瞬间压垮我们的系统。</p><h2 id="滑动时间窗口"><a href="#滑动时间窗口" class="headerlink" title="滑动时间窗口"></a>滑动时间窗口</h2><p>为了应对计数器算法的临界问题，人们想出来滑动窗口算法。</p><ul><li>在TCP网络通信协议中。就采用滑动时间窗口算法来解决网络拥堵问题。</li><li>滑动时间官口是将计数箱算法中的实际周期切分成多个小的时间窗口，分别在每个小的时间官口中记录访问次数。</li><li>然后根据时间将官口往前滑动并删吟过期的小时间会口。最终只需要统计滑动官口范围内的小时间离口的总的清求数即可。</li></ul><p><img src="https://img-blog.csdnimg.cn/064eeb2427b244c2833f98a3370f9916.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5rGf5rqq5rC0,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><p>整个红色的矩形框表示一个时间窗口，一个时间窗口就是一分钟。然后我们将时间窗口进行划分</p><ul><li>比如图中，我们就将滑动窗口 划成了3格，所以每格代表的是20秒钟。</li><li>每过20秒钟，我们的时间窗口就会往右滑动一格，每一个格子都有自己独立的计数器</li><li>比如当一个请求 在0:12秒的时候到达，那么0:00~0:19对应的计数器就会加1。</li></ul><h3 id="滑动窗口是怎么解决计数器算法的临界问题的呢？"><a href="#滑动窗口是怎么解决计数器算法的临界问题的呢？" class="headerlink" title="滑动窗口是怎么解决计数器算法的临界问题的呢？"></a>滑动窗口是怎么解决计数器算法的临界问题的呢？</h3><p>还是刚才那个例子，0:59到达的100个请求会落在最后的黄色格子中，而1:00到达的请求会落在红色的格子中。当时间到达1:00时，我们的窗口会往右移动一格，那么此时时间周期窗口内的总请求数量一共是200个，超过了限定的一个周期100个，所以触发了限流。</p><ul><li>计数器算法和滑动窗口算法原理一致，滑动窗口算法就是计数器算法。只是计数器算法没有对时间窗口做进一步地划分，所以只有1格。</li><li>当滑动窗口的格子划分的越多，那么滑动窗口的滚动就越平滑，限流的统计就会越精确。</li></ul><h2 id="漏桶算法"><a href="#漏桶算法" class="headerlink" title="漏桶算法"></a>漏桶算法</h2><p>漏桶算法的原理就像它的名字一样, 我们维持一个漏斗， 它有恒定的流出速度,不管水流流入的速度有多快，漏斗出水的速度始终保持不变,类似于消息中间件,不管消息的生产者请求量有多大,消息的处理能力取决于消费者<br><img src="https://img-blog.csdnimg.cn/3c18214711f2423fbe29a3454cb84121.png" alt="在这里插入图片描述"></p><p>漏桶的容量=漏桶的流出速度*可接受的等待时长。</p><ul><li>在这个容量范围内的清求可以排队等待系统的处理，超过这个容量的清求，才会被抛弃。</li></ul><p>在漏桶限流算法中，存在下面几种情况:</p><ol><li>当清求速度大于漏桶的流出速度时，也就是清求量大于当前服务所能处理的最大极跟值时，触发限流策略.</li><li>请求速度小于或等于漏桶的流出速度时，也就是服务的处理能力大于或等于请求量时，正常执行。</li></ol><p>漏桶算法有一个缺点:</p><ul><li>当系统在短时间内有突发的大流量时，漏桶算法处理不了，相当于桶装不了那么大水</li></ul><h2 id="令牌桶算法"><a href="#令牌桶算法" class="headerlink" title="令牌桶算法"></a>令牌桶算法</h2><p>令牌桶算法，是增加一个大小固定的容著,也就是令牌桶，系统以恒定的速率向令牌桶中放入令牌,如果有客户端来请求，先需要从令牌桶中拿一个令牌，拿到令牌，才有资格访问系统，这时令牌桶中少一个令牌。当令牌桶满的时候，再向令牌桶生成令牌时，令牌会被抛弃。<br><img src="https://img-blog.csdnimg.cn/b8fa455214134741bc3731fb991f7859.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5rGf5rqq5rC0,size_17,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><p>在令牌桶算法中，存在以下几种情况:</p><ol><li>请求速度大于令牌的生成速度：那么令牌桶中的令牌会被取完，后续再进来的清求，由于拿不到令牌，会被限流。</li><li>清求速度等于令牌的生成速度：那么此时系统处于平稳状态。</li><li>请求速度小于令牌的生成速度:那么此时系统的访问量远远低于系统的并发能力，请求可以被正常处理,令牌桶算法，由于有一个桶的存在，可以处理短时间大流量的场景，这是令牌桶和漏桶的一个区别。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 分布式微服务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 限流 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL如何保证ACID</title>
      <link href="/posts/43102.html"/>
      <url>/posts/43102.html</url>
      
        <content type="html"><![CDATA[<h2 id="ACID"><a href="#ACID" class="headerlink" title="ACID"></a>ACID</h2><ol><li>原子性：事务是一个原子操作单元，其对数据的修改，要么全都执行，要么全都不执行</li><li>一致性：事务开始前和结束后，数据库的完整性约束没有被破坏。</li><li>隔离性：同一时间，只允许一个事务请求同一数据，不同的事务之间彼此没有任何干扰。</li><li>持久性：事务完成后，事务对数据库的所有更新将被保存到数据库，不能回滚。</li></ol><h2 id="undo-log"><a href="#undo-log" class="headerlink" title="undo log"></a>undo log</h2><ul><li>undoLog 也就是我们常说的回滚日志文件 主要用于事务中执行失败，进行回滚，以及MVCC中对于数据历史版本的查看。</li><li>undo log由引擎层的InnoDB引擎实现,是逻辑日志,记录数据修改被修改前的值,比如”把id=’B’ 修改为id = ‘B2’ ，那么undo日志就会用来存放id =’B’的记录”。</li><li>当一条数据需要更新前,会先把修改前的记录存储在undolog中,如果这个修改出现异常,则会使用undo日志来实现回滚操作,保证事务的一致性。</li><li>当事务提交之后，undo log并不能立马被删除,而是会被放到待清理链表中,待判断没有事物用到该版本的信息时才可以清理相应undolog。</li><li>它保存了事务发生之前的数据的一个版本，用于回滚，同时可以提供多版本并发控制下的读（MVCC），也即非锁定读。</li></ul><h2 id="redo-log"><a href="#redo-log" class="headerlink" title="redo log"></a>redo log</h2><ul><li>redoLog 是重做日志文件是记录数据修改之后的值，用于持久化到磁盘中。</li><li>redo log包括两部分<ul><li>一是内存中的日志缓冲(redo log buffer)，该部分日志是易失性的；</li><li>二是磁盘上的重做日志文件(redo log file)，该部分日志是持久的。由引擎层的InnoDB引擎实现,是物理日志,记录的是物理数据页修改的信息,比如“某个数据页上内容发生了哪些改动”。</li></ul></li><li>当一条数据需要更新时,InnoDB会先将数据更新，然后记录redoLog 在内存中，然后找个时间将redoLog的操作执行到磁盘上的文件上。</li><li>不管是否提交成功我都记录，你要是回滚了，那我连回滚的修改也记录。它确保了事务的持久性。</li><li>每个InnoDB存储引擎至少有1个重做日志文件组（group），每个文件组下至少有2个重做日志文件，如默认的ib_logfile0和ib_logfile1。</li><li>为了得到更高的可靠性，用户可以设置多个的镜像日志组（mirrored log groups），将不同的文件组放在不同的磁盘上，以此提高重做日志的高可用性。</li><li>在日志组中每个重做日志文件的大小一致，并以循环写入的方式运行。InnoDB存储引擎先写重做日志文件1，当达到文件的最后时，会切换至重做日志文件2，再当重做日志文件2也被写满时，会再切换到重做日志文件1中。</li></ul><h2 id="MVCC"><a href="#MVCC" class="headerlink" title="MVCC"></a>MVCC</h2><ul><li>MVCC多版本并发控制是MySQL中基于乐观锁理论实现隔离级别的方式，用于读已提交和可重复读取隔离级别的实现。</li><li>在MySQL中，会在表中每一条数据后面添加两个字段：最近修改该行数据的事务ID，指向该行（undolog表中）回滚段的指针。</li><li>Read View判断行的可见性，创建一个新事务时，copy一份当前系统中的活跃事务列表。</li><li>当前不应该被本事务看到的其他事务id列表。</li><li>已提交读隔离级别下的事务在每次查询的开始都会生成一个独立的ReadView,而可重复读隔离级别则在第一次读的时候生成一个ReadView，之后的读都复用之前的ReadView。</li></ul><h2 id="数据库如何保证原子性"><a href="#数据库如何保证原子性" class="headerlink" title="数据库如何保证原子性"></a>数据库如何保证原子性</h2><p>原子性由undolog日志来保证，它记录了需要回滚的日志信息，事务回滚时撤销已经执行成功的sql</p><h2 id="数据库如何保证隔离性"><a href="#数据库如何保证隔离性" class="headerlink" title="数据库如何保证隔离性"></a>数据库如何保证隔离性</h2><p>隔离性是由MVCC来保证</p><h2 id="数据库如何保证持久性"><a href="#数据库如何保证持久性" class="headerlink" title="数据库如何保证持久性"></a>数据库如何保证持久性</h2><p>持久性由redolog来保证，mysq|修改数据的时候会在redolog中记录一份日志数据，就算数据没有保存成功，只要日志保存成功了，数据仍然不会丢失</p><h2 id="数据库如何保证一致性"><a href="#数据库如何保证一致性" class="headerlink" title="数据库如何保证一致性"></a>数据库如何保证一致性</h2><p>一致性由其他三大特性保证，程序代码要保证业务上的一致性</p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ACID </tag>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AQS原理</title>
      <link href="/posts/3478.html"/>
      <url>/posts/3478.html</url>
      
        <content type="html"><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>AQS是AbstarctQueuedSynchronizer 的简称 ，是一个用于构建锁和同步容器的框架。</p><p>juc并发 包内许多类都是基于 AQS 构建的</p><ul><li>ReentrantLock</li><li>ReentrantReadWriteLock</li><li>FutureTask</li></ul><p>AQS 解决了在实现同步容器时大量的细节问题。<br><img src="https://img-blog.csdnimg.cn/d49c82af4c5a4687806b853b3dd7065e.png" alt="在这里插入图片描述"></p><ul><li>AQS 使用一个 FIFO 队列表示排队等待锁的线程，队列头结点称作 “哨兵节点” ，它不与任何线程关联。</li><li>其他的节点与等待线程关联，每个阶段维护一个等待状态 waitStatus。</li></ul><h2 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h2><ul><li>独占锁：每次只能有一个线程持有锁， ReentrantLock 就是以独占方式实现的互斥锁；</li><li>共享锁：允许多个线程同时获取锁，并发访问共享资源，比如 ReentrantReadWriteLock。</li></ul><h2 id="内部原理"><a href="#内部原理" class="headerlink" title="内部原理"></a>内部原理</h2><p>AQS 的实现依赖内部的同步队列，也就是 FIFO 的双向队列，如果当前线程竞争锁失败，那么 AQS 会把当前线程以及等待状态信息构造成一个 Node 加入到同步队列中，同时再阻塞该线程。当获取锁的线程释放锁以后，会从队列中唤醒一个阻塞的节点 (线程)。<br><img src="https://img-blog.csdnimg.cn/8695a8335e9a4807877d1af86fe1b3d2.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5rGf5rqq5rC0,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>一个节点表示一个线程，它保存着线程的引用（thread）、状态（waitStatus）、前驱节点（prev）、后继节点（next），其实就是个双端双向链表</p><ul><li>AQS 队列内部维护的是一个 FIFO 的双向链表，这种结构的特点是每个数据结构都有两个指针，分别指向直接的后继节点和直接前驱节点。</li><li>双向链表可以从任意一个节点开始，很方便的访问前驱和后继。</li><li>每个 Node 其实是由线程封装，当线程争抢锁失败后会封装成 Node 加入到 ASQ 队列中去。</li></ul><h2 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h2><h4 id="添加线程"><a href="#添加线程" class="headerlink" title="添加线程"></a>添加线程</h4><p>当出现锁竞争以及释放锁的时候，AQS 同步队列中的节点会发生变化<br><img src="https://img-blog.csdnimg.cn/33188515e0eb44faa67106d48c0558ea.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5rGf5rqq5rC0,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><ul><li>队列操作的变化：新的线程封装成 Node 节点追加到同步队列中，设置 prev 节点以及修改当前节点的前置节点的 next 节点指向自己；</li><li>tail 指向变化：通过同步器将 tail 重新指向新的尾部节点。<h4 id="销毁线程"><a href="#销毁线程" class="headerlink" title="销毁线程"></a>销毁线程</h4>第一个 head 节点表示获取锁成功的节点，当头结点在释放同步状态时，会唤醒后继节点，如果后继节点获得锁成功，会把自己设置为头结点<br><img src="https://img-blog.csdnimg.cn/58333e8c7310454e819205749b8e93e9.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5rGf5rqq5rC0,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></li><li>head 节点指向：修改 head 节点指向下一个获得锁的节点；</li><li>新的获得锁的节点：第二个节点被 head 指向了，此时将 prev 的指针指向 null，因为它自己本身就是第一个首节点，所以 pre 指向 null。</li></ul><h2 id="AQS-与-ReentrantLock-的联系"><a href="#AQS-与-ReentrantLock-的联系" class="headerlink" title="AQS 与 ReentrantLock 的联系"></a>AQS 与 ReentrantLock 的联系</h2><p>ReentrantLock 是根据 AQS 实现的独占锁，提供了两个构造方法</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token class-name">ReentrantLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>       sync <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">NonfairSync</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">&#125;</span>   <span class="token keyword">public</span> <span class="token class-name">ReentrantLock</span><span class="token punctuation">(</span><span class="token keyword">boolean</span> fair<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>       sync <span class="token operator">=</span> fair <span class="token operator">?</span> <span class="token keyword">new</span> <span class="token class-name">FairSync</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token keyword">new</span> <span class="token class-name">NonfairSync</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>ReentrantLock 有三个内部类：Sync，NonfairSync，FairSync<br><img src="https://img-blog.csdnimg.cn/52499b5bb0d5442c8c604837e047566c.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5rGf5rqq5rC0,size_13,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><p>这三个内部类都是基于 AQS 进行的实现，所以ReentrantLock 是基于 AQS 进行的实现。</p><p>ReentrantLock 提供两种类型的锁：</p><ul><li>公平锁-FairSync</li><li>非公平锁-NonfairSync</li><li>默认实现是 NonFairSync。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 多线程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>比较交换CAS</title>
      <link href="/posts/509.html"/>
      <url>/posts/509.html</url>
      
        <content type="html"><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>CAS 是比较交换 CompareAndSwap 的简称，是一种用于在多线程环境下实现同步功能的机制。</p><p>顾名思义就是比较并交换。简单来说，从某一内存上取值 V，和预期值 A 进行比较</p><ul><li>如果内存值 V 和预期值 A 的结果相等，那么我们就把新值 B 更新到内存；</li><li>如果不相等，说明在这个过程中这个值被别的线程修改果，那么就重复上述操作直到成功为止。</li></ul><h2 id="为什么要CAS"><a href="#为什么要CAS" class="headerlink" title="为什么要CAS"></a>为什么要CAS</h2><h4 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h4><ul><li><p>在多线程中为了保持数据的准确性，避免多个线程同时操作某个变量，可以使用synchronized 实现同步锁。</p></li><li><p>使用 synchronized 关键字可以使操作的线程排队等待运行，可以说是一种悲观策略，认为线程会修改数据，所以开始就把持有锁的线程锁住，其他线程只能是挂起状态，等待锁的释放，所以同步锁带来了效率问题。</p></li></ul><h4 id="synchronized-的效率问题"><a href="#synchronized-的效率问题" class="headerlink" title="synchronized 的效率问题"></a>synchronized 的效率问题</h4><ul><li><p>在线程执行的时候，获得锁的线程在运行，其他被挂起的线程只能等待着持有锁的线程释放锁才有机会运行，时间浪费在阻塞等待上</p></li><li><p>在很多的线程切换的时候，由于有同步锁，就要涉及到锁的释放，加锁，这又是一个很大的时间开销。</p></li></ul><h4 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h4><ul><li><p>与阻塞机制相比有一种更有效地方法，即非阻塞机制，同步锁带来了线程执行时候之间的阻塞，而这种非阻塞机制在多个线程竞争同一个数据的时候不会发生阻塞的情况，效率大大提升</p></li><li><p>使用 volatile 不会造成阻塞，volatile 保证了线程之间的内存可见性和程序执行的有序性可以说已经很好的解决了上面的问题。</p></li><li><p>volatile存在原子操作问题，volatile 不能保证原子性，对于复合操作</p></li><li><p>例如 i++ 这样的程序包含三个原子操作：取值，自增，赋值。这个过程在多线程执行的时候就会有数据不一致的问题</p></li></ul><h2 id="CAS的意义"><a href="#CAS的意义" class="headerlink" title="CAS的意义"></a>CAS的意义</h2><ul><li>CAS（Compare And Swap 比较和交换）解决了 volatile 不能保证原子性的问题；</li><li>CAS 操作即能够解决锁的效率问题，也能够保证操作的原子性。</li></ul><h2 id="CAS-操作原理"><a href="#CAS-操作原理" class="headerlink" title="CAS 操作原理"></a>CAS 操作原理</h2><p>CAS 主要包含三个操作数，内存位置 V，原值 A，和新值 B。</p><ul><li>当位置 V 的值与 A 相等时，CAS 才会通过原子方式用新值 B 来更新 V，</li><li>否则不会进行任何操作。无论位置 V 的值是否等于 A，都将返回 V 原有的值。</li></ul><p>CAS 是一种乐观策略，每次都正常操作，不用担心其他线程会修改变量等数据，只在最后提交的时候验证数据是否被更改，如果其数据被更改，那么 CAS 会检测到并利用算法重新计算。</p><ul><li>CAS 也是同时允许一个线程修改变量，其他的线程试图修改都将失败；</li><li>相比于同步锁，CAS 对于失败的线程不会将他们挂起，下次仍可以继续提交，参与竞争，这也就是非阻塞机制的特点。</li></ul><h2 id="存在问题"><a href="#存在问题" class="headerlink" title="存在问题"></a>存在问题</h2><h4 id="ABA-问题"><a href="#ABA-问题" class="headerlink" title="ABA 问题"></a>ABA 问题</h4><p>假设有两个线程，线程 1 和线程 2，线程 1 工作时间需要 6 秒，线程 2 工作需要 2 秒，主内存值为 A；</p><ul><li>第 1 秒，线程 1 和线程 2 都把 A 拿到自己的工作内存；</li><li>第 2 秒，线程 2 开始执行，线程 2 工作完成把 A 改成了 B ；</li><li>第 4 秒，线程 2 把 B 又改成了 A；</li><li>第 6秒，线程 1 看到期望为 A ，和真实值也是 A， 认为没有线程修改过数据，其实 A 已经修改过了，后来又改了回去，然后线程 1 进行 CAS 操作。<h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4>为了解决这个问题，在每次进行操作的时候加上一个版本号即可，要求这个版本号只能增加，不能减少</li></ul>]]></content>
      
      
      <categories>
          
          <category> 多线程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CAS </tag>
            
            <tag> 乐观锁 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何保证消息的可靠性传输</title>
      <link href="/posts/53658.html"/>
      <url>/posts/53658.html</url>
      
        <content type="html"><![CDATA[<p>在生产环境中，因为机器以及网络设备的不可靠，保证消息的可靠是待解决的问题。在特定场景下消息可能存在丢失风险</p><h2 id="消息发送流程"><a href="#消息发送流程" class="headerlink" title="消息发送流程"></a>消息发送流程</h2><p>我们可以将 RabbitMQ 消息处理的过程分为三个步骤：</p><ul><li>生产阶段：生产者生产消息并且发送到消息队列；</li><li>储存阶段：消息队列存储和处理消息；</li><li>消费阶段：消息队列将消息转发到消费者。</li></ul><p>上述每个步骤都有可能出现消息丢失的风险；<br><img src="https://img-blog.csdnimg.cn/13d87d272eb54fddb92fcbd6d1faf0a1.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5rGf5rqq5rC0,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><h2 id="生产者生产消息并且发送到消息队列"><a href="#生产者生产消息并且发送到消息队列" class="headerlink" title="生产者生产消息并且发送到消息队列"></a>生产者生产消息并且发送到消息队列</h2><h4 id="丢失场景"><a href="#丢失场景" class="headerlink" title="丢失场景"></a>丢失场景</h4><p>生产者将数据发送到 RabbitMQ 的时候，可能数据就在半路给搞丢了，比如：</p><ul><li>网络故障。网络环境的不可靠导致消息发送失败，例如网络丢包、网络故障。</li><li>数据在网络中传输会经过诸多网络设备，只要其中一个网络链接在数据抵达前已经流量满载，新到的数据将会阻塞一段时间段。</li></ul><h4 id="AMQP事务机制"><a href="#AMQP事务机制" class="headerlink" title="AMQP事务机制"></a>AMQP事务机制</h4><p>使用AMQP协议的事务机制。生产者在发出消息之后，消息是否到达RabbitMQ服务器是默认不可知的，在生产者发送消息之前，调用channel.txSelect 语句开启事务</p><ul><li>如果消息发送失败，那么调用channel.txRollback回滚事务，尝试重新发送一条消息；</li><li>如果消息发送成功，那么调用channel.txCommit提交事务。</li></ul><p>采用事务的缺点是增加耗时，会降低RabbitMQ的吞吐性能。</p><h4 id="Confirm机制"><a href="#Confirm机制" class="headerlink" title="Confirm机制"></a>Confirm机制</h4><p>RabbitMQ有一种性能改进方案，即Confirm机制</p><ul><li>生产者调用channel.confirmSelect将通信方式设置为confirm模式；</li><li>生产者发送的所有消息都会被分配一个唯一 ID；</li><li>当生产者发送的消息成功投递到队列之后，RabbitMQ会发送一个ack给生产者，生产者即得知这条消息已经成功发送。</li><li>如果 RabbitMQ 没能处理这个消息，会回调你一个nack接口，告诉你这个消息接收失败，需要重试</li></ul><p>我们也可以结合这个机制在内存里维护每个消息 id 的状态，如果超过一定时间还没接收到这个消息的回调，那么就需要重新发送</p><h4 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h4><ul><li>事务机制是同步的，你提交一个事务之后会阻塞在那里</li><li>confirm机制是异步的，发送消息之后就可以发送下一个消息，然后那个消息RabbitMQ 接收了之后会异步回调你一个接口通知你这个消息接收到了。</li></ul><h2 id="消息队列存储和处理消息"><a href="#消息队列存储和处理消息" class="headerlink" title="消息队列存储和处理消息"></a>消息队列存储和处理消息</h2><p>消息存储在 RabbitMQ 队列中，如果队列没有持久化，如果服务器宕机，RabbitMQ 服务器重启后会导致消息丢失。</p><h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><p>开启 RabbitMQ 的持久化，就是消息写入之后会持久化到磁盘，如果 RabbitMQ 自己宕机了，重启之后会自动读取之前存储的数据；</p><p>也有可能RabbitMQ 还没持久化，就宕机了，这种情况发生的概率比较小</p><p>持久化也可以跟生产者的confirm机制配合起来，只有消息被持久化到磁盘之后，才给生产者发送ack，所以哪怕是出现上面这种情况，RabbitMQ 宕机了，消息丢了，生产者收不到ack，还是回重发的。</p><h4 id="消息队列持久化"><a href="#消息队列持久化" class="headerlink" title="消息队列持久化"></a>消息队列持久化</h4><ul><li><p>Exchange 持久化：以 Direct 模式为例，将 durable 参数设置为 true。</p></li><li><p>Queue 持久化：将 durable 参数设置为 true，但是这样只能保证持久化 Queue 的元数据，但是不会持久化 Queue 里存储的消息。</p></li><li><p>消息持久化：发送消息的时候将deliveryMode设置为2，将消息设置为持久化的</p></li><li><p>SpringBoot中的rabbitTemplate默认设置消息是持久化，不需要手动配置</p></li></ul><h2 id="消息队列将消息转发到消费者"><a href="#消息队列将消息转发到消费者" class="headerlink" title="消息队列将消息转发到消费者"></a>消息队列将消息转发到消费者</h2><p>消费者在收到消息之后，还没来得及处理消息的消费逻辑，所在机器就宕机了，导致内存中的消息丢失。</p><h4 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案"></a>解决方案</h4><p>RabbitMQ 默认采用自动 ACK 机制，在没有处理业务逻辑之前，消费者就会告知消息队列已经成功收到消息，这种方式并不能解决这种问题</p><ul><li>我们可以关闭自动ACK模式，通过一个 调用API接口就行，消费完消息后，再返回ACK。这样的话，如果你还没处理完，就没有ACK</li><li>这样 RabbitMQ 就认为你还没处理完，这个时候 RabbitMQ 会把这个消费分配给别的 consumer 去处理，消息是不会丢的。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 消息队列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RabbitMQ </tag>
            
            <tag> 可靠性 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>volatile 关键字</title>
      <link href="/posts/38250.html"/>
      <url>/posts/38250.html</url>
      
        <content type="html"><![CDATA[<h2 id="volatile-关键字"><a href="#volatile-关键字" class="headerlink" title="volatile 关键字"></a>volatile 关键字</h2><ul><li>volatile 关键字解决内存可见性问题，是一种弱形式的同步。</li><li>该关键字可以确保当一个线程更新共享变量时，更新操作对其他线程马上可见。</li><li>当一个变量被声明为 volatile 时，线程在写入变量时不会把值缓存在寄存器或者其他地方，而是会把值刷新回主内存。</li><li>当其他线程读取该共享变量时，会从主内存重新获取最新值，而不是使用当前线程的工作内存中的值。</li></ul><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>Java 语言提供了一种弱同步机制，即 volatile 变量，用来确保将变量的更新操作通知到其他线程。</p><p>当把变量声明为 volatile 类型后，编译器与运行时都会注意到这个变量是共享的，volatile 变量不会被缓存在寄存器或者对其他处理器不可见的地方，因此在读取 volatile 类型的变量时总会返回最新写入的值。</p><p>在访问 volatile 变量时不会执行加锁操作，因此也就不会使执行线程阻塞，因此 volatile 变量是一种比 sychronized 关键字更轻量级的同步机制。</p><p><img src="https://img-blog.csdnimg.cn/9e8d11a885064a3ab64812f35796106b.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5rGf5rqq5rC0,size_19,color_FFFFFF,t_70,g_se,x_16"></p><ul><li><p>当对非 volatile 变量进行读写的时候，每个线程先从内存拷贝变量到 CPU 缓存中。如果计算机有多个 CPU，每个线程可能在不同的 CPU 上被处理，这意味着每个线程可以拷贝到不同的 CPU cache 中。</p></li><li><p>而声明变量是 volatile 的，JVM 保证了每次读变量都从内存中读，跳过 CPU cache。</p></li></ul><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><ul><li>保证变量的可见性</li><li>禁止指令重排</li></ul><h4 id="保证变量的可见性"><a href="#保证变量的可见性" class="headerlink" title="保证变量的可见性"></a>保证变量的可见性</h4><p>当一条线程修改了变量值，新值对于其他线程来说是立即可以得知的。volatile 变量在各个线程的<br>工作内存中不存在-致性问题，但Java的运算操作符并非原子操作，导致volatile变量运算在并<br>发下仍不安全。</p><h4 id="禁止指令重排"><a href="#禁止指令重排" class="headerlink" title="禁止指令重排"></a>禁止指令重排</h4><p>使用volatile变量进行写操作，汇编指令带有lock前缀，相当于一个内存屏障，后面的指令不能<br>重排到内存屏障之前。</p><h4 id="使用lock前缀引发两件事"><a href="#使用lock前缀引发两件事" class="headerlink" title="使用lock前缀引发两件事:"></a>使用lock前缀引发两件事:</h4><ol><li>将当前处理器缓存行的数据写回系统内存。</li><li>使其他处理器的缓存无效。</li></ol><p>相当于对缓存变量做了- -次store和write操作，让volatile变量的修改对其他处理器立即可见。</p><h2 id="volatile-与-synchronized-的区别"><a href="#volatile-与-synchronized-的区别" class="headerlink" title="volatile 与 synchronized 的区别"></a>volatile 与 synchronized 的区别</h2><h4 id="相似处："><a href="#相似处：" class="headerlink" title="相似处："></a>相似处：</h4><p>volatile 的内存语义和 synchronized 有相似之处，具体来说就是，当线程写入了 volatile 变量值时就等价于线程退出 synchronized 同步块（把写入工作内存的变量值同步到主内存），读取 volatile 变量值时就相当于进入 synchronized 同步块（ 先清空本地内存变量值，再从主内存获取最新值）。</p><h4 id="区别："><a href="#区别：" class="headerlink" title="区别："></a>区别：</h4><p>使用锁的方式可以解决共享变量内存可见性问题，但是使用锁太笨重，因为它会带来线程上下文的切换开销。具体区别如下：</p><ul><li>volatile 本质是在告诉 jvm 当前变量在寄存器（工作内存）中的值是不确定的，需要从主存中读取；</li><li>synchronized 则是锁定当前变量，只有当前线程可以访问该变量，其他线程被阻塞住；</li><li>volatile 仅能使用在变量级别；synchronized 则可以使用在变量、方法、和类级别的；</li><li>volatile 仅能实现变量的修改可见性，不能保证原子性；而 synchronized 则可以保证变量的修改可见性和原子性；</li><li>volatile 不会造成线程的阻塞；synchronized 可能会造成线程的阻塞；</li><li>volatile 标记的变量不会被编译器优化；synchronized 标记的变量可以被编译器优化</li></ul>]]></content>
      
      
      <categories>
          
          <category> 多线程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> volatile </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JDK的锁优化策略</title>
      <link href="/posts/64859.html"/>
      <url>/posts/64859.html</url>
      
        <content type="html"><![CDATA[<h2 id="锁的优化策略"><a href="#锁的优化策略" class="headerlink" title="锁的优化策略"></a>锁的优化策略</h2><ul><li>JDK6对synchronized做了很多优化，引入了自适应自旋、锁消除、锁粗化、偏向锁和轻量级锁等优化策略，提高锁的效率；</li><li>锁一共有4个状态，级别从低到高依次是:无锁、偏向锁、轻量级锁和重量级锁，状态会随竞争情况升级。</li><li>锁可以升级但不能降级，这种只能升级不能降级的锁策略是为了提高锁获得和释放的效率。</li></ul><h2 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h2><ul><li>线程同步对性能最大的影响是阻塞，挂起和恢复线程的操作都需要从用户态转入内核态完成。</li><li>许多应用上共享数据的锁定只会持续很短的时间，为了这段时间去挂起和恢复线程并不值得。</li><li>如果机器有多个处理器核心，我们可以让后面请求锁的线程稍等一会， 但不放弃处理器的执行时间，看看持有锁的线程是否很快会释放锁。</li><li>为了让线程等待只需让线程执行一个循环，这项技术就是自旋锁。</li></ul><p>自旋锁在JDK4就已引入，默认关闭，在JDK6中改为默认开启。自旋不能代替阻塞，虽然避免了线程<br>切换开销，但要占用处理器时间。</p><ul><li>如果锁被占用的时间很短，自旋的效果就会非常好，反之只会白白消耗处理器资源。</li><li>如果自旋超过了限定的次数仍然没有成功获得锁，就应挂起线程，自旋默认限定次数是10</li></ul><h3 id="自适应自旋"><a href="#自适应自旋" class="headerlink" title="自适应自旋"></a>自适应自旋</h3><ul><li>JDK6对自旋锁进行了优化，自旋时间不再固定，而是由前一次的自旋时间及锁拥有者的状态决定。</li><li>如果在同一个锁上，自旋刚刚成功获得过锁且持有锁的线程正在运行，虚拟机会认为这次自旋也很可能成功，进而允许自旋持续更久。</li><li>如果自旋很少成功，以后获取锁时将可能直接省略掉自旋，避免浪费处理器资源。有了自适应自旋，随着程序运行时间的增长，虚拟机对程序锁的状况预测就会越来越精准。</li></ul><h2 id="锁消除"><a href="#锁消除" class="headerlink" title="锁消除"></a>锁消除</h2><ul><li>锁消除指即时编译器对检测到不可能存在共享数据竞争的锁进行消除。</li><li>主要判定依据来源于逃逸分析，如果判断一段代码中堆上的所有数据都只被一个线程访问，就可以当作栈上的数据对待，认为它们是线程私有的而无须同步。<h2 id="锁粗化"><a href="#锁粗化" class="headerlink" title="锁粗化"></a>锁粗化</h2></li><li>一般来说需要将同步块的作用范围限制得尽量小，只在共享数据的实际作用域中进行同步，这是为了使等待锁的线程尽快拿到锁。</li><li>但如果一系列的连续操作都对同一个对象反复加锁和解锁，甚至加锁操作是出现在循环体之外的，即使没有线程竞争也会导致不必要的性能消耗。</li><li>因此如果虚拟机探测到有一串零碎的操作都对同一个对象加锁，将会把同步的范围扩展到整个操作序列的外部。</li></ul><h2 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h2><ul><li>偏向锁是为了在没有竞争的情况下减少锁开销，锁会偏向于第一个获得它的线程，如果在执行过程中锁一直没有被其他线程获取，则持有偏向锁的线程将不需要进行同步。</li><li>当锁对象第一次被线程获取时，虚拟机会将对象头中的偏向模式设为1，同时使用CAS把获取到锁的线<br>程ID记录在对象的Mark Word中。</li><li>如果CAS成功，持有偏向锁的线程以后每次进入锁相关的同步块都不再进行任何同步操作。</li><li>一旦有其他线程尝试获取锁，偏向模式立即结束，根据锁对象是否处于锁定状态决定是否撤销偏向，后续同步按照轻量级锁那样执行。</li></ul><h2 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h2><p>轻量级锁是为了在没有竞争的前提下减少重量级锁使用操作系统互斥量产生的性能消耗。</p><p>在代码即将进入同步块时，如果同步对象没有被锁定，虚拟机将在当前线程的栈帧中建立一个锁记录空<br>间，存储锁对象目前Mark Word的拷贝。然后虚拟机使用CAS尝试把对象的Mark Word更新为指向<br>锁记录的指针，如果更新成功即代表该线程拥有了锁，锁标志位将转变为00，表示处于轻量级锁定状<br>念。</p><p>如果更新失败就意味着至少存在一条线程与当前线程竞争。虚拟机检查对象的Mark Word是否指向当<br>前线程的栈帧，如果是则说明当前线程已经拥有了锁，直接进入同步块继续执行，否则说明锁对象已经<br>被其他线程抢占。如果出现两条以上线程争用同一个锁，轻量级锁就不再有效，将膨胀为重量级锁，锁<br>标志状态变为10，此时Mark Word存储的就是指向重量级锁的指针，后面等待锁的线程也必须阻塞。</p><p>解锁同样通过CAS进行，如果对象Mark Word仍然指向线程的锁记录，就用CAS把对象当前的Mark<br>Word和线程复制的Mark Word替换回来。假如替换成功同步过程就顺利完成了，如果失败则说明有<br>其他线程尝试过获取该锁，就要在释放锁的同时唤醒被挂起的线程。</p><h2 id="偏向锁、轻量级锁和重量级锁之间的区别"><a href="#偏向锁、轻量级锁和重量级锁之间的区别" class="headerlink" title="偏向锁、轻量级锁和重量级锁之间的区别?"></a>偏向锁、轻量级锁和重量级锁之间的区别?</h2><ul><li>偏向锁的优点是加解锁不需要额外消耗，和执行非同步方法比仅存在纳秒级差距，缺点是如果存在锁竞争会带来额外锁撤销的消耗，适用只有一个线程访问同步代码块的场景。</li><li>轻量级锁的优点是竞争线程不阻塞，程序响应速度快，缺点是如果线程始终得不到锁会自旋消耗CPU,适用追求响应时间、同步代码块执行快的场景。</li><li>重量级锁的优点是线程竞争不使用自旋不消耗CPU，缺点是线程会阻塞,响应时间慢，适应追求吞吐<br>量、同步代码块执行慢的场景。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 多线程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 锁 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>synchronized关键字</title>
      <link href="/posts/27249.html"/>
      <url>/posts/27249.html</url>
      
        <content type="html"><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>synchronized 同步块是 Java 提供的一种原子性内置锁，Java 中的每个对象都可以把它当作一个同步锁来使用，这些 Java 内置的使用者看不到的锁被称为内部锁，也叫作监视器锁。</p><h4 id="内置锁"><a href="#内置锁" class="headerlink" title="内置锁"></a>内置锁</h4><ul><li><p>也叫排它锁，也就是当一个线程获取这个锁后，其他线程必须等待该线程释放锁后才能获取该锁。</p></li><li><p>代码在进入 synchronized 代码块前会自动获取内部锁，这时候其他线程访问该同步代码块时会被阻塞挂起。</p></li><li><p>拿到内部锁的线程会在正常退出同步代码块或者抛出异常后或者在同步块内调用了该内置锁资源的 wait 系列方法时释放该内置锁。</p></li></ul><h4 id="上下文切换"><a href="#上下文切换" class="headerlink" title="上下文切换"></a>上下文切换</h4><p>由于 Java 中的线程是与操作系统的线程一一对应的，所以当阻塞一个线程时，需要从用户态切换到内核态执行阻塞操作，这是很耗时的操作，这就是上下文切换，而 synchronized 的使用就会导致上下文切换。</p><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><p>在并发编程中存在线程安全问题，使用 synchronized 关键字能够有效的避免多线程环境下的线程安全问题。</p><h4 id="线程安全问题"><a href="#线程安全问题" class="headerlink" title="线程安全问题"></a>线程安全问题</h4><ul><li>存在共享数据，共享数据是对多线程可见的，所有的线程都有权限对共享数据进行操作；</li><li>多线程共同操作共享数据。关键字 synchronized 可以保证在同一时刻，只有一个线程可以执行某个同步方法或者同步代码块，同时 synchronized 关键字可以保证一个线程变化的可见性；</li><li>多线程共同操作共享数据且涉及增删改操作。如果只是查询操作，是不需要使用 synchronized 关键字的，在涉及到增删改操作时，为了保证数据的准确性，可以选择使用 synchronized 关键字。</li></ul><h2 id="三种使用方式"><a href="#三种使用方式" class="headerlink" title="三种使用方式"></a>三种使用方式</h2><p>Java 中每一个对象都可以作为锁，synchronized 有三种使用方式</p><ul><li>作用在普通同步方法（实例方法）：锁是当前实例对象 ，进入同步代码前要获得当前实例的锁；</li><li>作用在静态同步方法：锁是当前类的 class 对象 ，进入同步代码前要获得当前类对象的锁；</li><li>作用在同步方法块：锁是括号里面的对象，对给定对象加锁，进入同步代码库前要获得给定对象的锁。</li></ul><h2 id="双重检验锁实现单例模式"><a href="#双重检验锁实现单例模式" class="headerlink" title="双重检验锁实现单例模式"></a>双重检验锁实现单例模式</h2><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">DoubleCheck</span><span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token keyword">volatile</span> <span class="token keyword">static</span> <span class="token class-name">DoubleCheck</span> instance<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">DoubleCheck</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">synchronized</span> <span class="token keyword">static</span> <span class="token class-name">DoubleCheck</span> <span class="token function">getIntstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token comment">//先判断对象是否实例过，没有则进入加锁代码</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>instance <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token comment">//类对象加锁</span>            <span class="token keyword">synchronized</span><span class="token punctuation">(</span><span class="token class-name">DoubleCheck</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>instance <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                    instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DoubleCheck</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> instance<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>使用synchronized关键字，内外两次判断对象是否存在</li><li>必须使用volatile关键字修饰，防止jvm指令重排</li></ul>]]></content>
      
      
      <categories>
          
          <category> 多线程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 锁 </tag>
            
            <tag> synchronized </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>扩展线程池捕获线程异常</title>
      <link href="/posts/7599.html"/>
      <url>/posts/7599.html</url>
      
        <content type="html"><![CDATA[<h2 id="如何捕获线程池中的线程异常"><a href="#如何捕获线程池中的线程异常" class="headerlink" title="如何捕获线程池中的线程异常"></a>如何捕获线程池中的线程异常</h2><h3 id="简单案例"><a href="#简单案例" class="headerlink" title="简单案例"></a>简单案例</h3><p>我们先看一个案例，实现Runnable接口，计算两个数的商<br><img src="https://img-blog.csdnimg.cn/412d931173c34e70ae14e23a7236c8cb.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5rGf5rqq5rC0,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>创建一个线程池，参数如下<br><img src="https://img-blog.csdnimg.cn/a274f18d22894035b24ed64b36fe2835.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5rGf5rqq5rC0,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>提交任务到线程池，查看执行结果<br><img src="https://img-blog.csdnimg.cn/2cea315595974aab8d54688a7d456f14.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5rGf5rqq5rC0,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>执行结果<br><img src="https://img-blog.csdnimg.cn/c9999b695a714397aa4b35c320caef04.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5rGf5rqq5rC0,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><ul><li>我们发现，我们代码中，提交了5个线程，但最终只打印了4个结果，</li><li>而且没有报何错误，很明显100/0的那个任务没有打印</li><li>100/0会报除零异常，但是显然这次没有报任何错误</li></ul><h3 id="改用execute-提交线程"><a href="#改用execute-提交线程" class="headerlink" title="改用execute()提交线程"></a>改用execute()提交线程</h3><p>为了获得线程报错信息，我们可以改用execute()提交线程<br><img src="https://img-blog.csdnimg.cn/0066bbf997c746beae88e10f83264575.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5rGf5rqq5rC0,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><ul><li>从这里的控制台，我们得到了部分的报错信息，但是我们只能知道异常是在哪里抛出来的，ThreadPoolTest.java的第51行；</li><li>但是我们还是希望得到其他的更重要的信息，这个任务在哪里提交的？<h3 id="扩展线程池ThreadPoolExecutor"><a href="#扩展线程池ThreadPoolExecutor" class="headerlink" title="扩展线程池ThreadPoolExecutor"></a>扩展线程池ThreadPoolExecutor</h3>我们可以扩展一下ThreadPoolExecutor这个线程池，让他在任务调度前，先保存一下提交任务线程的堆栈信息</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">package</span> <span class="token namespace">com<span class="token punctuation">.</span>stream<span class="token punctuation">.</span>juc</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span></span><span class="token class-name">BlockingQueue</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span></span><span class="token class-name">Future</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span></span><span class="token class-name">ThreadPoolExecutor</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span></span><span class="token class-name">TimeUnit</span><span class="token punctuation">;</span><span class="token comment">/** * 扩展线程池 * 捕获线程池的异常 * * @author stream * @since 2021/9/15 7:51 */</span><span class="token keyword">class</span> <span class="token class-name">ExtenThreadPoolExecutor</span> <span class="token keyword">extends</span> <span class="token class-name">ThreadPoolExecutor</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token class-name">ExtenThreadPoolExecutor</span><span class="token punctuation">(</span><span class="token keyword">int</span> corePoolSize<span class="token punctuation">,</span> <span class="token keyword">int</span> maximumPoolSize<span class="token punctuation">,</span> <span class="token keyword">long</span> keepAliveTime<span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span> unit<span class="token punctuation">,</span> <span class="token class-name">BlockingQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Runnable</span><span class="token punctuation">></span></span> workQueue<span class="token punctuation">,</span> <span class="token class-name">CallerRunsPolicy</span> callerRunsPolicy<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">super</span><span class="token punctuation">(</span>corePoolSize<span class="token punctuation">,</span> maximumPoolSize<span class="token punctuation">,</span> keepAliveTime<span class="token punctuation">,</span> unit<span class="token punctuation">,</span> workQueue<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">execute</span><span class="token punctuation">(</span><span class="token class-name">Runnable</span> command<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token function">wrap</span><span class="token punctuation">(</span>command<span class="token punctuation">,</span><span class="token function">clientTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token class-name">Future</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">></span></span> <span class="token function">submit</span><span class="token punctuation">(</span><span class="token class-name">Runnable</span> task<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">submit</span><span class="token punctuation">(</span><span class="token function">wrap</span><span class="token punctuation">(</span>task<span class="token punctuation">,</span><span class="token function">clientTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token comment">// 抛出异常信息</span>    <span class="token keyword">private</span> <span class="token class-name">Exception</span> <span class="token function">clientTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Exception</span><span class="token punctuation">(</span><span class="token string">"Thread Stack"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">private</span> <span class="token class-name">Runnable</span> <span class="token function">wrap</span><span class="token punctuation">(</span><span class="token class-name">Runnable</span> task<span class="token punctuation">,</span> <span class="token class-name">Exception</span> exception <span class="token punctuation">,</span> <span class="token class-name">String</span> name<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token annotation punctuation">@Override</span>            <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>                    task<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 捕获异常</span>                <span class="token punctuation">&#125;</span><span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                    exception<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">throw</span> e<span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们用扩展后的线程池提交任务，还是刚才的代码<br><img src="https://img-blog.csdnimg.cn/f585e3e0943b4c089071ef9f7df94552.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5rGf5rqq5rC0,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>这样，我们就得到了异常发生的内部堆栈信息，帮助我们快速定位问题</p>]]></content>
      
      
      <categories>
          
          <category> 多线程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线程池 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ThreadLocal的使用</title>
      <link href="/posts/22538.html"/>
      <url>/posts/22538.html</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>ThreadLocal 为解决多线程程序的并发问题提供了一种新的思路，使用这个工具类可以很简洁地编写出优美的多线程程序。</p><ul><li><p>ThreadLocal 很容易让人望文生义，想当然地认为是一个 “本地线程”。其实，ThreadLocal 并不是一个 Thread，而是 Thread 的局部变量，也许把它命名为 ThreadLocalVariable 更容易让人理解一些。</p></li><li><p>当使用 ThreadLocal 维护变量时，ThreadLocal 为每个使用该变量的线程提供独立的变量副本，所以每一个线程都可以独立地改变自己的副本，而不会影响其它线程所对应的副本。</p></li></ul><p>从线程的角度看，目标变量就象是线程的本地变量，这也是类名中 “Local” 所要表达的意思。</p><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><p>ThreadLocal提供了线程本地变量，如果你创建了一个 ThreadLocal 变量，那么访问这个变量的每个线程都会有这个变量的一个本地副本。当多个线程操作这个变量时，实际操作的是自己本地内存里面的变量，从而避免了线程安全问题。<br><img src="https://img-blog.csdnimg.cn/da73098b996a4ca582c20451c3665a3c.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5rGf5rqq5rC0,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><p>ThreadLocal 是线程本地存储，在每个线程中都创建了一个 ThreadLocalMap 对象，每个线程可以访问自己内部 ThreadLocalMap 对象内的 value。通过这种方式，避免资源在多线程间共享。</p><h2 id="set-和get-方法"><a href="#set-和get-方法" class="headerlink" title="set()和get()方法"></a>set()和get()方法</h2><p>set 方法是为了设置 ThreadLocal 变量，设置成功后，该变量只能够被当前线程访问，其他线程不可直接访问操作改变量。参数是泛型<br><img src="https://img-blog.csdnimg.cn/add11667446f4362b06ddd7dd0650846.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5rGf5rqq5rC0,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><p>get 方法是为了获取 ThreadLocal 变量的值，get 方法没有任何入参，直接调用即可获取。<br><img src="https://img-blog.csdnimg.cn/402c399592cb48ac9707f2629e92f9ca.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5rGf5rqq5rC0,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><h2 id="remove-方法"><a href="#remove-方法" class="headerlink" title="remove() 方法"></a>remove() 方法</h2><p>remove 方法是为了清除 ThreadLocal 变量，清除成功后，该 ThreadLocal 中没有变量值。<br><img src="https://img-blog.csdnimg.cn/144cb735fb68441f9b4db94121c50f34.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5rGf5rqq5rC0,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><h2 id="单线程使用案例"><a href="#单线程使用案例" class="headerlink" title="单线程使用案例"></a>单线程使用案例</h2><p><img src="https://img-blog.csdnimg.cn/d06fb2b2ea2e4d96a728e4cc6a93099f.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5rGf5rqq5rC0,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><h2 id="多线程下的-ThreadLocal使用案例"><a href="#多线程下的-ThreadLocal使用案例" class="headerlink" title="多线程下的 ThreadLocal使用案例"></a>多线程下的 ThreadLocal使用案例</h2><p>看个简单案例</p><ul><li>线程1设置了ThreadLocal（thread-1 local value）</li><li>线程2设置了ThreadLocal（thread-2 local value）</li><li>线程2remove变量ThreadLocal</li><li>看看线程1是否还能打印之前设置的ThreadLocal</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">package</span> <span class="token namespace">com<span class="token punctuation">.</span>stream<span class="token punctuation">.</span>juc</span><span class="token punctuation">;</span><span class="token comment">/** * @author stream * @since 2021/9/15 16:11 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ThreadLocalTest</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">ThreadLocal</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> local <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ThreadLocal</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">Thread</span> threadOne <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token annotation punctuation">@Override</span>            <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                local<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token string">"thread-1 local value"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>                    <span class="token comment">// 等待5000毫秒，确保threadTwo 执行remove完成</span>                    <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">5000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                 <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>local<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">Thread</span> threadTwo <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token annotation punctuation">@Override</span>            <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                local<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token string">"thread-2 local value"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>local<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                local<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"thread-2 remove 变量local 操作完毕。"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                threadTwo<span class="token punctuation">.</span> <span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        threadOne<span class="token punctuation">.</span> <span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>执行结果<br><img src="https://img-blog.csdnimg.cn/d9aa7d2f2fd4417babdb562ef719b084.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5rGf5rqq5rC0,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><ul><li>从结果来看，在 threadTwo 执行完 remove 方法后，threadOne 仍然能够成功打印</li><li>从而证明了 ThreadLocal 的专属特性，线程独有，其他线程不可修改</li></ul><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul><li>ThreadLocal 是解决线程安全问题一个很好的思路，</li><li>它通过为每个线程提供一个独立的变量副本解决了变量并发访问的冲突问题。</li><li>ThreadLocal 比直接使用 synchronized 同步机制解决线程安全问题更简单，更方便，且程序拥有更高的并发性。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 多线程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ThreadLocal </tag>
            
            <tag> 共享变量 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HashMap的扩容</title>
      <link href="/posts/61579.html"/>
      <url>/posts/61579.html</url>
      
        <content type="html"><![CDATA[<h2 id="HashMap初始化"><a href="#HashMap初始化" class="headerlink" title="HashMap初始化"></a>HashMap初始化</h2><p>在JDK1.8中，定义了HashMap的初始化过程，我们看看他的源码是如果定义这个初始化过程<br><img src="https://img-blog.csdnimg.cn/ef83dacd0c114c8b92ce95ee8fb5dc8f.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5rGf5rqq5rC0,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>可以看到，它的构造方法中传入了两个参数，一个是初始化容量，一个是加载因子，默认是0.75f</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">HashMap</span><span class="token punctuation">(</span><span class="token keyword">int</span> initialCapacity<span class="token punctuation">,</span> <span class="token keyword">float</span> loadFactor<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>但是这个容量最终调用了另一个构造方法<br><img src="https://img-blog.csdnimg.cn/1ba346c1aaa74ba6bb213d36903d2ba0.png" alt="在这里插入图片描述"><br>这个threshold的成员变量，就是触发HashMap扩容的阈值，当HashMap的数据量达到或超过threshold时，就会扩容。</p><p>我们再往下看这个tableSizeFor(int cap)的构造方法<br><img src="https://img-blog.csdnimg.cn/9c1e459e5575442c97e23fb351f9d51c.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5rGf5rqq5rC0,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>在 tableSizeFor(int cap)这个构造方法中，对传入的参数cap进行了多次位运算，这样可以让返回值保持在 2 的 N 次方，在扩容的时候，可以快速计算数据在扩容后的新表中的位置。</p><h2 id="HashMap-的-table-初始化"><a href="#HashMap-的-table-初始化" class="headerlink" title="HashMap 的 table 初始化"></a>HashMap 的 table 初始化</h2><p>从上面的源码大家可以发现一个问题，整个计算阈值的过程中，装载因子loadFactor并没有参与运算</p><p>实际上，在HashMap中，所有的数据都是存储在数组中，这个数组的大小就是阈值与加载因子的乘积</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">table<span class="token punctuation">.</span>size <span class="token operator">==</span> threshold <span class="token operator">*</span> loadFactor<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="HashMap的动态扩容"><a href="#HashMap的动态扩容" class="headerlink" title="HashMap的动态扩容"></a>HashMap的动态扩容</h2><ul><li>在 HashMap 中，动态扩容是 resize() 方法</li><li>这个方法了 table 的扩容，它还承担了 table 的初始化。</li></ul><p>我们先看看HashMap中put一个元素的过程，最终调用的是putVal这个方法，我们看看源码</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">final</span> <span class="token class-name">V</span> <span class="token function">putVal</span><span class="token punctuation">(</span><span class="token keyword">int</span> hash<span class="token punctuation">,</span> <span class="token class-name">K</span> key<span class="token punctuation">,</span> <span class="token class-name">V</span> value<span class="token punctuation">,</span> <span class="token keyword">boolean</span> onlyIfAbsent<span class="token punctuation">,</span>                   <span class="token keyword">boolean</span> evict<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> tab<span class="token punctuation">;</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> p<span class="token punctuation">;</span> <span class="token keyword">int</span> n<span class="token punctuation">,</span> i<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>tab <span class="token operator">=</span> table<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> <span class="token punctuation">(</span>n <span class="token operator">=</span> tab<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>            n <span class="token operator">=</span> <span class="token punctuation">(</span>tab <span class="token operator">=</span> <span class="token function">resize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>p <span class="token operator">=</span> tab<span class="token punctuation">[</span>i <span class="token operator">=</span> <span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> hash<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>            tab<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">newNode</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>            <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> e<span class="token punctuation">;</span> <span class="token class-name">K</span> k<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>p<span class="token punctuation">.</span>hash <span class="token operator">==</span> hash <span class="token operator">&amp;&amp;</span>                <span class="token punctuation">(</span><span class="token punctuation">(</span>k <span class="token operator">=</span> p<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> key <span class="token operator">||</span> <span class="token punctuation">(</span>key <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                e <span class="token operator">=</span> p<span class="token punctuation">;</span>            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token keyword">instanceof</span> <span class="token class-name">TreeNode</span><span class="token punctuation">)</span>                e <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span><span class="token punctuation">)</span>p<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">putTreeVal</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> tab<span class="token punctuation">,</span> hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> binCount <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token punctuation">;</span> <span class="token operator">++</span>binCount<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> p<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                        p<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token function">newNode</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token keyword">if</span> <span class="token punctuation">(</span>binCount <span class="token operator">>=</span> TREEIFY_THRESHOLD <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token comment">// -1 for 1st</span>                            <span class="token function">treeifyBin</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span> hash<span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token keyword">break</span><span class="token punctuation">;</span>                    <span class="token punctuation">&#125;</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span>hash <span class="token operator">==</span> hash <span class="token operator">&amp;&amp;</span>                        <span class="token punctuation">(</span><span class="token punctuation">(</span>k <span class="token operator">=</span> e<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> key <span class="token operator">||</span> <span class="token punctuation">(</span>key <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                        <span class="token keyword">break</span><span class="token punctuation">;</span>                    p <span class="token operator">=</span> e<span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>e <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// existing mapping for key</span>                <span class="token class-name">V</span> oldValue <span class="token operator">=</span> e<span class="token punctuation">.</span>value<span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>onlyIfAbsent <span class="token operator">||</span> oldValue <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>                    e<span class="token punctuation">.</span>value <span class="token operator">=</span> value<span class="token punctuation">;</span>                <span class="token function">afterNodeAccess</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">return</span> oldValue<span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token operator">++</span>modCount<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">++</span>size <span class="token operator">></span> threshold<span class="token punctuation">)</span>            <span class="token function">resize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">afterNodeInsertion</span><span class="token punctuation">(</span>evict<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在resize()中，它调整了扩容阈值threshold，并且完成了对table的初始化。我们看看resize()的源码</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">final</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">resize</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> oldTab <span class="token operator">=</span> table<span class="token punctuation">;</span>        <span class="token keyword">int</span> oldCap <span class="token operator">=</span> <span class="token punctuation">(</span>oldTab <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> oldTab<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token keyword">int</span> oldThr <span class="token operator">=</span> threshold<span class="token punctuation">;</span>        <span class="token keyword">int</span> newCap<span class="token punctuation">,</span> newThr <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>oldCap <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>oldCap <span class="token operator">>=</span> MAXIMUM_CAPACITY<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                threshold <span class="token operator">=</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span>MAX_VALUE<span class="token punctuation">;</span>                <span class="token keyword">return</span> oldTab<span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>newCap <span class="token operator">=</span> oldCap <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> MAXIMUM_CAPACITY <span class="token operator">&amp;&amp;</span>                     oldCap <span class="token operator">>=</span> DEFAULT_INITIAL_CAPACITY<span class="token punctuation">)</span>                newThr <span class="token operator">=</span> oldThr <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// double threshold</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>oldThr <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token comment">// initial capacity was placed in threshold</span>        <span class="token comment">//当我们指定了初始容量，且 table 未被初始化时，oldThr 就不为 0，</span>        <span class="token comment">//将 newCap 赋值为 oldThr，新创建的 table 会是我们构造的 HashMap 时指定的容量值。</span>            newCap <span class="token operator">=</span> oldThr<span class="token punctuation">;</span>        <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>               <span class="token comment">// zero initial threshold signifies using defaults</span>            newCap <span class="token operator">=</span> DEFAULT_INITIAL_CAPACITY<span class="token punctuation">;</span>            newThr <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">(</span>DEFAULT_LOAD_FACTOR <span class="token operator">*</span> DEFAULT_INITIAL_CAPACITY<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>newThr <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">//通过装载因子（loadFactor）调整了新的阈值（newThr）</span>            <span class="token keyword">float</span> ft <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">float</span><span class="token punctuation">)</span>newCap <span class="token operator">*</span> loadFactor<span class="token punctuation">;</span>            newThr <span class="token operator">=</span> <span class="token punctuation">(</span>newCap <span class="token operator">&lt;</span> MAXIMUM_CAPACITY <span class="token operator">&amp;&amp;</span> ft <span class="token operator">&lt;</span> <span class="token punctuation">(</span><span class="token keyword">float</span><span class="token punctuation">)</span>MAXIMUM_CAPACITY <span class="token operator">?</span>                      <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>ft <span class="token operator">:</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span>MAX_VALUE<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">// 使用 loadFactor 调整后的阈值，重新保存到 threshold 中</span>        threshold <span class="token operator">=</span> newThr<span class="token punctuation">;</span>        <span class="token annotation punctuation">@SuppressWarnings</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span><span class="token string">"rawtypes"</span><span class="token punctuation">,</span><span class="token string">"unchecked"</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span>        <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> newTab <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">[</span>newCap<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token comment">//通过 newCap 创建新的数组，将其指定到 table 上，完成 table 的初始化</span>        table <span class="token operator">=</span> newTab<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>oldTab <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> oldCap<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> e<span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> oldTab<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    oldTab<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span>next <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>                        newTab<span class="token punctuation">[</span>e<span class="token punctuation">.</span>hash <span class="token operator">&amp;</span> <span class="token punctuation">(</span>newCap <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> e<span class="token punctuation">;</span>                    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>e <span class="token keyword">instanceof</span> <span class="token class-name">TreeNode</span><span class="token punctuation">)</span>                        <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span><span class="token punctuation">)</span>e<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> newTab<span class="token punctuation">,</span> j<span class="token punctuation">,</span> oldCap<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">else</span> <span class="token punctuation">&#123;</span> <span class="token comment">// preserve order</span>                        <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> loHead <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">,</span> loTail <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>                        <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> hiHead <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">,</span> hiTail <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>                        <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> next<span class="token punctuation">;</span>                        <span class="token keyword">do</span> <span class="token punctuation">&#123;</span>                            next <span class="token operator">=</span> e<span class="token punctuation">.</span>next<span class="token punctuation">;</span>                            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span>hash <span class="token operator">&amp;</span> oldCap<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                                <span class="token keyword">if</span> <span class="token punctuation">(</span>loTail <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>                                    loHead <span class="token operator">=</span> e<span class="token punctuation">;</span>                                <span class="token keyword">else</span>                                    loTail<span class="token punctuation">.</span>next <span class="token operator">=</span> e<span class="token punctuation">;</span>                                loTail <span class="token operator">=</span> e<span class="token punctuation">;</span>                            <span class="token punctuation">&#125;</span>                            <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>                                <span class="token keyword">if</span> <span class="token punctuation">(</span>hiTail <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>                                    hiHead <span class="token operator">=</span> e<span class="token punctuation">;</span>                                <span class="token keyword">else</span>                                    hiTail<span class="token punctuation">.</span>next <span class="token operator">=</span> e<span class="token punctuation">;</span>                                hiTail <span class="token operator">=</span> e<span class="token punctuation">;</span>                            <span class="token punctuation">&#125;</span>                        <span class="token punctuation">&#125;</span> <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> next<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token keyword">if</span> <span class="token punctuation">(</span>loTail <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                            loTail<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>                            newTab<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> loHead<span class="token punctuation">;</span>                        <span class="token punctuation">&#125;</span>                        <span class="token keyword">if</span> <span class="token punctuation">(</span>hiTail <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                            hiTail<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>                            newTab<span class="token punctuation">[</span>j <span class="token operator">+</span> oldCap<span class="token punctuation">]</span> <span class="token operator">=</span> hiHead<span class="token punctuation">;</span>                        <span class="token punctuation">&#125;</span>                    <span class="token punctuation">&#125;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> newTab<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>所有我们传递进来的 initialCapacity 虽然经过 tableSizeFor() 方法调整后，直接赋值给 threshold</li><li>但是它实际是 table 的大小，并且最终会通过 loadFactor 重新调整 threshold。</li></ul><h2 id="经典面试题"><a href="#经典面试题" class="headerlink" title="经典面试题"></a>经典面试题</h2><h3 id="计划用HashMap存1k条数据，构造时传1000会触发扩容吗"><a href="#计划用HashMap存1k条数据，构造时传1000会触发扩容吗" class="headerlink" title="计划用HashMap存1k条数据，构造时传1000会触发扩容吗"></a>计划用HashMap存1k条数据，构造时传1000会触发扩容吗</h3><ul><li> HashMap 初始容量指定为 1000，会被 tableSizeFor() 调整为 1024；</li><li>但是它只是表示 table 数组为 1024；</li><li>负载因子是0.75，扩容阈值会在 resize() 中调整为 768（1024 * 0.75）</li><li>会触发扩容</li></ul><p>如果需要存储1k的数据，应该传入1000 / 0.75(1333)</p><ul><li>tableSizeFor() 方法调整到 2048，不会触发扩容。</li></ul><h3 id="计划用HashMap存1w条数据，构造时传10000会触发扩容吗"><a href="#计划用HashMap存1w条数据，构造时传10000会触发扩容吗" class="headerlink" title="计划用HashMap存1w条数据，构造时传10000会触发扩容吗"></a>计划用HashMap存1w条数据，构造时传10000会触发扩容吗</h3><ul><li>当我们构造HashMap时，参数传入进来 1w </li><li>经过 tableSizeFor() 方法处理之后，就会变成 2 的 14 次幂 16384</li><li>负载因子是 0.75f，可存储的数据容量是 12288（16384 * 0.75f）</li><li>完全够用，不会触发扩容</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HashMap </tag>
            
            <tag> 扩容 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL索引(二)</title>
      <link href="/posts/19546.html"/>
      <url>/posts/19546.html</url>
      
        <content type="html"><![CDATA[<h1 id="MySQL索引-二"><a href="#MySQL索引-二" class="headerlink" title="MySQL索引(二)"></a>MySQL索引(二)</h1><h2 id="自适应哈希索引"><a href="#自适应哈希索引" class="headerlink" title="自适应哈希索引"></a>自适应哈希索引</h2><ul><li>自适应哈希索引是InnoDB引擎的一个特殊功能，当它注意到某些索引值被使用的非常频繁时，会在内<br>存中基于B-Tree索引之上再创键一个哈希索引，这样就让B-Tree索引也具有哈希索引的一些优点，比<br>如快速哈希查找</li><li>这是一个完全自动的内部行为，用户无法控制或配置，但如果有必要可以关闭该功能。</li></ul><h2 id="空间索引"><a href="#空间索引" class="headerlink" title="空间索引"></a>空间索引</h2><ul><li>MyISAM的表支持空间索引，可以用作地理数据存储</li><li>和B-Tree索引不同，这类索引无需前缀查询。</li><li>空间索引会从所有维度来索引数据，查询时可以有效地使用任意维度来组合查询。</li><li>必须使用MySQL的GIS即地理信息系统的相关函数来维护数据</li><li>MySQL对地理信息的支持并不完善，因此大基本不会使用这种索引。</li></ul><h2 id="全文索引"><a href="#全文索引" class="headerlink" title="全文索引"></a>全文索引</h2><p>通过数值比较、范围过滤等就可以完成绝大多数需要的查询，但如果希望通过关键字匹配进行查询，就<br>需要基于相似度的查询，而不是精确的数值比较，全文索引就是为这种场景设计的。</p><ul><li>MyISAM的全文索引是一种特殊的B-Tree索引，共有两层</li><li>第一层是所有关键字，然后对于每一个关键字的第二层，包含的是一组相关的”文档指针”。</li><li>全文索引不会索引文档对象中的所有词语，它会根据规则过滤掉一些词语</li></ul><h2 id="聚簇索引"><a href="#聚簇索引" class="headerlink" title="聚簇索引"></a>聚簇索引</h2><p>聚簇索引并不是一种索引类型，而是一种数据存储方式。InnoDB 的聚簇索引实际上在同一个结构中保存<br>了B-Tree索引和数据行。当表有聚餐索引时，它的行数据实际上存放在索引的叶子页中，因为无法同<br>时把数据行存放在两个不同的地方，所以一个表只能有一个聚簇索引。聚簇索引也叫主键索引</p><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul><li>可以把相关数据保存在一起，将数据放在索引树的叶子节点下，找到叶子就可以找到数据</li><li>数据访问更快，聚簇索引将索引和数据保存在同一个B-Tree中，因此获取数据比非聚簇索引要更快。</li><li>使用覆盖索引扫描的查询可以直接使用页节点中的主键值。<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4></li><li>聚簇索引最大限度提高了IO密集型应用的性能，如果数据全部在内存中将会失去优势</li><li>更新聚簇索引列的代价很高，因为会强制每个被更新的行移动到新位置</li><li>基于聚簇索引的表插入新行或主键被更新导致行移动时，可能导致页分裂，表会占用更多磁盘空间</li><li>当行稀疏或由于页分裂导致数据存储不连续时，全表扫描可能很慢。</li></ul><h2 id="非聚簇索引"><a href="#非聚簇索引" class="headerlink" title="非聚簇索引"></a>非聚簇索引</h2><ul><li>非聚簇索引是在索引树的叶子节点上存放数据的地址，找到该地址后，需要到磁盘中查询一次才能获取到数据。</li><li>MyISAM存储引擎的索引方式就是非聚簇索引，只在索引树的叶子节点上存放地址。</li></ul><h4 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h4><ul><li>在InnoDB 里，索引 B+Tree 的叶子节点存储了”整行数据”的是主键索引，也被称之为聚簇索引</li><li>索引B+Tree的叶子节点只存储了”主键的值和索引列”的是非主键索引，也被称之为非聚簇索引</li></ul><h2 id="索引覆盖"><a href="#索引覆盖" class="headerlink" title="索引覆盖"></a>索引覆盖</h2><p>覆盖索引指一个索引包含或覆盖了所有需要查询的字段的值，不再需要根据索引回表查询数据。覆盖索<br>引必须要存储索引列的值，因此MySQL只能使用B-Tree索引做覆盖索引。</p><h4 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h4><ul><li>索引条目通常远小于数据行大小，可以极大减少数据访问量</li><li>因为索引按照列值顺序存储，所以对于IO密集型防伪查询回避随机从磁盘读取每一行数据的IO少得多</li><li>由于InnoDB使用.聚簇索引，覆盖索引对InnoDB很有帮助。InnoDB 的二级索引在叶子节点保存了行的主键值，如果二级主键能覆盖查询那么可以避免对主键索引的二次查询。</li></ul><h2 id="什么情况下索引失效"><a href="#什么情况下索引失效" class="headerlink" title="什么情况下索引失效"></a>什么情况下索引失效</h2><ul><li>模糊查询 %like</li><li>索引列参与计算,使用了函数</li><li>非最左前缀顺序</li><li>where单列索引对null判断 </li><li>where不等于</li><li>or操作有至少一个字段没有索引</li><li>需要回表的查询结果集过大（超过配置的范围）</li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
            <tag> 索引 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TCP三次握手和四次挥手</title>
      <link href="/posts/37932.html"/>
      <url>/posts/37932.html</url>
      
        <content type="html"><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><h4 id="SYN-Synchronize-Sequence-Numbers"><a href="#SYN-Synchronize-Sequence-Numbers" class="headerlink" title="SYN-(Synchronize Sequence Numbers)"></a>SYN-(Synchronize Sequence Numbers)</h4><ul><li>同步序列编号。是TCP/IP建立连接时使用的握手信号。在客户机和服务器之间建立TCP连接时，首先会发送的一个信号。客户端在接受到SYN消息时，就会在自己的段内生成一个随机值seq=x。<h4 id="ACK-Acknowledge-character"><a href="#ACK-Acknowledge-character" class="headerlink" title="ACK-(Acknowledge character)"></a>ACK-(Acknowledge character)</h4></li><li>确认字符，表示发来的数据已确认接收无误。最后，客户端将ACK发送给服务器。序列号被设置为所接收的确认值即Y + 1。<h4 id="SYN-ACK"><a href="#SYN-ACK" class="headerlink" title="SYN-ACK"></a>SYN-ACK</h4></li><li>服务器收到SYN后，打开客户端连接，发送一个SYN-ACK作为答复。确认号设置为比接收到的序列号多一个，即X+ 1，服务器为数据包选择的序列号是另一个随机数Y。<h4 id="FIN"><a href="#FIN" class="headerlink" title="FIN"></a>FIN</h4></li><li>用于断开连接的</li></ul><h2 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h2><h4 id="三次握手过程"><a href="#三次握手过程" class="headerlink" title="三次握手过程"></a>三次握手过程</h4><p>建立TCP连接需要进行三次握手，分配初始序列号和资源，在相互确认之后才开始数据的传输。握手初始化了传输可靠性以及数据顺序性必要的信息，这些信息包括两个方向的初始序列号，确认号由初始序列号生成，使用3次握手是因为3次握手已经准备好了传输可靠性以及数据顺序性所必要的信息</p><ul><li>客户端主动打开</li><li>服务端被动打开</li></ul><h3 id="握手过程"><a href="#握手过程" class="headerlink" title="握手过程"></a>握手过程</h3><p><img src="https://img-blog.csdnimg.cn/64eada28b1244e1a93be6d2a1cf55a71.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5rGf5rqq5rC0,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><ul><li><p>第一次握手:客户端将标志位SYN置为1，随机产生一个值序列号seq=x，并将该数据包发送给服务端，客户端进入syn_sent状态，等待服务端确认。</p></li><li><p>第二次握手:服务端收到数据包后由标志位SYN=1知道客户端请求建立连接，服务端将标志位SYN和 ACK都置为1，ack=x+1,随机产生一个值seq=y，并将该数据包发送给客户端以确认连接请求，服务端进入syn_rcvd状态。</p></li><li><p>第三次握手:客户端收到确认后检查,如果正确则将标志位ACK为1，ack=y+1，并将该数据包发送给服务端，服务端进行检查如果正确则连接建立成功，客户端和服务端进入established状态，完成三次握手，随后客户端和服务端之间可以开始传输数据了</p></li></ul><h4 id="为什么需要三次握手"><a href="#为什么需要三次握手" class="headerlink" title="为什么需要三次握手"></a>为什么需要三次握手</h4><ul><li>TCP的连接是发送消息两个方向的连接都要建立成功。</li><li>如果要保证双向连接都成功的话，三次通信是最少的次数了。</li><li>大于三次的话，后面的次数通信就没有必要了，是在浪费资源。</li></ul><h2 id="TCP四次挥手"><a href="#TCP四次挥手" class="headerlink" title="TCP四次挥手"></a>TCP四次挥手</h2><p>断开TCP连接需要四次挥手</p><h4 id="挥手过程"><a href="#挥手过程" class="headerlink" title="挥手过程"></a>挥手过程</h4><p><img src="https://img-blog.csdnimg.cn/d6b11ef8598a4a78b47dfe037816ebfd.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5rGf5rqq5rC0,size_15,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><ul><li><p>第一次挥手：客户端发送一个FIN，用来关闭客户端到服务端的数据传送，客户端进入finwait1状态。</p></li><li><p>第二次挥手：服务端收到FIN后，发送一个ACK给客户端，确认序号为收到序号+1，服务端进入Close_wait状态。此时TCP连接处于半关闭状态，即客户端已经没有要发送的数据了，但服务端若发送数据，则客户端仍要接收。</p></li><li><p>第三次挥手：服务端发送一个FIN，用来关闭服务端到客户端的数据传送，服务端进入Last_ack状态。</p></li><li><p>第四次挥手：客户端收到FIN后，客户端进入Time_wait状态，接着发送一个ACK给服务端，确认后，服务端进入Closed状态，完成四次挥手。</p></li></ul><h4 id="为什么要四次挥手"><a href="#为什么要四次挥手" class="headerlink" title="为什么要四次挥手"></a>为什么要四次挥手</h4><ul><li>任何一方都可以在数据传送结束后发出连接释放的通知，待对方确认后进入半关闭状态。</li><li>当另一方也没有数据再发送的时候，则发出连接释放通知，对方确认后就完全关闭了TCP连接。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TCP </tag>
            
            <tag> 三次握手 </tag>
            
            <tag> 四次挥手 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL索引(一)</title>
      <link href="/posts/36094.html"/>
      <url>/posts/36094.html</url>
      
        <content type="html"><![CDATA[<h1 id="MySQL索引"><a href="#MySQL索引" class="headerlink" title="MySQL索引"></a>MySQL索引</h1><h2 id="索引是什么"><a href="#索引是什么" class="headerlink" title="索引是什么"></a>索引是什么</h2><p>索引是数据库中用来提高性能的常用工具，索引在 MySQL 中也叫“键（Key）”，是存储引擎用于快速查找记录的一种数据结构，这也是索引的基本功能。</p><ul><li>索引对于良好的性能很关键，尤其是当表中数据量越来越大时，索引对性能的影响愈发重要</li><li>在数据量较小且负载较低时，不恰当的索引对性能的影响可能还不明显，但数据量逐渐增大时，性能会急剧下降。</li><li>索引类似一本书的目录，如果要在一本书中找到特定的知识点，先通过目录找到对应的页码</li><li>在 MySQL 中，存储引擎用类似的方法使用索引，先在索引找到对应值，再根据索引记录找到对应的数据行。</li><li>索引就是为了提高数据查询的效率，跟一本书的目录一样。</li></ul><h2 id="索引的优点"><a href="#索引的优点" class="headerlink" title="索引的优点"></a>索引的优点</h2><p>在MySQL中，首先在索引中找到对应的值，然后根据匹配的索引记录找到对应的数据行。索引可以包括<br>一个或多个列的值，如果索引包含多个列，那么列的顺序也十分重要，因为MySQL只能使用索引的最<br>左前缀。</p><ul><li>索引大大减少了服务器需要扫描的数据量</li><li>可以帮助服务器避免排序和临时表</li><li>可以将随机IO变成顺序IO。</li><li>但对于非常小的表，大部分情况下会采用全表扫描。这样更高效</li><li>对于中到大型的表，索引就非常有效。但对于特大型的表，建立和使用索引的代价也随之增长</li></ul><h2 id="哈希索引"><a href="#哈希索引" class="headerlink" title="哈希索引"></a>哈希索引</h2><h4 id="哈希索引-1"><a href="#哈希索引-1" class="headerlink" title="哈希索引"></a>哈希索引</h4><ul><li>哈希索引基于哈希表实现，只有精确匹配索引所有列的查询才有效。</li><li>对于每一行数据, 存储引擎都会对所有的索引列计算一个哈希码，哈希码是一个较小的值， 并且不同键值的行计算出的哈希码也不一样。</li><li>哈希索引将所有的哈希码存储在索引中，同时在哈希表中保存指向每个数据行的指针。</li><li>只有Memory引擎显式支持哈希索引，这也是Memory引擎的默认索引类型。</li><li>因为索引自身只需存储对应的哈希值，所以索引的结构十分紧凑，这让哈希索引的速度非常快</li></ul><h4 id="哈希索引的限制"><a href="#哈希索引的限制" class="headerlink" title="哈希索引的限制"></a>哈希索引的限制</h4><ul><li>哈希索引数据不是按照索引值顺序存储的，无法用于排序。</li><li>哈希索引不支持部分索引列匹配查找，因为哈希索引始终是使用索引列的全部内容来计算哈希值<br>的。例如在数据列(a,b). 上建立哈希索引,如果查询的列只有a就无法使用该索引。</li><li>哈希索引只支持等值比较查询，不支持任何范围查询。</li></ul><h2 id="B-Tree索引"><a href="#B-Tree索引" class="headerlink" title="B-Tree索引"></a>B-Tree索引</h2><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><ul><li>不同的存储引擎有不同是底层数据结构，在InnoDB中使用B+ Tree索引</li><li>B-Tree通常意味着所有的值都是按顺序存储的，并且每个叶子页到根的距离相同</li><li>B-Tree 索引能够加快访问数据的速度，因为存储引擎不再需要进行全表扫描来获取需要的数据，取而代之的是从索引的根节点开始进行搜索。</li><li>根节点的槽中存放了指向子节点的指针,存储引擎根据这些指针向下层查找。通过比较节点页的值和要查找的值可以找到合适的指针进入下层子节点，这些指针实际上定义了子节点页中值的上限和下限。</li><li>最终存储引擎要么找到对应的值，要么该记录不存在。叶子节点的指针指向的是被索引的数据，而不是其他的节点页。</li></ul><h4 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h4><p><img src="https://img-blog.csdnimg.cn/dc5c7e61c22748979fc3c3f673b148bd.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5rGf5rqq5rC0,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><h4 id="B-Tree索引的限制"><a href="#B-Tree索引的限制" class="headerlink" title="B-Tree索引的限制"></a>B-Tree索引的限制</h4><ul><li>如果不是按照索引的最左列开始查找,则无法使用索引。</li><li>不能跳过索引中的列，例如索引为(id,name,sex), 不能只使用id和sex而跳过name。</li><li>如果查询中有某个列的范围查询，则其右边的所有列都无法使用索引。</li></ul><h2 id="B-Tree索引-1"><a href="#B-Tree索引-1" class="headerlink" title="B+Tree索引"></a>B+Tree索引</h2><h4 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h4><p>B+Tree索引的结构与B-Tree索引类似<br><img src="https://img-blog.csdnimg.cn/e1487aa4d203421d9934c8b671f8044f.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5rGf5rqq5rC0,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><h4 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h4><ul><li>B+Tree的非叶子节点不存储数据，所有data存储在叶子节点，导致查询查询时间复杂度为log</li><li>而B-Tree的查询时间复杂度不固定，与关键字在树中的位置有关，最好为O(1)</li><li>B+Tree的节点两两相连可大大增加区间访问性，可使用范围查询等</li><li>而B-Tree每个节点关键字和data在一起，无法区间查找</li><li>B+Tree更适合外部存储，由于内节点无data域，每个节点能索引的范围更大更精确</li></ul><h2 id="InnoDB为什么选择B-树作为索引结构"><a href="#InnoDB为什么选择B-树作为索引结构" class="headerlink" title="InnoDB为什么选择B+树作为索引结构"></a>InnoDB为什么选择B+树作为索引结构</h2><h4 id="Hash索引"><a href="#Hash索引" class="headerlink" title="Hash索引"></a>Hash索引</h4><ul><li>Hash索引底层是哈希表，哈希表是一种以key-value存储数据的结构，所以多个数据在存储关系上是完全没有任何顺序关系的，所以，对于区间查询是无法直接通过索引查询的，就需要全表扫描。所以，哈希索引只适用于等值查询的场景。而B+ 树是一种多路平衡查询树，所以他的节点是天然有序的（左子节点小于父节点、父节点小于右子节点），所以对于范围查询的时候不需要做全表扫描<h4 id="二叉查找树"><a href="#二叉查找树" class="headerlink" title="二叉查找树"></a>二叉查找树</h4></li><li>解决了排序的基本问题，但是由于无法保证平衡，可能退化为链表。<h4 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h4></li><li>通过旋转解决了平衡的问题，但是旋转操作效率太低。<h4 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h4></li><li>通过舍弃严格的平衡和引入红黑节点，解决了AVL旋转效率过低的问题，但是在磁盘等场景下，树仍然太高，IO次数太多。<h4 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h4></li><li>在B树的基础上，将非叶节点改造为不存储数据纯索引节点，进一步降低了树的高度；此外将叶节点使用指针连接成链表，范围查询更加高效。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
            <tag> 索引 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL的存储引擎</title>
      <link href="/posts/23763.html"/>
      <url>/posts/23763.html</url>
      
        <content type="html"><![CDATA[<h1 id="MySQL存储引擎"><a href="#MySQL存储引擎" class="headerlink" title="MySQL存储引擎"></a>MySQL存储引擎</h1><p>MySQL 提供不同的技术存储数据，这些技术使用不同的数据存储机制、索引建立方式、锁方式来完成数据的构建，这些技术统称为存储引擎。</p><p>MySQL 至少支持 9 种存储引擎，目前最受关注的是 InnoDB 和 MyISAM 存储引擎</p><h2 id="MyISAM"><a href="#MyISAM" class="headerlink" title="MyISAM"></a>MyISAM</h2><ul><li><p>MySQL5.5版之前的默认数据库引擎，性能不错，而且提供了大量的特性，包括全文索引、压缩、空间函数等</p></li><li><p>但MyISAM不支持事务和行级锁， 而且崩溃后无法安全恢复。</p><h2 id="InnoDB"><a href="#InnoDB" class="headerlink" title="InnoDB"></a>InnoDB</h2></li><li><p>由于MyISAM的不足，MySQL引入了InnoDB (事务性数据库引擎)</p></li><li><p>MySQL 5. 5版本后默认的存储引擎为InnoDB，我们使用的基本都是InnoDB 存储引擎</p></li><li><p>但是在某些情况下使用MyISAM 也是合适的比如读操作非常频繁的情况下。</p><h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2></li><li><p>是否支持行级锁: MyISAM 只有表级锁, 而InnoDB 支持行级锁和表级锁 ，默认为行级锁。</p></li><li><p>是否支持事务和崩溃后的安全恢复: MyISAM 强调的是性能，每次查询具有原子性，其执行速度比InnoDB更快，但是不提供事务支持。</p></li><li><p>InnoDB提供事务支持事务，外部键等高级数据库功能。具有事务、回滚和崩溃修复能力的事务安全表。</p></li><li><p>是否支持外键: MyISAM不支持，而InnoDB支持。</p></li><li><p>是否支持MVCC :InnoDB支持，MyISAM不支持。应对高并发事务，MVCC比单纯的加锁更高效;</p></li><li><p>MVCC只在 读取已提交和可重复读两个隔离级别下工作;</p></li><li><p>MVCC可以使用乐观锁 和悲观锁来实现</p></li></ul><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><ul><li><p>MyISAM 对于不支持事务并且存在大量 SELECT 的读场景比较合适；</p></li><li><p>如果业务代码中要支持事务，必须选择 InnoDB 存储引擎；</p></li><li><p>如果业务代码中要支持外键，必须选择 InnoDB 存储引擎；</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
            <tag> 存储引擎 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一条SQL更新语句是如何执行的</title>
      <link href="/posts/35870.html"/>
      <url>/posts/35870.html</url>
      
        <content type="html"><![CDATA[<h2 id="MySQL日志文件"><a href="#MySQL日志文件" class="headerlink" title="MySQL日志文件"></a>MySQL日志文件</h2><h3 id="二进制日志-binlog"><a href="#二进制日志-binlog" class="headerlink" title="二进制日志-binlog"></a>二进制日志-binlog</h3><ul><li><p>二进制日志，其实就是我们平常所说的 binlog，它是 MySQL 重要的日志模块，在 Server 层实现。</p></li><li><p>binlog 以二进制形式，将所有修改数据的 query 记录到日志文件中，包括 query 语句、执行时间、相关事务信息等。</p></li></ul><h3 id="InnoDB-redo-log"><a href="#InnoDB-redo-log" class="headerlink" title="InnoDB-redo log"></a>InnoDB-redo log</h3><ul><li>redo log，是存储引擎 InnoDB 生成的日志，主要为了保证数据的可靠性</li><li>redo log 记录了 InnoDB 所做的所有物理变更和事务信息。</li><li>redo log 默认存放在数据目录下面，可以通过修改 innodb_log_file_size 和 innodb_log_files_in_group 来配置redo log 的文件数量和每个日志文件的大小。</li></ul><h3 id="错误日志-error-log"><a href="#错误日志-error-log" class="headerlink" title="错误日志-error log"></a>错误日志-error log</h3><ul><li>错误日志，记录 MySQL 每次启动关闭的详细信息，以及运行过程中比较严重的警告和错误信息。</li><li>错误日志默认是关闭的，可以通过配置参数 log-error 进行开启，以及指定存储路径。</li></ul><h3 id="慢查询日志-slow-query-log"><a href="#慢查询日志-slow-query-log" class="headerlink" title="慢查询日志-slow query log"></a>慢查询日志-slow query log</h3><ul><li>慢查询日志，记录 MySQL 中执行时间较长的 query，包括执行时间、执行时长、执行用户、主机等信息。</li><li>慢查询日志默认是关闭的，可以通过配置 slow_query_log 进行开启</li><li>慢查询的阈值和存储路径，通过配置参数 long_query_time 和 slow_query_log_file 实现。</li></ul><h3 id="一般查询日志-general-query-log"><a href="#一般查询日志-general-query-log" class="headerlink" title="一般查询日志-general query log"></a>一般查询日志-general query log</h3><ul><li>一般查询日志，记录 MySQL 中所有的 query</li><li>慢查询记录的是超过阈值的 query，而一般查询日志记录的是所有的 query。</li><li>一般查询日志的开启需要慎重，因为开启后对 MySQL 的性能有比较大的影响。</li><li>一般查询日志默认是关闭的，可以通过配置参数 general_log 进行开启</li><li>存储路径可以通过配置参数 general_log_file 来实现</li></ul><h3 id="binlog和redo-log的区别"><a href="#binlog和redo-log的区别" class="headerlink" title="binlog和redo log的区别"></a>binlog和redo log的区别</h3><ul><li>binlog是逻辑日志，记录SQL语句的基本逻辑；redo log是物理日志，记录在数据页所做的修改；</li><li>binlog是在Server层实现，所有的存储引擎都可以使用binlog这个日志模块；redo log是InnoDB存储引擎特有的日志模块；</li><li>binlog是追加写，在写满或重启之后，会生成新的binlog文件，之前的日志不会进行覆盖；redo log是循环写，空间大小是固定的；</li><li>binlog 是在事务最终提交前写入的；redo log是在事务执行过程不断的写入；</li><li>binlog可以应用于数据归档、主从搭建等场景；redo log作为异常宕机或者介质故障后的数据恢复使用；</li></ul><h2 id="一条更新语句是如何执行的"><a href="#一条更新语句是如何执行的" class="headerlink" title="一条更新语句是如何执行的"></a>一条更新语句是如何执行的</h2><p>更新语句的执行流程比查询语句多了两个重要的日志模块： binlog（归档日志）和redo log（重做日志）</p><pre class="line-numbers language-none"><code class="language-none">update student set sex&#x3D;&#39;女&#39; where name&#x3D;&#39; 李四 &#39;;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol><li>先查询到李四这一条数据，如果命中缓存会之间返回</li><li>执行器拿到查询的数据，把 sex 改为 女，然后调用引擎 API 接口，写入这一行数据，</li><li>InnoDB 引擎把数据保存在内存中，同时记录 redo log，此时 redo log 进入 prepare 状态，</li><li>执行器生成更新操作的 binlog，并写入磁盘</li><li>调用引擎接口提交事务，更新 redo log为commit状态，更新完成。</li></ol><p>上述过程便是 redo log 两阶段提交，如果不这样会发生什么</p><h4 id="先redo-log后binlog"><a href="#先redo-log后binlog" class="headerlink" title="先redo log后binlog"></a>先redo log后binlog</h4><ul><li>假设更新完 redo log 后，数据库宕机，没有被写入binlog 日志</li><li>数据库重启后会通过 redo log 恢复数据，但是 bingog 并没有记录这个更新</li><li>就会丢失这一条数据，主从同步也会丢失这一条数据<h4 id="先binlog后redo-log"><a href="#先binlog后redo-log" class="headerlink" title="先binlog后redo log"></a>先binlog后redo log</h4></li><li>假设先写了 binlog，数据库宕机，没有更新redo log</li><li>数据库重启后是无法恢复这一条记录的</li><li>但是binlog又有记录，就会导致数据不一致<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2>分析器—&gt;权限校验—&gt;执行器—&gt;执行引擎—&gt;redo log prepare—&gt;binlog日志—&gt;redo log commit</li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 更新语句 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一条SQL查询语句是如何执行的</title>
      <link href="/posts/62911.html"/>
      <url>/posts/62911.html</url>
      
        <content type="html"><![CDATA[<h2 id="MySQL数据库的架构"><a href="#MySQL数据库的架构" class="headerlink" title="MySQL数据库的架构"></a>MySQL数据库的架构</h2><p>MySQL 包含 Server 层和存储引擎层两大部分。</p><h4 id="存储引擎层"><a href="#存储引擎层" class="headerlink" title="存储引擎层"></a>存储引擎层</h4><p>负责数据的存储和提取，MySQL 采用插件式的存储引擎，常见的存储引擎有</p><ul><li>InnoDB</li><li>MyISAM</li><li> CSV</li></ul><p>其中 InnoDB 是最常用的存储引擎，也是 MySQL 的默认存储引擎</p><h4 id="Server-层"><a href="#Server-层" class="headerlink" title="Server 层"></a>Server 层</h4><ul><li>连接池： 用来身份认证和权限验证</li><li>查询缓存:  执行查询语句的时候，会先查询缓存，命中缓存之间返回</li><li>分析器:  没有命中缓存的话，SQL 语句就会经过分析器，检查你的 SQL 语句语法是否正确，分析你的 SQL 语句要干什么</li><li>优化器： 优化成最优的执行方案去执行</li><li>执行器:  执行优化后的语句，然后从存储引擎返回数据</li></ul><p><img src="https://img-blog.csdnimg.cn/e94eae580c404bdbb58a12efcb1ed1f1.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Vwc3RyZWFtNDgw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h4 id="连接器"><a href="#连接器" class="headerlink" title="连接器"></a>连接器</h4><ul><li>连接器主要和身份认证和权限相关的功能相关，类似哨兵</li><li>主要负责用户登录数据库，进行用户的身份认证，包括校验账户密码，权限等操作</li></ul><h4 id="查询缓存"><a href="#查询缓存" class="headerlink" title="查询缓存"></a>查询缓存</h4><p>MySQL 查询不建议使用缓存，因为查询缓存经常失效，所以大多数情况下都是不去使用查询缓存的。</p><ul><li>查询缓存主要用来缓存我们所执行的 SELECT 语句以及该语句的结果</li><li>连接建立后，执行查询语句的时候，会先查询缓存，如果缓存 key 被命中，就会直接返回给客户端，如果没有命中，就会执行后续的操作</li><li>查询完成后也会把结果缓存起来，方便下一次调用</li><li>真正执行缓存查询的时候还是会校验用户的权限，判断该用户是否有查询权限</li></ul><h4 id="分析器"><a href="#分析器" class="headerlink" title="分析器"></a>分析器</h4><p>如果 没有命中缓存，那么就会进入分析器，分析器主要是用来分析 SQL 语句是来干什么的，分为两步</p><ul><li><p>词法分析，一条 SQL 语句有多个字符串组成，首先要提取关键字，比如 select，提出查询的表，提出字段名，提出查询条件等等</p></li><li><p>语法分析，主要就是判断你输入的 sql 是否正确，是否符合 MySQL 的语法</p></li></ul><h4 id="优化器"><a href="#优化器" class="headerlink" title="优化器"></a>优化器</h4><ul><li>优化器的作用就是它认为的最优的执行方案去执行</li><li>例如如多个索引的时候该如何选择索引</li><li>经过了优化器之后就可以让执行器去执行sql了</li></ul><h4 id="执行器"><a href="#执行器" class="headerlink" title="执行器"></a>执行器</h4><ul><li>首先执行前会校验该用户有没有权限，如果没有权限，就会返回错误信息</li><li>如果有权限，就会去调用引擎的接口，返回接口执行的结果。</li></ul><h2 id="一条查询语句如何执行"><a href="#一条查询语句如何执行" class="headerlink" title="一条查询语句如何执行"></a>一条查询语句如何执行</h2><pre class="line-numbers language-none"><code class="language-none">select name from student  where  age&#x3D; &#39;18&#39; and sex &#x3D; &#39;女&#39;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>我们分析下这个语句的执行流程：</p><ol><li><p>先检查该语句是否有权限，如果没有权限，直接返回错误信息</p></li><li><p>如果有权限，在 MySQL8.0 版本以前，会先查询缓存，如果命中缓存之，间返回，如果没有，执行下一步。</p></li><li><p>通过分析器进行词法分析，提取 sql 语句的关键元素，比如提取上面这个语句是查询 select，提取需要查询的表名为 student,需要查询名为name的列，查询条件是这个表的 age=’18’和sex=‘女’。</p></li><li><p>判断这个 sql 语句是否有语法错误，比如关键词是否正确等等，如果错误就执行下一步。</p></li><li><p>接下来就是优化器进行确定执行方案，上面的 sql 语句，可以有两种执行方案，优化器会根据自己的优化算法选择执行效率最好的一个方案</p><ul><li>先查询学生表中age为“18”的学生，然后判断是否sex=女。</li><li>先找出学生中sex=女的学生，然后再判断是否age=18 </li></ul></li><li><p>进行权限校验，如果没有权限就会返回错误信息，如果有权限就会调用数据库引擎接口，返回引擎的执行结果给客户端</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>权限校验—&gt;查询缓存—&gt;分析器—&gt;优化器—&gt;权限校验—&gt;执行器—&gt;执行引擎<br><img src="https://img-blog.csdnimg.cn/c72895ce2f4048d9b694583f44767070.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Vwc3RyZWFtNDgw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 查询语句 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL事务和隔离级别</title>
      <link href="/posts/30653.html"/>
      <url>/posts/30653.html</url>
      
        <content type="html"><![CDATA[<h1 id="MySQL事务和隔离级别"><a href="#MySQL事务和隔离级别" class="headerlink" title="MySQL事务和隔离级别"></a>MySQL事务和隔离级别</h1><h2 id="什么是事务"><a href="#什么是事务" class="headerlink" title="什么是事务"></a>什么是事务</h2><p>事务是一组原子性的SQL查询，事务内的SQL语句，要么全部执行成功，要么全部执行失败</p><p>最经典的例子就是转账了，假如小明要给小红转账100元，这个转账会涉及到两个关键操作就是:将小明的余额减少100元，将小红的余额增加100元。如果在这两个操作之间突然出现错误比如银行系统崩溃，导致小明余额减少而小红的余额没有增加，这样就很麻烦了。</p><p>事务就是保证这两个关键操作要么都成功，要么都要失败。</p><h2 id="事务的特性"><a href="#事务的特性" class="headerlink" title="事务的特性"></a>事务的特性</h2><p>事务具备 ACID 特性</p><ul><li>原子性（atomicity）</li><li>一致性（consistency）</li><li>隔离性（isolation）</li><li>持久性（durability）。</li></ul><h4 id="原子性（atomicity）"><a href="#原子性（atomicity）" class="headerlink" title="原子性（atomicity）"></a>原子性（atomicity）</h4><p>一个事务被视为一个完整的最小工作单元，事务中的数据库操作，要么全部执行成功，要么全部执行失败回滚，不会存在只成功执行了其中的一部分数据库操作；</p><h4 id="一致性（consistency）"><a href="#一致性（consistency）" class="headerlink" title="一致性（consistency）"></a>一致性（consistency）</h4><p>数据库总是从一个一致性的状态转换到另一个一致性的状态。在银行转账的例子中，小明的钱减少了100，然后系统出错，因为执行失败时，事务进行了回滚，所做的修改并没有保存到数据库中；</p><h4 id="隔离性（isolation）"><a href="#隔离性（isolation）" class="headerlink" title="隔离性（isolation）"></a>隔离性（isolation）</h4><p>一个事物所做的修改在提交以前，对其他事务是不可见的。在银行转账的例子中，小明的钱减少100时，此时另外一个程序在汇总支票账户，它所查询到小明账户，并没有减去100元人民币；</p><h4 id="持久性（durability）"><a href="#持久性（durability）" class="headerlink" title="持久性（durability）"></a>持久性（durability）</h4><p>事务提交成功，所做的修改就会永久保存到数据库中，即使系统崩溃，修改的数据也不会丢失。</p><ul><li>事务是在存储引擎层实现的，MySQL 是支持多种存储引擎的数据库，</li><li>并不是所有的存储引擎都支持事务，比如 MyISAM 就不支持事务。</li><li>事务增加了数据库的安全性，同时也需要数据库做很多额外的工作，需要更强的 CPU、内存、以及磁盘空间。</li></ul><h2 id="并发事务带来的问题"><a href="#并发事务带来的问题" class="headerlink" title="并发事务带来的问题"></a>并发事务带来的问题</h2><p>在典型的应用程序中，多个事务并发运行，经常会操作相同的数据来完成各自的任务(多个用户对同一数据进行操作)。并发虽然是必须的，但可能会导致以下的问题：</p><h4 id="脏读-Dirty-read"><a href="#脏读-Dirty-read" class="headerlink" title="脏读(Dirty read)"></a>脏读(Dirty read)</h4><p>当一个事务正在访问数据并且对数据进行了修改，而这种修改还没有提交到数据库中，这时另外一个事务也访问了这个数据，然后使用了这个数据。因为这个数据是还没有提交的数据，那么另外一个事务读到的这个数据是“脏数据”，依据“脏数据”所做的操作可能是不正确的。</p><h4 id="丢失修改-Lost-to-modify"><a href="#丢失修改-Lost-to-modify" class="headerlink" title="丢失修改(Lost to modify)"></a>丢失修改(Lost to modify)</h4><p>一个事务读取一个数据时，另外一个事务也访问了该数据，那么在第一个事务中修改了这个数据后，第二个事务也修改了这个数据。这样第一个事务内的修改结果就被丢失，因此称为丢失修改。例如: 事务1读取某表中的数据i=10,事务2也读取i=10，事务1修改i=i-1,事务2也修改i=i-1,最终结果i=9，事务1的修改被丢失。</p><h4 id="不可重复读-Unrepeatableread"><a href="#不可重复读-Unrepeatableread" class="headerlink" title="不可重复读(Unrepeatableread)"></a>不可重复读(Unrepeatableread)</h4><p>指在一个事务内多次读同一数据。在这个事务还没有结束时，另一个事务也访问该数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改导致第一个事务两次读取的数据可能不太一样。这就发生了在一个事务内两次读到的数据是不一样的情况，因此称为不可重复读。</p><h4 id="幻读-Phantom-read"><a href="#幻读-Phantom-read" class="headerlink" title="幻读(Phantom read)"></a>幻读(Phantom read)</h4><p>幻读与不可重复读类似。它发生在一个事务(T1) 读取了几行数据，接着另一个并发事务(T2) 插入了一些数据时。在随后的查询中，第一个事务(T1) 就会发现多了一些些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读。</p><h4 id="不可重复读和幻读区别"><a href="#不可重复读和幻读区别" class="headerlink" title="不可重复读和幻读区别:"></a>不可重复读和幻读区别:</h4><ul><li>不可重复读的重点是修改比如多次读取一条记录发现其中某些列的值被修改</li><li>幻读的重点在于新增或者删除比如多次读取一条记录发现记录增多或减少了。</li></ul><h2 id="事务的隔离级别"><a href="#事务的隔离级别" class="headerlink" title="事务的隔离级别"></a>事务的隔离级别</h2><p>在 SQL 标准中，包含了四种隔离级别，即未提交读（read uncommitted）、提交读（read committed）、可重复读（repeatable read）、可串行化（serializable）。</p><h4 id="未提交读（read-uncommitted）"><a href="#未提交读（read-uncommitted）" class="headerlink" title="未提交读（read uncommitted）"></a>未提交读（read uncommitted）</h4><p>一个事务还未提交，它所做的变更能被别的事务看到。事务可以读取未提交的数据，被称为脏读（dirty read），这种隔离级别在实际应用中一般很少使用；</p><h4 id="提交读（read-committed）"><a href="#提交读（read-committed）" class="headerlink" title="提交读（read committed）"></a>提交读（read committed）</h4><p>一个事务提交之后，它所做的变更才能被别的事务看到。大多数数据库的默认隔离级别是提交读（read committed），比如 Oracle；</p><h4 id="可重复读（repeatable-read）"><a href="#可重复读（repeatable-read）" class="headerlink" title="可重复读（repeatable read）"></a>可重复读（repeatable read）</h4><p>一个事务在执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的。在可重复读隔离级别下，未提交变更对其他事务也是不可见的。该级别保证了在同一个事务中，多次读取同样记录的结果是一致的。MySQL 的默认事务隔离级别是可重复读（repeatable read）；</p><h4 id="可串行化（serializable）"><a href="#可串行化（serializable）" class="headerlink" title="可串行化（serializable）"></a>可串行化（serializable）</h4><p>serializable 是最高的隔离级别。对同一行数据，读写都会进行加锁。当出现锁冲突时，后面访问的事务必须等前一个事务完成，才能继续执行。实际应用场景很少用到这种隔离级别，只有在非常需要确保数据一致性，而且可以接受没有并发的情况，才会使用这种隔离级别。</p><p><img src="https://img-blog.csdnimg.cn/e2cbeb193f9240709bdd30ca8a7c37ea.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Vwc3RyZWFtNDgw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 事务 </tag>
            
            <tag> 隔离级别 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis缓存过期与内存淘汰</title>
      <link href="/posts/26947.html"/>
      <url>/posts/26947.html</url>
      
        <content type="html"><![CDATA[<h1 id="Redis缓存过期与内存淘汰"><a href="#Redis缓存过期与内存淘汰" class="headerlink" title="Redis缓存过期与内存淘汰"></a>Redis缓存过期与内存淘汰</h1><ul><li>Redis中有个设置时间过期的功能，即对存储在redis 数据库中的值可以设置一个过期时间，到了过期时间，key会被删除</li><li>如果内存空间满了，再往Redis里面插入数据，就会触发缓存淘汰机制 <h2 id="缓存过期策略"><a href="#缓存过期策略" class="headerlink" title="缓存过期策略"></a>缓存过期策略</h2>作为一个缓存数据库，这是非常实用的。我们set key的时候，都可以给一个expire_time, 就是过期时间，通过过期时间我们可以指定这个key可以存活的时间。</li></ul><p>那么，到了过期时间后，这些key是怎么被删除的呢？</p><ul><li>缓存过期是在 Key 超过 expire_time 后，从内存中删除，减少内存空间的占用</li><li>不同策略的定义、优点和缺点都是不同的。Redis 的过期策略主要有三种实现方式：</li></ul><h3 id="定时删除："><a href="#定时删除：" class="headerlink" title="定时删除："></a>定时删除：</h3><p>对于每一个有过期时间的 Key，创建一个定时器，到过期时间后立即删除；</p><ul><li>优点：保存内存可以尽快释放，减少过期 Key 对内存空间的占用；</li><li>缺点：占用大量的 CPU 资源去处理定时器，影响缓存的吞吐量，这和 Redis 设计追求性能的设定不符，所以一般不会采用这种策略。<h3 id="惰性删除："><a href="#惰性删除：" class="headerlink" title="惰性删除："></a>惰性删除：</h3>过期的 Key 不做处理，只有当访问这个 Key 时才会判断是否过期，过期则删除；</li><li>优点：删除操作只有在访存的时候才可能执行，对 CPU 的占用做到了最小。</li><li>缺点：如果内存中大量的 Key 均过期，且一段时间内没有被访问，会占用大量内存。<h3 id="定期删除："><a href="#定期删除：" class="headerlink" title="定期删除："></a>定期删除：</h3>每隔一段时间(默认100ms)全量扫描设置了过期时间的 Key，如果失效则从内存中删除，否则不做处理；</li><li>优点：通过限制定时的频率，来减少对 CPU 的占用和对内存的占用；</li><li>缺点：作为一种折中的方案，在内存友好方面，不如定时删除策略；在 CPU 友好方面，不如惰性删除。使用时的表现非常依赖配置的定期频率。<h2 id="内存淘汰机制"><a href="#内存淘汰机制" class="headerlink" title="内存淘汰机制"></a>内存淘汰机制</h2>但是仅仅通过设置过期时间还是有问题的。如果定期删除漏掉了很多过期key,然后你也<br>没及时去查，也就没走惰性删除，此时会有大量过期key堆积在内存里，导致redis内存耗<br>尽了<br>redis内存淘汰机制就横空出世了，缓存过期策略和内存淘汰机制是非常容易混淆的两个概念，两者的目的是不同的。</li><li>缓存过期策略：针对过期 Key ，从内存中移除的方式。</li><li>内存淘汰机制：针对 Redis 内存不足时，业务还在继续往 Redis 追加内容，如何处理已有的内容。</li></ul><h3 id="八种淘汰策略"><a href="#八种淘汰策略" class="headerlink" title="八种淘汰策略"></a>八种淘汰策略</h3><ul><li>volatile-lru：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，移除最近最少使用的 key；</li><li>allkeys-lru：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的 key；</li><li>volatile-lfu：当内存不足以容纳新写入数据时，在过期密集的键中，使用 LFU 算法进行删除 key；</li><li>allkeys-lfu：当内存不足以容纳新写入数据时，对所有的 key 执行 LFU 算法筛选过期；</li><li>volatile-random：当内存不足以容纳新写入数据时，在设置了过期的键中，随机删除一个 key；</li><li>allkeys-random：当内存不足以容纳新写入数据时，随机删除一个或者多个 key；</li><li>volatile-ttl：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，有更早过期时间的 key 优先移除；</li><li>noeviction：当内存不足以容纳新写入数据时，新写入操作直接报错，无法写入。</li></ul><p>上述算法按照特性可以分为几类：LRU/LFU 算法、随机删除算法、优先淘汰历史数据算法、报错处理算法。目前主流是使用 LRU 算法</p><ul><li>Redis 用作持久化数据库，不配置缓存过期时间，采用 allkeys-lru ；</li><li>Redis 作为缓存数据库，配置了 Key 过期时间，采用 volatile-lru 算法。</li></ul><h2 id="LRU算法"><a href="#LRU算法" class="headerlink" title="LRU算法"></a>LRU算法</h2><p>LRU（Least Recently Used，最近最少使用算法）是最常见的缓存淘汰算法，核心思想是 “如果数据最近被访问过，那么将来被访问的可能性也更高”。</p><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><ul><li>新数据直接插入到链表头部；</li><li>每当缓存命中（即缓存数据被访问），则将被命中的数据移到链表头部；</li><li>当链表满的时候，将链表尾部的数据丢弃。<br><img src="https://img-blog.csdnimg.cn/113099241a5047b495e01ae2d1472d8e.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Vwc3RyZWFtNDgw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li></ul><p>总结，越靠近链表头部的数据越是不容易被淘汰，越靠近链表尾部的数据越是容易淘汰。</p>]]></content>
      
      
      <categories>
          
          <category> 缓存 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 缓存过期 </tag>
            
            <tag> 内存淘汰 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis的持久化方式</title>
      <link href="/posts/2050.html"/>
      <url>/posts/2050.html</url>
      
        <content type="html"><![CDATA[<h1 id="Redis的持久化方式"><a href="#Redis的持久化方式" class="headerlink" title="Redis的持久化方式"></a>Redis的持久化方式</h1><p>Redis 缓存的优势是提供快速的查询和存储能力，所以所有的数据都被存储在内存中。相对于硬盘，内存中的数据是半持久化存储，当遇到不可抗阻力，例如断电或者硬件损坏导致的服务器宕机时，内存中的数据会完全丢失。为了防止 Redis 中的数据丢失，需要将数据持久化存储到硬盘。</p><h4 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h4><p>持久化就是把 Redis 数据从内存同步到硬盘的过程。Redis中提供了两种持久化方案</p><ul><li>RDB 持久化：将 Redis 的数据定时 dump 到硬盘；</li><li>AOF 持久化：将 Redis 的操作日志追加写入硬盘文件。</li></ul><h2 id="RDB方式"><a href="#RDB方式" class="headerlink" title="RDB方式"></a>RDB方式</h2><p>RDB方式也叫快照持久化</p><ul><li>Redis可以通过创建快照来获得存储在内存里面的数据在某个时间点上的副本。</li><li>Redis创建快照之后，可以对快照进行备份，可以将快照复制到其他服务器从而创建具有相同数据的服务器副本(Redis主从结构，主要用来提高Redis性能)</li><li>还可以将快 照留在原地以便重启服务器的时候使用。</li></ul><p>快照持久化是Redis默认采用的持久化方式，在redis.conf配置文件中默认有此下配置</p><pre class="line-numbers language-none"><code class="language-none">save 900 1    # 在900秒(15分钟)之后，如果至少有1个key发生变化，Redis就会自动触发BGSAVE命令创建快照。save 300 10# 在300秒(5分钟)之后，如果至少有10个key发生变化，Redis就会自动触发BGSAVE命令创建快照。save 60 10000# 在60秒(1分钟)之后，如果至少有10000个key发生变化，Redis就会自动触发BGSAVE命令创建快照。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="RDB过程"><a href="#RDB过程" class="headerlink" title="RDB过程"></a>RDB过程</h4><p>RDB 持久化方式的步骤是：</p><ul><li>定时从 Redis 主进程 fork 一个 Redis 子进程；</li><li>Redis 子进程生成内存的数据快照，并且写入 RDB 临时文件；</li><li>临时文件写入成功后，生成 RDB 最终文件。<br><img src="https://img-blog.csdnimg.cn/ad270ae5e9504d578e59ad3990fea4ef.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Vwc3RyZWFtNDgw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><h4 id="触发机制"><a href="#触发机制" class="headerlink" title="触发机制"></a>触发机制</h4>RDB 同步有三种触发机制：save 指令、bgsave 指令、自动化指令</li><li>save 指令：命令会阻塞当前 Redis 服务器，导致 Redis 暂时不可用；</li><li>bgsave 指令：命令在后台异步执行操作，Redis 服务器同时也能响应客户端请求，阻塞只发生在 fork 时间段，时间很短。</li><li>自动化指令：在 redis.conf 文件配置，例如数据在经过 m 次修改后自动触发 bgsave 命令(上面说的哪种)</li></ul><p>简单来说，因为 save 指令会在整个过程中阻塞服务器，所以线上生产环境都是使用 bgsave 指令。</p><h2 id="AOF方式"><a href="#AOF方式" class="headerlink" title="AOF方式"></a>AOF方式</h2><p>AOF 持久化方式以日志形式记录 Redis 服务器的每一个插入、修改、删除操作，以文本的形式异步保存。</p><ul><li>AOF 持久化与快照持久化相比，AOF持久化的实时性更好，因此已成为主流的持久化方案。</li><li>默认情况下Redis没有开启AOF (append only file)方式的持久化</li><li>可以通过配置文件的appendonly参数开启:appendonly yes</li></ul><h4 id="AOF过程"><a href="#AOF过程" class="headerlink" title="AOF过程"></a>AOF过程</h4><p>开启AOF持久化后每执行条会更改Redi s中的数据的命令 ，Redis就会将该命令写入硬盘中的AOF 文件。<br>AOF文件的保存位置和RDB文件的位置相同，都是通过dir参数设置的，默认的文件名是appendonly.aof。<br><img src="https://img-blog.csdnimg.cn/6d34b532eb754841b4253afb583812ee.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Vwc3RyZWFtNDgw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>在Redis的配置文件中存在三种不同的AOF持久化方式，它们分别是:</p><pre class="line-numbers language-none"><code class="language-none">appendfsync always     # 每次有数据修改发生时都会写入AOF文件,这样会严重降低Redis的速度appendfsync everysec   # 每秒钟同步一次，显示地将多个写命令同步到硬盘appendfsync no         # 让操作系统决定何时进行同步<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li>为了兼顾数据和写入性能，一般采用appendfsync everysec选项 ；</li><li>让Redis每秒同步一 次AOF文件，Redis性能几乎没受到任何影响；</li><li>而且这样即使出现系统崩溃，用户最多只会丢失一秒之内产生的数据；</li><li>当硬盘忙于执行写入操作的时候，Redis还会优雅的放慢自己的速度以便适应硬盘的最大写入速度。</li></ul><h2 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h2><h4 id="RDB-的优点："><a href="#RDB-的优点：" class="headerlink" title="RDB 的优点："></a>RDB 的优点：</h4><ul><li>性能较高：在开始持久化时，只需要 fork 出一个子进程，子进程负责持久化的工作，避免主线程的 IO 操作；</li><li>启动效率高：相对于 AOF 方式，如果数据集非常大， 启动速度更快。</li></ul><h4 id="RDB-的缺点："><a href="#RDB-的缺点：" class="headerlink" title="RDB 的缺点："></a>RDB 的缺点：</h4><ul><li>如果服务器在定时持久化之前宕机，那么 Redis 中没来得及写入的数据都会丢失。</li></ul><h4 id="AOF-的优点："><a href="#AOF-的优点：" class="headerlink" title="AOF 的优点："></a>AOF 的优点：</h4><ul><li>数据安全：每次修改都会同时追加到日志文件，就算服务器宕机，数据也能在日志文件中找回；</li><li>方便重建：日志文件同 MySQL 的 binlog 功能相同，我们所有的写操作都能从日志文件中获取。</li></ul><h4 id="AOF-的缺点："><a href="#AOF-的缺点：" class="headerlink" title="AOF 的缺点："></a>AOF 的缺点：</h4><ul><li>运行效率低：AOF 方式本质上是牺牲缓存的性能，来换去缓存的一致性；</li><li>占用文件更大：AOF 的日志文件相对 RDB 同步的文件，通常要更大，所以在恢复时速度更慢。</li></ul><h2 id="混合持久化"><a href="#混合持久化" class="headerlink" title="混合持久化"></a>混合持久化</h2><ul><li>Redis 4.0开始支持RDB和AOF的混合持久化</li><li>默认关闭，可以通过配置项aof-use-rdb-preamble开启</li></ul><p>在混合持久化下，AOF重写的时候就直接把RDB 的内容写到AOF文件开头。这样做的好处是可<br>以结合RDB和AOF的优点，快速加载同时避免丢失过多的数据。当然缺点也是有的，AOF 里面的<br>RDB部分是压缩格式不再是AOF格式，可读性较差。</p><h4 id="AOF重写"><a href="#AOF重写" class="headerlink" title="AOF重写"></a>AOF重写</h4><ul><li>AOF重写可以产生一个新的AOF文件，这个新的AOF文件和原有的AOF文件所保存的数据库状态一样，但体积更小。</li><li>AOF重写是通过读取数据库中的键值对来实现的，程序无须对现有AOF文件进行任何读入、分析或者写入操作。</li><li>在执行BGREWRITEAOF 命令时，Redis 服务器会维护一个AOF 重写缓冲区，该缓冲区会在子进程创建<br>新AOF文件期间，记录服务器执行的所有写命令。</li><li>当子进程完成创建新AOF文件的工作之后，服务器会将重写缓冲区中的所有内容追加到新AOF文件的末尾，使得新旧两个AOF文件所保存的数据库状态一致。</li><li>最后，服务器用新的A0F文件替换旧的AOF文件，以此来完成AOF文件重写操作</li></ul>]]></content>
      
      
      <categories>
          
          <category> 缓存 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
            <tag> 持久化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM垃圾收集器</title>
      <link href="/posts/51819.html"/>
      <url>/posts/51819.html</url>
      
        <content type="html"><![CDATA[<p>垃圾收集算法是内存回收的方法论，那么垃圾收集器就是内存回收的具体实现。</p><h2 id="垃圾收集器分类"><a href="#垃圾收集器分类" class="headerlink" title="垃圾收集器分类"></a>垃圾收集器分类</h2><p>目前，有很多的垃圾收集器，各类垃圾收集器各有优缺点，但目前为止还没有最好的<br>垃圾收集器出现，更加没有万能的垃圾收集器，我们能做的就是根据具体应用场景选择适合自己的垃圾<br>收集器<br>下图是7 种垃圾回收器<br><img src="https://img-blog.csdnimg.cn/89edeadfaf1842daaea33649a198963b.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Vwc3RyZWFtNDgw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="Serial收集器"><a href="#Serial收集器" class="headerlink" title="Serial收集器"></a>Serial收集器</h2><p>Serial收集器是最基本、发展历史最久的收集器，这个收集器是采用标记-复制算法的单线程的收集器。</p><ul><li>单线程一方面意味着他只会使用一个 CPU 或者一条线程去完成垃圾收集工作，</li><li>另一方面也意味着他进行垃圾收集时必须暂停其他线程的所有工作，直到它收集结束为止。</li></ul><p><img src="https://img-blog.csdnimg.cn/34c23b3debb74c669df6ed6844bd16c9.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Vwc3RyZWFtNDgw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="Parnew收集器"><a href="#Parnew收集器" class="headerlink" title="Parnew收集器"></a>Parnew收集器</h2><p>Parnew 收集器其实就是Serial收集器的多线程版本，除了使用多线程进行垃圾收集外，其余行为和 Serial 收集器完全一样，但是他却是 Server 模式下的虚拟机首选的新生代收集器。</p><ul><li>除了 Serial 收集器外，目前只有它能与 CMS 收集器配合工作。CMS 收集器第一次实现了让垃圾收集器与用户线程基本上同时工作；CMS收集器我们后面会说</li><li>Parnew 收集器默认开启的收集线程数与 CPU 数量相同，在 CPU 数量非常多的情况下，可以使用 -XX:ParallelGCThreads 参数来限制垃圾收集的线程数。<br><img src="https://img-blog.csdnimg.cn/60910e6d076d4f4f92ff4136c90614e3.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Vwc3RyZWFtNDgw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><h2 id="Parallel-Scavenge收集器"><a href="#Parallel-Scavenge收集器" class="headerlink" title="Parallel Scavenge收集器"></a>Parallel Scavenge收集器</h2>Parallel Scavenge 收集器也是一个新生代收集器，也采用了标志-复制算法，也是并行的多线程收集器。Parallel Scavenge 收集器的目标是达到一个可控制的吞吐量。Parallel Scavenge 收集器是虚拟机运行在 Server 模式下的默认垃圾收集器。被称为“吞吐量优先收集器”。</li><li>采用标记-复制算法</li><li>多线程收集</li><li>控制吞吐量的目标。</li></ul><p>Parallel Scavenge 收集器运行过程同 Parnew 收集器基本一致<br><img src="https://img-blog.csdnimg.cn/60910e6d076d4f4f92ff4136c90614e3.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Vwc3RyZWFtNDgw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ul><li><p>控制吞吐量：CMS 等收集器的关注点是尽可能缩短垃圾收集时用户线程的停顿时间，而 Parallel Scavenge 收集器的目标则是达到一个可控制的吞吐量。</p></li><li><p>吞吐量就是 CPU 用于运行用户代码时间与 CPU 总消耗时间的比值，即吞吐量=运行用户代码时间/（运行用户代码时间+垃圾收集时间）。</p></li><li><p>空间吞吐量参数介绍：虚拟机提供了-XX：MaxGCPauseMills 和 -XX：GCTimeRatio 两个参数来精确控制最大垃圾收集停顿时间和吞吐量大小。</p></li><li><p>GC 停顿时间的缩短是以牺牲吞吐量和新生代空间换取的。由于与吞吐量关系密切，Parallel Scavenge 收集器也被称为“吞吐量优先收集器”。</p></li></ul><h2 id="Serial-Old收集器"><a href="#Serial-Old收集器" class="headerlink" title="Serial Old收集器"></a>Serial Old收集器</h2><p> Serial Old 收集器与Serial收集器是一个单线程收集器，作用于老年代，使用“标记-整理算法”，这个收集器的主要意义也是在于给 Client 模式下的虚拟机使用。<br> 运行过程与Serial基本一致<br> <img src="https://img-blog.csdnimg.cn/34c23b3debb74c669df6ed6844bd16c9.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Vwc3RyZWFtNDgw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="Parallel-Old收集器"><a href="#Parallel-Old收集器" class="headerlink" title="Parallel Old收集器"></a>Parallel Old收集器</h2><p>Parallel Old 收集器是 Parallel Scavenge 收集器的老年代版本，使用多线程和“标记-整理算法”进行垃圾回收。<br>在注重吞吐量以及CPU资源的场合，都可以优先考虑Parallel Scavenge收集器和Parallel old收集器。<br><img src="https://img-blog.csdnimg.cn/d801f35d82964bfd98b10b2d378dca38.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Vwc3RyZWFtNDgw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="CMS收集器"><a href="#CMS收集器" class="headerlink" title="CMS收集器"></a>CMS收集器</h2><p>CMS（Conrrurent Mark Sweep，连续标记扫描）收集器是以获取最短回收停顿时间为目标的收集器。使用标记-清除算法。CMS收集器是HotSpot虚拟机第一款真正意义上的并发收集器，它第一次实现了让垃圾收集线程与用户线程(基本上)同时工作。</p><h4 id="收集过程"><a href="#收集过程" class="headerlink" title="收集过程"></a>收集过程</h4><ul><li>初始标记：暂停所有的其他线程，标记 GC Roots 能直接关联到的对象，时间很短；</li><li>并发标记：同时开启GC和用户线程，进行 GC Roots Tracing（可达性分析）过程，时间很长；</li><li>重新标记：修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，时间比初始标记长；但远远小于并发标记的时间</li><li>并发清除：开启用户线程，回收内存空间，时间很长。其中，并发标记与并发清除两个阶段耗时最长，但是可以与用户线程并发执行。<h4 id="运行过程"><a href="#运行过程" class="headerlink" title="运行过程"></a>运行过程</h4><img src="https://img-blog.csdnimg.cn/fcce9b8b4741450b9a2c54e765ae5a48.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Vwc3RyZWFtNDgw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4></li><li>并发收集</li><li>低停顿<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4></li><li>对CPU资源敏感;</li><li>无法处理浮动垃圾;</li><li>它使用的回收算法“标记-清除”算法会导致收集结束时会有大量空间碎片产生。</li></ul><h2 id="G1收集器"><a href="#G1收集器" class="headerlink" title="G1收集器"></a>G1收集器</h2><p>G1 是目前技术发展的比较最前沿成果之一，HotSpot开发团队赋予它的使命是未来可以替换掉 JDK1.5 中发布的 CMS 收集器。</p><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ul><li>并发和并行：使用多个 CPU 来缩短 Stop The World 停顿时间，与用户线程并发执行；</li><li>分代收集：独立管理整个堆，但是能够采用不同的方式去处理新创建对象和已经存活了一段时间、熬过多次 GC 的旧对象，以获取更好的收集效果；</li><li>空间整合：基于标记-整理算法，无内存碎片产生；</li><li>可预测的停顿：能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为 M 毫秒的时间片段内，消耗在垃圾收集器上的时间不得超过N毫秒。<h4 id="回收步骤"><a href="#回收步骤" class="headerlink" title="回收步骤"></a>回收步骤</h4></li><li>初始标记:标记GC Roots能直接关联到的对象，让下一阶段用户线程并发运行时能正确地在可用<br>Region中分配新对象。需要STW但耗时很短，在Minor GC时同步完成。</li><li>并发标记:从GC Roots开始对堆中对象进行可达性分析，递归扫描整个堆的对象图。耗时长但可<br>与用户线程并发，扫描完成后要重新处理SATB记录的在并发时有变动的对象。</li><li>最终标记:对用户线程做短暂暂停，处理并发阶段结束后仍遗留下来的少量SATB记录。</li><li>筛选回收:对各Region的回收价值排序，根据用户期望停顿时间制定回收计划。必须暂停用户线<br>程，由多条收集线程并行完成。</li></ul><p>G1收集器在后台维护了一个个优先列表，每次根据允许的收集时间，优先选择回收价值最大的Region(这<br>也就是它的名字Garbage-First的由来)。这种使用Region划分内存空间以及有优先级的区域回收方式，<br>保证了收集器在有限时间内可以尽可能高的收集效率(把内存化整为零)</p><p>在G1之前的垃圾收集器，收集的范围都是整个新生代或者老年代，而 G1 不再是这样。使用 G1 收集器时，Java 堆的内存布局与其他收集器有很大差别，它将整个Java堆划分为多个大小相等的独立区域（Region），虽然还保留有新生代和老年代的概念，但新生代和老年代不再是物理隔离的了，它们都是一部分（可以不连续）Region 的集合。</p>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 垃圾收集器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何判断对象是垃圾</title>
      <link href="/posts/47877.html"/>
      <url>/posts/47877.html</url>
      
        <content type="html"><![CDATA[<h1 id="如何判断对象是否是垃圾"><a href="#如何判断对象是否是垃圾" class="headerlink" title="如何判断对象是否是垃圾"></a>如何判断对象是否是垃圾</h1><p>堆中几乎放着所有的对象实例，对堆垃圾回收前的第步就是要判断哪些对象已经死亡(即不能再被任<br>何途径使用的对象)，方便垃圾回收器对这些死亡的对象进行回收。<br>在说如果判断对象是否为垃圾前，我们需要了解一些其他概念</p><h4 id="垃圾回收器"><a href="#垃圾回收器" class="headerlink" title="垃圾回收器"></a>垃圾回收器</h4><p>JVM 为 Java 提供了垃圾回收机制，其实是一种偏自动的内存管理机制。简单来说，垃圾回收器会自动追踪所有正在使用的对象，并将其余未被使用的对象标记为垃圾，不需要开发者手动进行垃圾回收，JVM 自动进行垃圾回收，释放内容。</p><h4 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h4><p>如果不进行垃圾回收，内存迟早都会被消耗空，因为我们在不断的分配内存空间而不进行回收。除非内存无限大，我们可以任性的分配不回收，但是事实并非如此。所以，垃圾回收是必须的。</p><h4 id="哪些内存需要回收"><a href="#哪些内存需要回收" class="headerlink" title="哪些内存需要回收"></a>哪些内存需要回收</h4><p>所谓“要回收的垃圾”无非就是那些不可能再被任何途径所使用的对象。无需再使用的对象，会被标记为垃圾，等待JVM回收此部分内存。</p><h2 id="计数器法"><a href="#计数器法" class="headerlink" title="计数器法"></a>计数器法</h2><ul><li>在对象中添加一个引用计数器，如果被引用计数器加1，引用失效时计数器减1；</li><li>如果计数器为0则被标记为垃圾。</li><li>原理简单，效率高，但是在Java中很少使用，因为存在对象间循环引用的问题，导致计数器无法清零。<h2 id="可达性分析"><a href="#可达性分析" class="headerlink" title="可达性分析"></a>可达性分析</h2></li><li>大多数语言的内存管理都使用可达性分析判断对象是否存活。</li><li>基本思路是通过一系列称为GC Roots的根对象作为起始节点集，</li><li>从这些节点开始，根据引用关系向下搜索，搜索过程走过的路径称为引用链，</li><li>如果某个对象到GC Roots没有任何引用链相连，则会被标记为垃圾。</li></ul><p>在 Java 语言中，可以作为 GCRoots 的对象包括下面几种：</p><ul><li>虚拟机栈（栈帧中的局部变量区，也叫局部变量表）中引用的对象；</li><li>方法区中的类静态变量属性引用的对象；</li><li>方法区中常量引用的对象；</li><li>本地方法栈中 JNI（Native方法）引用的对象。</li></ul><p>图片中红色箭头指向的都是没有GC Root引用链的，均被判定为垃圾<br><img src="https://img-blog.csdnimg.cn/2ce6dccd389447baaea0d73705e42045.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Vwc3RyZWFtNDgw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="GC-Root"><a href="#GC-Root" class="headerlink" title="GC Root"></a>GC Root</h3><h4 id="虚拟机栈中的引用的对象"><a href="#虚拟机栈中的引用的对象" class="headerlink" title="虚拟机栈中的引用的对象"></a>虚拟机栈中的引用的对象</h4><p>在程序中创建一个对象，对象会在堆上开辟一块空间，同时会将这块空间的地址作为引用保存到虚拟机栈中，如果对象生命周期结束了，那么引用就会从虚拟机栈中出栈，因此如果在虚拟机栈中有引用，就说明这个对象还是有用的，这种情况是最常见的；</p><h4 id="全局的静态的对象"><a href="#全局的静态的对象" class="headerlink" title="全局的静态的对象"></a>全局的静态的对象</h4><p>也就是使用了 static 关键字，由于虚拟机栈是线程私有的，所以这种对象的引用会保存在共有的方法区中，显然将方法区中的静态引用作为 GC Roots 是必须的；</p><h4 id="常量引用"><a href="#常量引用" class="headerlink" title="常量引用"></a>常量引用</h4><p>就是使用了 static final 关键字，由于这种引用初始化之后不会修改，所以方法区常量池里的引用的对象也应该作为 GC Roots；</p><h4 id="Native-方法引用对象"><a href="#Native-方法引用对象" class="headerlink" title="Native 方法引用对象"></a>Native 方法引用对象</h4><p>这一种是在使用 JNI 技术时，有时候单纯的 Java 代码并不能满足我们的需求，我们可能需要在 Java 中调用 C 或 C++ 的代码，因此会使用 native 方法，JVM 内存中专门有一块本地方法栈，用来保存这些对象的引用，所以本地方法栈中引用的对象也会被作为 GC Roots。</p>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 垃圾回收 </tag>
            
            <tag> GC Root </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM运行时数据区(二)</title>
      <link href="/posts/40122.html"/>
      <url>/posts/40122.html</url>
      
        <content type="html"><![CDATA[<h1 id="JVM运行时数据区-二"><a href="#JVM运行时数据区-二" class="headerlink" title="JVM运行时数据区(二)"></a>JVM运行时数据区(二)</h1><p> <a href="https://blog.csdn.net/upstream480/article/details/119703305">上篇文章</a>写了JVM运行时数据区中的程序计数器，Java虚拟机栈和本地方法栈。这篇文章我们接着班Java运行时数据区中的堆和方法区说一下<br> <img src="https://img-blog.csdnimg.cn/f3594045c19443f6ade8f38be3b57652.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Vwc3RyZWFtNDgw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="方法区-Method-Area"><a href="#方法区-Method-Area" class="headerlink" title="方法区(Method Area)"></a>方法区(Method Area)</h2><p>方法区，也称非堆（Non-Heap），是一个被线程共享的内存区域。其中主要存储加载的类字节码、class/method/field 等元数据对象、static-final 常量、static 变量、JIT 编译器编译后的代码等数据。</p><h3 id="方法区也叫永久代"><a href="#方法区也叫永久代" class="headerlink" title="方法区也叫永久代"></a>方法区也叫永久代</h3><ul><li>方法区和永久代的关系很像Java中接口和类的关系，类实现了接口，</li><li>而永久代就是HotSpot虚拟机对虚拟机规范中方法区的一种实现方式。</li><li>永久代是HotSpot的概念，方法区是Java虚拟机规范中的定义，是一种规范， </li><li>永久代是一种实现，一个是标准一个是实现，其他的虚拟机实现没有永久。</li></ul><h3 id="方法区存放的数据"><a href="#方法区存放的数据" class="headerlink" title="方法区存放的数据"></a>方法区存放的数据</h3><ul><li>类型全限定名：全限定名为 package 路径与类名称组合起来的路径；</li><li>类型的直接超类的全限定名：父类或超类的全限定名；</li><li>类的类型：判定当前类是 Class 还是接口 Interface；</li><li>类型的访问修饰符：判断修饰符，如 pulic，private 等；</li><li>类型的常量池：常量池</li><li>字段信息：类中字段的信息；</li><li>方法信息：类中方法的信息；</li><li>静态变量：类中的静态变量信息；</li><li>一个到类 ClassLoader 的引用：对 ClassLoader 的引用，这个引用指向对内存；</li><li>一个到 Class 类的引用：对对象实例的引用，这个引用指向对内存。</li></ul><p>另外，方法区包含了一个特殊的区域 “运行时常量池”。</p><h3 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h3><ul><li>运行时常量池是方法区的一部分。</li><li>Class 文件中有类的版本、字段、方法、接口等描述信息，还</li><li>有常量池信息(用于存放编译期生成的各种字面量和符号引用)；</li><li>当常量池无法再申请到内存时会抛出OutOfMemoryError 异常。</li></ul><p>常量池主要用于存放两大类常量：字面量（Literal）和符号引用量（Symbolic References）<br><img src="https://img-blog.csdnimg.cn/bc4eb4934f784c65bcf5459eeba04c87.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Vwc3RyZWFtNDgw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="常量池好处"><a href="#常量池好处" class="headerlink" title="常量池好处"></a>常量池好处</h3><p>常量池是为了避免频繁的创建和销毁对象而影响系统性能，其实现了对象的共享。</p><ul><li>节省内存空间：常量池中所有相同的字符串常量被合并，只占用一个空间。</li><li>节省运行时间：比较字符串时，== 比 equals () 快。对于两个引用变量，只用 == 判断引用是否相等，就可以判断实际值是否相等。</li></ul><h3 id="变化"><a href="#变化" class="headerlink" title="变化"></a>变化</h3><p>Java8后，JVM移除了方法区并使用 metaspace（元数据空间）作为替代实现。metaspace 占用系统内存，只要不碰触到系统内存上限，方法区会有足够的内存空间。</p><h2 id="堆区-Heap"><a href="#堆区-Heap" class="headerlink" title="堆区(Heap)"></a>堆区(Heap)</h2><p>堆内存是运行时数据区中非常重要的结构，实例对象会存放于堆内存中。绝大多数的垃圾回收都发生在堆内存中，因此对于 JVM 来说，堆内存占据着十分重要的且不可替代的位置。<br><img src="https://img-blog.csdnimg.cn/b1b6e103091a43cf8f71e50ca8d813b9.png" alt="在这里插入图片描述"></p><h3 id="内存划分"><a href="#内存划分" class="headerlink" title="内存划分"></a>内存划分</h3><ul><li><p>堆内存从结构上来说分为年轻代（YoungGen）和老年代（OldGen）两部分；</p></li><li><p>年轻代（YoungGen）又可以分为生成区（Eden）和幸存者区（Survivor）两部分；</p></li><li><p>幸存者区（Survivor）又可细分为 S0区（from space）和 S1区 (to space)两部分。</p></li><li><p>年轻代中容量划分默认比例是 8:1:1；</p><h3 id="为什么要分代"><a href="#为什么要分代" class="headerlink" title="为什么要分代"></a>为什么要分代</h3><p>将堆内存从概念层面进行模块划分，总体分为两大部分，年轻代和老年代。从物理层面将堆内存进行内存容量划分，一部分分给年轻代，一部分分给老年代。这就是我们所说的分代。</p><h3 id="分代的意义："><a href="#分代的意义：" class="headerlink" title="分代的意义："></a>分代的意义：</h3><p>分代主要是为了易于堆内存分类管理，易于垃圾回收。</p></li><li><p>易于管理：对于堆空间的分代也是如此，比如新创建的对象会进入年轻代（YoungGen）的生成区（Eden），生命周期未结束的且可达的对象，在经历多次垃圾回收之后，会存放入老年代（OldGen），这就是分类管理；</p></li><li><p>易于垃圾回收：将对象根据存活概率进行分类，对存活时间长的对象，放到固定区，从而减少扫描垃圾时间及 GC 频率。针对分类进行不同的垃圾回收算法，对算法扬长避短。</p><h3 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h3><p><img src="https://img-blog.csdnimg.cn/cf38fb89883543f0bca582403125828c.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Vwc3RyZWFtNDgw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p></li><li><p>新生成的对象首先放到年轻代 Eden 区，当 Eden 空间满了，触发 Minor GC，存活下来的对象移动到Survivor0 区，Survivor0 区满后触发执行 Minor GC，Survivor0 区存活对象移动到 Suvivor1 区，这样保证了一段时间内总有一个 survivor 区为空。经过多次 Minor GC 仍然存活的对象移动到老年代；</p></li><li><p>在一次新生代垃圾回收后，如果对象还存活，则会进入S0或者S1,并且对象的<br>年龄还会加1，当它的年龄增加到一定程度(默认为15岁)，就会被晋升到老年代中。</p></li><li><p>老年代存储长期存活的对象，GC 期间会停止所有线程等待 GC 完成，所以对响应要求高的应用尽量减少发生 Major GC，避免响应超时。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 内存区域 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM运行时数据区(一)</title>
      <link href="/posts/23582.html"/>
      <url>/posts/23582.html</url>
      
        <content type="html"><![CDATA[<h1 id="JVM运行时数据区"><a href="#JVM运行时数据区" class="headerlink" title="JVM运行时数据区"></a>JVM运行时数据区</h1><p>Java运行时数据区可以细分为五个模块：栈，堆，寄存器，方法区和本地方法栈<br><img src="https://img-blog.csdnimg.cn/3d562e1c5a984eada6a1a10ed2057605.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Vwc3RyZWFtNDgw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>在Java8之后，方法区改成了元空间，有一些区域是线程私有的，有一些是线程共享的</p><h4 id="线程私有"><a href="#线程私有" class="headerlink" title="线程私有"></a>线程私有</h4><ul><li>程序计数器</li><li>Java 虚拟机栈</li><li>本地方法栈<h4 id="线程共享"><a href="#线程共享" class="headerlink" title="线程共享"></a>线程共享</h4></li><li>Java 堆</li><li>方法区</li></ul><h2 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h2><p>程序计数器也叫寄存器，每个线程启动的时候，都会创建一个 PC（Program Counter，程序计数器）寄存器。PC 寄存器里保存有当前正在执行的 JVM 指令的地址。</p><ul><li>程序计数器是一块比较小的内存空间，是当前线程所执行的字节码的行号指示器；</li><li>字节码解释器工作时通过改变这个计数器的值来选取下一条需要执行的字节码指令；</li><li>比如分支、循环、跳转、异常处理、线程恢复等功能都需要依赖这个计数器来完。</li><li>程序计数器是一个在虚拟机中没有规定内存溢出的区域，他的生命周期随着线程的创建而创建，随着线程的结束而死亡<h3 id="主要作用"><a href="#主要作用" class="headerlink" title="主要作用"></a>主要作用</h3></li><li>字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制</li><li>在多线程的情况下，程序计数器用于记录当前线程执行的位置，当线程被切换回来的时候能<br>恢复上次执行的位置</li></ul><h2 id="Java-虚拟机栈"><a href="#Java-虚拟机栈" class="headerlink" title="Java 虚拟机栈"></a>Java 虚拟机栈</h2><p>Java虚拟机栈来描述Java方法的内存模型。每当有新线程创建时就会分配一个栈空间，线程结束后栈<br>空间被回收，栈与线程拥有相同的生命周期。</p><h3 id="虚拟机栈异常"><a href="#虚拟机栈异常" class="headerlink" title="虚拟机栈异常"></a>虚拟机栈异常</h3><ul><li><p>线程请求的栈深度大于虚拟机允许的深度抛出StackOverflowError。</p></li><li><p>如果JVM栈容量可以动态扩展，栈扩展无法申请足够内存抛出OutOfMemoryError </p><h3 id="虚拟机栈特点"><a href="#虚拟机栈特点" class="headerlink" title="虚拟机栈特点"></a>虚拟机栈特点</h3></li><li><p>Java 虚拟机栈是线程私有的，它的生命周期与线程相同（随线程而生，随线程而灭）；</p></li><li><p>如果线程请求的栈深度大于虚拟机所允许的深度，将抛出 StackOverflowError 异常；</p></li><li><p>如果虚拟机栈可以动态扩展，如果扩展时无法申请到足够的内存，就会抛出 OutOfMemoryError 异常；</p></li><li><p>Java 虚拟机栈描述的是 Java 方法执行的内存模型：每个方法执行的同时会创建一个栈帧。对于我们来说，主要关注的栈内存，就是虚拟机栈中局部变量表部分。</p><h3 id="栈帧"><a href="#栈帧" class="headerlink" title="栈帧"></a>栈帧</h3></li><li><p>在虚拟机栈中的元素用于支持虚拟机进行方法调用，每个方法在执行时都会创建一个栈帧存储方法的局部变量表、操作栈、动态链接和方法出口等信息。每个方法从调用到执行完成，就是栈帧从入栈到出栈的过程。</p></li><li><p>栈帧（Stack Frame）是用于支持虚拟机进行方法调用和方法执行的数据结构。它是虚拟机运行时数据区中的 java 虚拟机栈的栈元素</p><h4 id="局部变量表"><a href="#局部变量表" class="headerlink" title="局部变量表"></a>局部变量表</h4><p>局部变量表用于存放方法参数和方法内部定义的局部变量。</p></li><li><p>局部变量表的容量以变量槽（Variable Slot）为最小单位；</p></li><li><p>在方法执行过程中，Java 虚拟机是使用局部变量表完成参数值到参数变量列表的传递过程；</p></li></ul><h4 id="操作栈"><a href="#操作栈" class="headerlink" title="操作栈"></a>操作栈</h4><ul><li>操作数栈是一个后入先出（Last In First Out）栈，方法的执行操作在操作数栈中完成，每一个字节码指令往操作数栈进行写入和提取的过程，就是入栈和出栈的过程；</li><li>操作数栈的每一个元素可以是任意的 Java 数据类型，32 位数据类型所占的栈容量为 1，64 位数据类型所占的栈容量为 2；</li><li>当一个方法刚刚执行的时候，这个方法的操作数栈是空的，在方法执行的过程中，通过一些字节码指令从局部变量表或者对象实例字段中复制常量或者变量值到操作数栈中。<h4 id="动态链接"><a href="#动态链接" class="headerlink" title="动态链接"></a>动态链接</h4></li><li>每个栈帧都包含一个指向运行时常量池（JVM 运行时数据区域）中该栈帧所属方法属性的引用；</li><li>持有这个引用是为了支持方法调用过程中的动态链接。<h4 id="方法出口信息"><a href="#方法出口信息" class="headerlink" title="方法出口信息"></a>方法出口信息</h4>方法出口信息代表的是方法执行结束，方法执行结束有两种方式</li><li>一种方式是执行引擎遇到任意一个方法返回的字节码指令（例如：return），这时候可能会有返回值传递给上层的方法调用者，这种退出方法的方式称为正常完成出口</li><li>另外一种退出方式是，在方法执行过程中遇到了异常，并且这个异常没有在方法体内得到处理，无论是 Java 虚拟机内部产生的异常，还是代码中使用 throw 字节码指令产生的异常，只要在本方法的异常处理器表中没有搜索到匹配的异常处理器，就会导致方法退出，这种退出方法的方式称为异常完成出口</li><li>不管哪种方式，栈帧都会被弹出</li></ul><h2 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h2><ul><li>本地方法栈与虚拟机栈作用相似；</li><li>区别虚拟机栈为虚拟机执行Java方法服务，本地方法栈为虚本地方法服务；</li><li>调用本地方法时虚拟机栈保持不变,动态链接并直接调用指定本地方法；</li><li>本地方法被执行的时候，在本地方法栈也会创建一个栈帧， 用于存放该本地方法的局部变量表、操作数<br>栈、动态链接、出口信息。</li><li>本地方法栈在栈深度异常和栈扩展失败时分别抛出StackOverflowError和OutOfMemoryError。</li></ul>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 内存区域 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java类加载机制</title>
      <link href="/posts/48192.html"/>
      <url>/posts/48192.html</url>
      
        <content type="html"><![CDATA[<h2 id="类加载过程"><a href="#类加载过程" class="headerlink" title="类加载过程"></a>类加载过程</h2><p>Java类加载过程为：加载-链接-初始<br>链接的过程包括验证，准备，解析<br><img src="https://img-blog.csdnimg.cn/14b229396a0d48d686a01c6f18e1d702.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Vwc3RyZWFtNDgw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h4 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h4><p>把编译后的class字节码文件通过类加载器装载入内存中，并将这些数据转换成方法区中的运行时数据（静态变量、静态代码块、常量池等），在堆中生成一个Class类对象代表这个类（反射原理），作为方法区类数据的访问入口。</p><ul><li>通过全类名获取定义此类的二进制字节流</li><li>将字节流所代表的静态存储结构转换为方法区的运行时数据结构</li><li>在内存中生成一个代表该类的Class 对象，作为方法区这些数据的访问入口</li></ul><h4 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h4><p>保证加载进来的字节流符合虚拟机规范，不会造成安全错误</p><ul><li><p>对文件格式的验证，比如常量中是否有不被支持的常量？文件中是否有不规范的或者附加的其他信息？</p></li><li><p>对元数据的验证，比如该类是否继承了被final修饰的类？类中的字段，方法是否与父类冲突？是否出现了不合理的重载？</p></li><li><p>对字节码的验证，保证程序语义的合理性，比如要保证类型转换的合理性。</p></li><li><p>对符号引用的验证，比如校验符号引用中通过全限定名是否能够找到对应的类？校验符号引用中的访问性（private，public等）是否可被当前类访问？</p><h4 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h4></li><li><p>为类变量（不是实例变量）分配内存，并且赋予初值。</p></li><li><p>初值并不是代码中写的初始化的值，而是Java虚拟机根据不同变量类型的默认初始值。</p></li><li><p>比如8种基本类型的初值，默认为0；引用类型的初值则为null；</p></li><li><p>常量的初值即为代码中设置的值，final static num= 456， 那么该阶段num的初值就是456</p><h4 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h4><p>将常量池内的符号引用替换为直接引用的过程；<br>在解析阶段，虚拟机会把所有的类名，方法名，字段名这些符号引用替换为具体的内存地址或偏移量，也就是直接引用。</p></li><li><p>符号引用：一个字符串给出了一些能够唯一性识别一个方法，一个变量，一个类的相关信息。</p></li><li><p>直接引用：一个内存地址或者偏移量。比如类方法，类变量的直接引用是指向方法区的指针；</p></li><li><p>而实例方法，实例变量的直接引用则是从实例的头指针开始算起到这个实例变量位置的偏移量</p></li></ul><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><ul><li>对类变量初始化，是执行类构造器的过程。</li><li>只对static修饰的变量或语句进行初始化。</li><li>如果初始化一个类的时候，其父类尚未初始化，则优先初始化其父类。</li><li>如果同时包含多个静态变量和静态代码块，则按照自上而下的顺序依次执行。</li><li>虚拟机会保证一个类的<clinit>()方法在多线程环境中被正确加锁和同步。</li></ul><h2 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h2><p><img src="https://img-blog.csdnimg.cn/c111bacbdc15478db391e81c6be73d5f.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Vwc3RyZWFtNDgw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h4 id="启动类加载器（bootstrap-class-loader）"><a href="#启动类加载器（bootstrap-class-loader）" class="headerlink" title="启动类加载器（bootstrap class loader）"></a>启动类加载器（bootstrap class loader）</h4><ul><li>用来加载 Java 的核心库(JAVA_HOME/jre/lib/rt.jar,sun.boot.class.path路径下的内容)，是用原生代码C++来实现的，并不继承自 java.lang.ClassLoader。</li><li>加载扩展类和应用程序类加载器。并指定他们的父类加载器。</li></ul><h4 id="扩展类加载器（extensions-class-loader）"><a href="#扩展类加载器（extensions-class-loader）" class="headerlink" title="扩展类加载器（extensions class loader）"></a>扩展类加载器（extensions class loader）</h4><ul><li>用来加载 Java 的扩展库(JAVA_HOME/jre/ext/*.jar，或java.ext.dirs路径下的内容) 。Java 虚拟机的实现会提供一个扩展库目录。该类加载器在此目录里面查找并加载 Java类。</li><li>由sun.misc.Launcher$ExtClassLoader实现。</li></ul><h4 id="应用程序类加载器（application-class-loader）"><a href="#应用程序类加载器（application-class-loader）" class="headerlink" title="应用程序类加载器（application class loader）"></a>应用程序类加载器（application class loader）</h4><ul><li>它根据 Java 应用的类路径（classpath，java.class.path 路径下的内容）来加载 Java 类</li><li>一般来说，Java 应用的类都是由它来完成加载的</li><li>由sun.misc.Launcher$AppClassLoader实现</li></ul><h4 id="自定义类加载器"><a href="#自定义类加载器" class="headerlink" title="自定义类加载器"></a>自定义类加载器</h4><ul><li><p>开发人员可以通过继承 java.lang.ClassLoader类的方式实现自己的类加载器，满足一些特殊的需求。</p><h2 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h2><p>其实这里的双亲很容易让人误解，大家都觉得双亲表示父母的意思，其实这里的双亲是父类的意思，<br>每一个类都有它自己的类加载器。系统中的ClassLoder 在协同工作的时候会默认使用双亲委派<br>模型。</p><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4></li><li><p>向上委托：如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器去执行，如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的启动类加载器。如果父类加载器可以完成类加载任务，就成功返回；</p></li><li><p>向下委派：倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载，一直向下委派加载，这就是双亲委派模式。如果都不能加载，则会报错。<br><img src="https://img-blog.csdnimg.cn/5f3e0d23e0d44ed6aede34fd3c482d2a.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Vwc3RyZWFtNDgw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p></li><li><p>在类加载的时候，系统会首先判断当前类是否被加载过。</p></li><li><p>已经被加载的类会直接返回，否则才会尝试加载。</p></li><li><p>加载的时候，首先会把该请求委派该父类加载器来处理， 因此所有的请求最终都应该传送到顶层的启动类加载器BootstrapClassLoader 中。</p></li><li><p>当父类加载器无法处理时，才由自己来处理。当父类加载器为null时，会使用启动类加载器BootstrapClassLoader 作为父类加载器。</p></li></ul><h2 id="为什么要打破双亲委派"><a href="#为什么要打破双亲委派" class="headerlink" title="为什么要打破双亲委派"></a>为什么要打破双亲委派</h2><p>Tomcat作为一个Web容器，会包含各种Web应用程序，为了使各个应用程序不互相干扰，至少需要达到以下要求：</p><ul><li>部署在同一个Web容器上的两个Web应用程序所使用的Java类库可以实现相互隔离</li><li>部署在同一个Web容器上的两个Web应用程序所使用的Java类库可以相互共享</li><li>Web容器需要保证自身的安全不受Web应用程序所影响</li></ul><p>tomcat 为了实现隔离性，没有遵守双亲委派模型，所以在Tomcat中，类的加载不能使用简单的ClassLoader来加载，而是需要自定义分级的ClassLoader。</p><h4 id="Tomcat类加载过程"><a href="#Tomcat类加载过程" class="headerlink" title="Tomcat类加载过程"></a>Tomcat类加载过程</h4><ol><li>先在本地缓存中查看是否已经加载过该类，如果已经加载过就返回</li><li>否则就让系统类加载器(AppClassLoader)尝试加载该类</li><li>这一步主要是为了防止一些基础类会被web中的类覆盖，如果加载到即返回</li><li>前两步均没加载到目标类，那么web应用的类加载器将自行加载，如果加载到则返回，否则继续下一步。</li><li>最后还是加载不到的话，则委托父类加载器去加载。</li></ol>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 双亲委派 </tag>
            
            <tag> 类加载 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RabbitMQ中消息确认和返回机制</title>
      <link href="/posts/25789.html"/>
      <url>/posts/25789.html</url>
      
        <content type="html"><![CDATA[<h1 id="RabbitMQ中消息确认和返回机制"><a href="#RabbitMQ中消息确认和返回机制" class="headerlink" title="RabbitMQ中消息确认和返回机制"></a>RabbitMQ中消息确认和返回机制</h1><ul><li>为了保证 RabbitMQ 中消息的可靠性投递，以及消息在发生特定异常时的补偿策略</li><li>RabbitMQ诞生了消息确认和返回机制</li><li>这两种机制是 RabbitMQ 自带的补偿机制，可以直接使用<h2 id="消息确认"><a href="#消息确认" class="headerlink" title="消息确认"></a>消息确认</h2><h3 id="消息确认机制"><a href="#消息确认机制" class="headerlink" title="消息确认机制"></a>消息确认机制</h3></li><li>消息确认机制，是保障消息与 RabbitMQ消息之间可靠传输消息一种保障机制</li><li>其主要内容就是用来监听RabbitMQ消息队列收到消息之后返回给生产端的ack确认消息</li><li>消息确认机制描述了一种消息是否已经被发送到 RabbitMQ消息队列中以及 RabbitMQ消息队列是否以及接收到生产端发送的消息。<br><img src="https://img-blog.csdnimg.cn/99aeca6ce8204c8594533573a094443a.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Vwc3RyZWFtNDgw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><h3 id="消息确认机制的作用"><a href="#消息确认机制的作用" class="headerlink" title="消息确认机制的作用"></a>消息确认机制的作用</h3></li><li>监听生产者的消息是否已经发送到了 RabbitMQ消息队列中；</li><li>如果消息没有被发送到 RabbitMQ消息队列中，则消息确认机制不会给生产端返回任何确认应答，也就是没有发送成功</li><li>相反，如果消息被成功发送到了 RabbitMQ消息队列中，则消息确认机制会给生产端返回一个确认应答，</li><li>以通知生产者，消息已经发送到了 RabbitMQ消息队列</li></ul><h2 id="返回机制"><a href="#返回机制" class="headerlink" title="返回机制"></a>返回机制</h2><h3 id="消息返回机制"><a href="#消息返回机制" class="headerlink" title="消息返回机制"></a>消息返回机制</h3><ul><li>描述不可达的消息与生产者之间的一种保障策略</li><li>其主要是用来监听，RabbitMQ消息队列中是否存在不可达的消息，并根据监听结果返回给生产端的一种监听机制</li><li>消息返回机制描述了一种 RabbitMQ消息队列中的不可达消息与生产端的关系<br><img src="https://img-blog.csdnimg.cn/cf4a5ba4eba842edb8351b4d6d9f9edc.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Vwc3RyZWFtNDgw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><h3 id="什么是不可达的消息"><a href="#什么是不可达的消息" class="headerlink" title="什么是不可达的消息"></a>什么是不可达的消息</h3></li><li>消息在被成功发送到RabbitMQ消息队列中之后，如果消息在经过当前配置的 exchangeName 或 routingKey 没有找到指定的交换机，或没有匹配到对应的消息队列，</li><li>那么这个消息就被称为不可达的消息，如果此时配置了消息返回机制，那么此时RabbitMQ消息队列会返回给生产者一个信号，信号中包括消息不可达的原因，以及消息本身的内容。</li></ul><h3 id="消息确认机制的作用-1"><a href="#消息确认机制的作用-1" class="headerlink" title="消息确认机制的作用"></a>消息确认机制的作用</h3><ul><li>监听生产端发动到RabbitMQ消息队列中的消息是否可达</li><li>如果消息不可达，则返回一个信号通知生产端，相反，如果消息可达，则不会返回任何信号</li></ul>]]></content>
      
      
      <categories>
          
          <category> 消息队列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 确认机制 </tag>
            
            <tag> 返回机制 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RabbitMQ队列模型</title>
      <link href="/posts/54078.html"/>
      <url>/posts/54078.html</url>
      
        <content type="html"><![CDATA[<h2 id="模型定义"><a href="#模型定义" class="headerlink" title="模型定义"></a>模型定义</h2><ul><li>生产者（Producer）：发送消息到队列的模块，可以理解为消息的提供者</li><li>队列（Queue）：存储消息的一段空间，作为消息的缓存模块；</li><li>消费者（Consumer）：从队列中接受消息的模块，可以理解为消息的处理者</li><li>交换机（Exchange）：消息不直接发到队列，首先发到 Exchange 模块，再根据路由规则转发到定制化的队列。<h2 id="队列模型"><a href="#队列模型" class="headerlink" title="队列模型"></a>队列模型</h2></li><li>简单队列</li><li>工作队列</li><li>发布/订阅队列</li><li>路由队列</li><li>主题队列</li></ul><h2 id="简单队列"><a href="#简单队列" class="headerlink" title="简单队列"></a>简单队列</h2><p>在简单队列模型中，只有一个生产者、一个消息队列、一个消费者。<br><img src="https://img-blog.csdnimg.cn/5ec9510d3e9e4bbba1bdfe6e6956c967.png" alt="在这里插入图片描述"></p><ul><li>优点是不需要配置复杂的路由规则</li><li>缺点是只支持一对一通信</li><li>在大多数场景中一般不会使用这种队列<h2 id="工作队列（Work-Queue）"><a href="#工作队列（Work-Queue）" class="headerlink" title="工作队列（Work Queue）"></a>工作队列（Work Queue）</h2>在工作队列模型中，一个生产者，拥有向多个消息消费者发送消息的能力，但是一条消息只能被一个消费者消费。<br>如何保证详细不被重复消费，在使用消息队列时也是需要考虑的问题</li></ul><p><img src="https://img-blog.csdnimg.cn/daf04b39bb484ab989e8104067a620e3.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Vwc3RyZWFtNDgw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ul><li>应用场景：需要将流量打散到多个消费者模块的场景，也就是削峰</li><li>例如美团点餐中，某一时段点餐高峰，电商秒杀等，瞬时流量很大的应用<h2 id="发布-订阅队列（Publish-Subscribe）"><a href="#发布-订阅队列（Publish-Subscribe）" class="headerlink" title="发布/订阅队列（Publish/Subscribe）"></a>发布/订阅队列（Publish/Subscribe）</h2><img src="https://img-blog.csdnimg.cn/cb5ce4cf7f8c4ae3b6b66b2ac5704ced.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Vwc3RyZWFtNDgw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li><li>在发布/订阅队列模型中，生产者只能向交换机发送消息，交换机绑定了多个队列，</li><li>所有绑定该交换机的队列都会收到交换机中的所有消息。</li></ul><p>交换机存在四种路由方式：</p><ul><li>direct</li><li>topic</li><li>headers</li><li>fanout-广播</li></ul><p>发布/订阅模型是非常常见的队列模型<br>例如上篇文章中的注册流程中，一个用户的注册请求需要往短信服务和邮箱服务发送消息，可以使用该模型。</p><h2 id="路由队列（Routing）"><a href="#路由队列（Routing）" class="headerlink" title="路由队列（Routing）"></a>路由队列（Routing）</h2><p>路由队列也是在发布/订阅队列模型中的一种，只是交换机的路由方式不一样，交换机的路由方式为direct模式<br><img src="https://img-blog.csdnimg.cn/cb5ce4cf7f8c4ae3b6b66b2ac5704ced.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Vwc3RyZWFtNDgw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ul><li>在路由队列模型中，生产者将消息发送到 direct 模式的交换机，交换机和队列绑定的时候限制了路由 Key。</li><li>当生产者发送一条消息的时候，会指定一条路由 Key，这条消息只会发送到对应的队列中</li><li>每个队列都会绑定一个key，只有发送消息的key和绑定key相同的队列才能收到消息</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Configuration</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">RabbitmqDirectConfig</span> <span class="token punctuation">&#123;</span>    <span class="token comment">/**     * 队列 queue     */</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">String</span> QUEUE_DIRECT_01 <span class="token operator">=</span> <span class="token string">"queue_direct01"</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">String</span> QUEUE_DIRECT_02 <span class="token operator">=</span> <span class="token string">"queue_direct02"</span><span class="token punctuation">;</span>    <span class="token comment">/**     * 交换机 exchange     */</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">String</span> DIRECT_EXCHANGE <span class="token operator">=</span> <span class="token string">"directExchange"</span><span class="token punctuation">;</span>    <span class="token comment">/**     * 路由键 routingkey #表示0或多个单词，*表示一个单词     */</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">String</span> QUEUE_RED <span class="token operator">=</span> <span class="token string">"queue.red"</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">String</span> QUEUE_GREEN <span class="token operator">=</span> <span class="token string">"queue.green"</span><span class="token punctuation">;</span>    <span class="token annotation punctuation">@Bean</span>    <span class="token keyword">public</span> <span class="token class-name">Queue</span> <span class="token function">queueDirect01</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Queue</span><span class="token punctuation">(</span>QUEUE_DIRECT_01<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token annotation punctuation">@Bean</span>    <span class="token keyword">public</span> <span class="token class-name">Queue</span> <span class="token function">queueDirect02</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Queue</span><span class="token punctuation">(</span>QUEUE_DIRECT_02<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token annotation punctuation">@Bean</span>    <span class="token keyword">public</span> <span class="token class-name">DirectExchange</span> <span class="token function">directExchange</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">DirectExchange</span><span class="token punctuation">(</span>DIRECT_EXCHANGE<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token annotation punctuation">@Bean</span>    <span class="token keyword">public</span> <span class="token class-name">Binding</span> <span class="token function">bindingDirectRed</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token class-name">BindingBuilder</span><span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token function">queueDirect01</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token keyword">to</span><span class="token punctuation">(</span><span class="token function">directExchange</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token keyword">with</span><span class="token punctuation">(</span>QUEUE_RED<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token annotation punctuation">@Bean</span>    <span class="token keyword">public</span> <span class="token class-name">Binding</span> <span class="token function">bindingDirectGreen</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token class-name">BindingBuilder</span><span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token function">queueDirect02</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token keyword">to</span><span class="token punctuation">(</span><span class="token function">directExchange</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token keyword">with</span><span class="token punctuation">(</span>QUEUE_GREEN<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>路由队列的优势是能够定制化发送消息，消费者选择性收听消息，适合灵活变通的应用场景。</p><h2 id="主题队列（Topics）"><a href="#主题队列（Topics）" class="headerlink" title="主题队列（Topics）"></a>主题队列（Topics）</h2><p>主题队列也是在发布/订阅队列模型中的一种，只是交换机的路由方式不一样，交换机的路由方式为topic模式<br><img src="https://img-blog.csdnimg.cn/cb5ce4cf7f8c4ae3b6b66b2ac5704ced.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Vwc3RyZWFtNDgw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ul><li>在主题队列模型中，实际上是基于路由队列的定制化配置，支持了key的通配符匹配</li><li>简单理解就是正则表达式+路由key。</li><li>例如*.queue只能匹配到a.queue类似的key，但是queue.#可以匹配到queue.a或者queue.a.b类似的key。</li><li>应用场景与路由队列相同。<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/** * Title: RabbitmqTopicConfig * Description: Topic模式常用 */</span><span class="token annotation punctuation">@Configuration</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">RabbitmqTopicConfig</span> <span class="token punctuation">&#123;</span>    <span class="token comment">/**     * 队列 queue     */</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">String</span> QUEUE_TOPIC_01 <span class="token operator">=</span> <span class="token string">"queue_topic01"</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">String</span> QUEUE_TOPIC_02 <span class="token operator">=</span> <span class="token string">"queue_topic02"</span><span class="token punctuation">;</span>    <span class="token comment">/**     * 交换机 exchange     */</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">String</span> TOPIC_EXCHANGE <span class="token operator">=</span> <span class="token string">"topicExchange"</span><span class="token punctuation">;</span>    <span class="token comment">/**     * 路由键 routingkey     * #表示匹配0或多个单词     * *表示匹配一个单词     */</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">String</span> ROUTINGKEY_01 <span class="token operator">=</span> <span class="token string">"#.queue.#"</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">String</span> ROUTINGKEY_02 <span class="token operator">=</span> <span class="token string">"*.queue.#"</span><span class="token punctuation">;</span>    <span class="token annotation punctuation">@Bean</span>    <span class="token keyword">public</span> <span class="token class-name">Queue</span> <span class="token function">queueTopic01</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Queue</span><span class="token punctuation">(</span>QUEUE_TOPIC_01<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token annotation punctuation">@Bean</span>    <span class="token keyword">public</span> <span class="token class-name">Queue</span> <span class="token function">queueTopic02</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Queue</span><span class="token punctuation">(</span>QUEUE_TOPIC_02<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token annotation punctuation">@Bean</span>    <span class="token keyword">public</span> <span class="token class-name">TopicExchange</span> <span class="token function">topicExchange</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">TopicExchange</span><span class="token punctuation">(</span>TOPIC_EXCHANGE<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token annotation punctuation">@Bean</span>    <span class="token keyword">public</span> <span class="token class-name">Binding</span> <span class="token function">bindingTopic01</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token class-name">BindingBuilder</span><span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token function">queueTopic01</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token keyword">to</span><span class="token punctuation">(</span><span class="token function">topicExchange</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token keyword">with</span><span class="token punctuation">(</span>ROUTINGKEY_01<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token annotation punctuation">@Bean</span>    <span class="token keyword">public</span> <span class="token class-name">Binding</span> <span class="token function">bindingTopic02</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token class-name">BindingBuilder</span><span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token function">queueTopic02</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token keyword">to</span><span class="token punctuation">(</span><span class="token function">topicExchange</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token keyword">with</span><span class="token punctuation">(</span>ROUTINGKEY_02<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul>]]></content>
      
      
      <categories>
          
          <category> 消息队列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 队列模型 </tag>
            
            <tag> 发布/订阅 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>消息队列基础</title>
      <link href="/posts/23133.html"/>
      <url>/posts/23133.html</url>
      
        <content type="html"><![CDATA[<h2 id="什么是队列"><a href="#什么是队列" class="headerlink" title="什么是队列"></a>什么是队列</h2><p>队列这个概念非常好理解，你可以把它想象为在食堂排队打饭，先来的先打，后来的人只能站末尾，不允许插队，先进者先出，这就是典型的队列。<br><img src="https://img-blog.csdnimg.cn/57c51a3affa14b1cabd0ba528e4a571b.png" alt="在这里插入图片描述"><br>队列的特定就是先进先出，先来的先出去</p><h2 id="什么是消息队列"><a href="#什么是消息队列" class="headerlink" title="什么是消息队列"></a>什么是消息队列</h2><h3 id="消息"><a href="#消息" class="headerlink" title="消息"></a>消息</h3><ul><li>消息是指在应用间传送的数据。</li><li>消息可以非常简单，比如只包含文本字符串，也可以更复杂，可能包含嵌入对象。<h3 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h3></li><li>消息队列是一种应用间的通信方式，说白了就是存放消息的队列</li><li>消息发送后可以立即返回，由消息系统来确保消息的可靠传递。</li><li>消息发布者只管把消息发布到队列中，而不用管谁来取</li><li>消息使用者只管从队列中取消息而不管是谁发布的</li><li>这样发布者和使用者都不用知道对方的存在</li><li>常见的消息队列有 RabbitMQ、RocketMQ、Kafka<br><img src="https://img-blog.csdnimg.cn/b1ebd6c92b4e42a6a823a6a6f7710620.png" alt="在这里插入图片描述"><h3 id="什么是-RabbitMQ-？"><a href="#什么是-RabbitMQ-？" class="headerlink" title="什么是 RabbitMQ ？"></a>什么是 RabbitMQ ？</h3></li></ul><p><strong>一场使用消息进行通信的高可用和数据安全的在线会议</strong><br>这句话是RabbitMQ官网的描述</p><p>实际上，RabbitMQ 是一种消息通信方式，采用消息队列的形式，来将消息进行传递与发送，RabbitMQ 在通过消息队列传递消息时，可以保证消息的高可用性、消息中数据的安全性。</p><p>也就是说，RabbitMQ 是一种高可用且数据安全的消息通信中间件。</p><h2 id="为什么要使用消息队列"><a href="#为什么要使用消息队列" class="headerlink" title="为什么要使用消息队列"></a>为什么要使用消息队列</h2><ul><li>消息队列也是针对特定问题有不同的使用场景，</li><li>任何技术的产生都是为了解决问题</li><li>消息队列主要用于异步处理、应用解耦、流量削峰三种场景。</li></ul><h3 id="异步处理"><a href="#异步处理" class="headerlink" title="异步处理"></a>异步处理</h3><p>我们可以想象一种场景，我们的在网站注册新用户的时候：</p><ul><li>填写注册信息后，</li><li>需要发送验证码，</li><li>用户收到验证码输入，要通过短信和邮件的方式验证是否用户本人注册，每个流程的请求响应耗时为 100ms，在同步的方式下总共需要耗时 300ms。<h4 id="同步场景"><a href="#同步场景" class="headerlink" title="同步场景"></a>同步场景</h4><img src="https://img-blog.csdnimg.cn/a81809139ee64501a0d26ca2024b72e6.png" alt="在这里插入图片描述"><h4 id="异步场景"><a href="#异步场景" class="headerlink" title="异步场景"></a>异步场景</h4></li><li>在异步场景下，我们不用等待邮件是否发送成功，只需写入注册信息后</li><li>开启两个异步任务，调用邮件合短信服务，两个服务同时完成，</li><li>最终响应只需要200ms<br><img src="https://img-blog.csdnimg.cn/f99f028886ba46ffad1e8fcce00bf8cb.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Vwc3RyZWFtNDgw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li></ul><h4 id="消息队列-1"><a href="#消息队列-1" class="headerlink" title="消息队列"></a>消息队列</h4><ul><li>使用消息队列后，我们直接发送注册消息后，系统直接返回，</li><li>至于后面的邮件合短信服务是否进行，我们不要要管理</li><li>反正他们最终一定会执行</li><li>最终只需要100ms<br><img src="https://img-blog.csdnimg.cn/d84ce079d16b4144840fb2e64159ebc9.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Vwc3RyZWFtNDgw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li></ul><p>后面的邮件服务和短信服务，直接去消息队列中取消息消息后执行即可<br>​</p><h3 id="应用解耦"><a href="#应用解耦" class="headerlink" title="应用解耦"></a>应用解耦</h3><p>上述异步请求的过程本质上也是应用解耦的过程，再模拟一个场景，用户下订单后，需要调用库存服务，如果库存服务升级，订单服务也跟着需要升级，耦合度比较高</p><p><img src="https://img-blog.csdnimg.cn/dfc435c06f114577a8bbba116f319780.png" alt="在这里插入图片描述"></p><p>引入消息队列后，只需要统一消息即可，实现高内聚，低耦合<img src="https://img-blog.csdnimg.cn/eea14b2cd5b44ab6a618c06c04a2b970.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Vwc3RyZWFtNDgw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="流量削峰"><a href="#流量削峰" class="headerlink" title="流量削峰"></a>流量削峰</h3><ul><li>互联网存在很多高并发场景，例如在 12306 抢购春运火车票，或者天猫的双十一和各类电商的秒杀秒杀活动，</li><li>系统在短时间收到大量的用户请求，数据库无法处理相对日常的数倍流量</li><li>数据库非常容易被压垮甚至宕机，会导致服务不可用。</li><li>为了避免这种情况发生，有熔断、降级、以及流量削峰等多种解决方案，消息队列是最常见的流量削峰方案。</li></ul><p><img src="https://img-blog.csdnimg.cn/e97cd65603d64304a767536ae13f5f66.png" alt="在这里插入图片描述"></p><ul><li>业务代码从消息队列中拿到用户请求，再执行后续的业务逻辑。</li><li>消息队列在用户和业务逻辑中之间作为中间件模块</li><li>库存服务可以一条一条的处理消息，防止大量流量直接打到底层数据库。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 消息队列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RabbitMQ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java集合之HashMap(三)</title>
      <link href="/posts/60692.html"/>
      <url>/posts/60692.html</url>
      
        <content type="html"><![CDATA[<h2 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h2><p>在多线程，高并发的场景下，HashMap存在线程安全问题</p><ul><li>主要原因在于并发下的rehash会造成元素之间会形成一个循环链表。</li><li>jdk 1.8 后解决了这个问题，但是还是不应该在多线程下使用HashMap ，因为多线程下使用HashMap 还是会存在其他问题比如数据丢失。</li><li>并发环境下推荐使用Concur rentHashMap</li></ul><h2 id="ConcurrentHashMap和HashMap的区别"><a href="#ConcurrentHashMap和HashMap的区别" class="headerlink" title="ConcurrentHashMap和HashMap的区别"></a>ConcurrentHashMap和HashMap的区别</h2><p>Concur rentHashMap和Hashtable 的区别主要体现在实现线程安全的方式上不同。</p><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><ul><li>Java8以前的ConcurrentHashMap采用分段的数组+链表实现</li><li>Java8以后采用的数据结构跟HashMap1.8的结构一样，数组+链表/红黑二叉树。</li><li>HashMap 和ConcurrentHashMap的底层数据结构类似都是采用数组+链表的形式</li><li>数组是HashMap 的主体，链表则是主要为了解决哈希冲突而存在的;<h4 id="java8前"><a href="#java8前" class="headerlink" title="java8前"></a>java8前</h4><img src="https://img-blog.csdnimg.cn/813a80c60f4d4ec4b22098c8f98c5e1c.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Vwc3RyZWFtNDgw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><h4 id="Java8后"><a href="#Java8后" class="headerlink" title="Java8后"></a>Java8后</h4><img src="https://img-blog.csdnimg.cn/eafa20c43aa14a999185c67c3b5bd3bd.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Vwc3RyZWFtNDgw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li></ul><h3 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式:"></a>实现方式:</h3><ul><li>在Java8以前，ConcurrentHashMap 对整个数组进行了分段(Segment),</li><li>每一把锁只锁数组中一部分数据，多线程访问数组里不同数据段的数据，就不会存在锁竞争，提高并发访问率</li><li>Java8以后已经放弃了段的概念，直接用数组+链表+红黑树的数据结构来实现</li><li>并发控制使用synchronized和CAS(比较交换)来操作</li><li>Java8中虽然还能看到分段的数据结构，但属性都已经大大简化了，只是为了兼容旧版本<br><img src="https://img-blog.csdnimg.cn/1f692597e280492b97fe11f1658bb428.png" alt="在这里插入图片描述"></li></ul><h3 id="Hashtable实现线程安全的方式"><a href="#Hashtable实现线程安全的方式" class="headerlink" title="Hashtable实现线程安全的方式"></a>Hashtable实现线程安全的方式</h3><ul><li>Hashtable(同一把锁) :使用synchronized 来保证线程安全，效率非常低下</li><li>当一个线程访问同步方法时，其他线程也访问同步方法，可能会进入阻塞或轮询状态</li><li>如使用put添加元素，另一个线程不能使用put添加元素，也不能使用get, 竞争会越来越激烈<br>效率越低。</li></ul><h3 id="JDK1-8与JDK1-7的性能对比"><a href="#JDK1-8与JDK1-7的性能对比" class="headerlink" title="JDK1.8与JDK1.7的性能对比"></a>JDK1.8与JDK1.7的性能对比</h3><ul><li>HashMap中，如果key经过hash算法得出的数组索引位置全部不相同，即Hash算法非常好，那样的话，getKey方法的时间复杂度就是O(1)，</li><li>如果Hash算法技术的结果碰撞非常多，假如Hash算极其差，所有的Hash算法结果得出的索引位置一样，那样所有的键值对都集中到一个数组中，或者在一个链表中，或者在一个红黑树中，时间复杂度分别为O(n)和O(lgn)</li></ul><h3 id="ConcurrentHashMap线程安全的具体实现方式-底层具体实现"><a href="#ConcurrentHashMap线程安全的具体实现方式-底层具体实现" class="headerlink" title="ConcurrentHashMap线程安全的具体实现方式/底层具体实现"></a>ConcurrentHashMap线程安全的具体实现方式/底层具体实现</h3><h4 id="JDK1-7"><a href="#JDK1-7" class="headerlink" title="JDK1.7"></a>JDK1.7</h4><ul><li>首先将数据分为一段一段的存储，然后给每一段数据配一把锁，当个线程占用锁访问其中一个段数据<br>时，其他段的数据也能被其他线程访问。</li><li>ConcurrentHashMap是由Segment 数组结构和HashEntry 数组结构组成。</li><li>Segment实现了Reentr antLock ，所以Segment 是一种可重入锁，扮演锁的角色。HashEntry 用于存储<br>键值对数据。</li><li>一个 ConcurrentHashMap 里包含一个Segment数组。Segment 的结构和HashMap类似，是一种数组和<br>链表结构，一个Segment 包含一个HashEntry 数组，每个HashEntry 是个链表结构的元素，每个Segment守护着一个HashEntry数组里的元素，当对HashEntry 数组的数据进行修改时，必须首先获得<br>对应的Segment的锁 。<h4 id="JDK1-8"><a href="#JDK1-8" class="headerlink" title="JDK1.8"></a>JDK1.8</h4></li><li>ConcurrentHashMap取消了分段锁，采用CAS和synchronized来保证并发安全。</li><li>数据结构跟HashMap1.8的结构类似，数组+链表/红黑二叉树。</li><li>Java 8后在链表长度超过0时将链表转换为红黑树</li><li>synchronized只锁定当前链表或红黑树的首节点，这样只要hash不冲突，就不会产生并发，提升效率</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HashMap </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java集合之HashMap(二)</title>
      <link href="/posts/32182.html"/>
      <url>/posts/32182.html</url>
      
        <content type="html"><![CDATA[<h2 id="HashMap扩容机制"><a href="#HashMap扩容机制" class="headerlink" title="HashMap扩容机制"></a>HashMap扩容机制</h2><h3 id="明确几个参数："><a href="#明确几个参数：" class="headerlink" title="明确几个参数："></a>明确几个参数：</h3><ul><li>capacity 即容量，默认16。</li><li>loadFactor 加载因子，默认是0.75</li><li>threshold 阈值。阈值=容量*加载因子。默认12。当元素数量超过阈值时便会触发扩容。</li></ul><h3 id="什么时候触发扩容？"><a href="#什么时候触发扩容？" class="headerlink" title="什么时候触发扩容？"></a>什么时候触发扩容？</h3><ul><li>一般情况下，当元素数量超过阈值时便会触发扩容。每次扩容的容量都是之前容量的2倍。</li><li>HashMap的容量是有上限的，必须小于1&lt;&lt;30，即1073741824。</li><li>如果容量超出了这个数，则不再增长，且阈值会被设置为Integer.MAX_VALUE<h3 id="什么是扩容"><a href="#什么是扩容" class="headerlink" title="什么是扩容"></a>什么是扩容</h3></li><li>扩容(resize)就是重新计算HashMap的容量，向HashMap对象里不停的添加元素，而HashMap对象内部的数组无法装载更多的元素时，对象就需要扩大数组的长度，以便能装入更多的元素。</li><li>当然Java里的数组是无法自动扩容的，因为数组空间是连续分配的，必须使用一个新的数组代替已有的容量小的数组，就像我们用一个小瓶子装水，水装满之后如果想装更多的水，就得换大瓶子。</li></ul><h3 id="HashMap扩容源码"><a href="#HashMap扩容源码" class="headerlink" title="HashMap扩容源码"></a>HashMap扩容源码</h3><h4 id="JDK1-7"><a href="#JDK1-7" class="headerlink" title="JDK1.7"></a>JDK1.7</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Entry</span><span class="token punctuation">[</span><span class="token punctuation">]</span> newTable <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Entry</span><span class="token punctuation">[</span>newCapacity<span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment">//初始化一个新的Entry数组</span><span class="token function">transfer</span><span class="token punctuation">(</span>newTable<span class="token punctuation">)</span><span class="token punctuation">;</span>                         <span class="token comment">//！！将数据转移到新的Entry数组里</span>table <span class="token operator">=</span> newTable<span class="token punctuation">;</span>                           <span class="token comment">//HashMap的table属性引用新的Entry数组</span>threshold <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">(</span>newCapacity <span class="token operator">*</span> loadFactor<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//修改阈值</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ul><li>这里就是使用一个容量更大的数组来代替已有的容量小的数组</li><li>transfer()方法将原有Entry数组的元素拷贝到新的Entry数组里<h4 id="JDK1-8"><a href="#JDK1-8" class="headerlink" title="JDK1.8"></a>JDK1.8</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java"> <span class="token number">1</span> <span class="token keyword">final</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">resize</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token number">2</span>     <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> oldTab <span class="token operator">=</span> table<span class="token punctuation">;</span> <span class="token number">3</span>     <span class="token keyword">int</span> oldCap <span class="token operator">=</span> <span class="token punctuation">(</span>oldTab <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> oldTab<span class="token punctuation">.</span>length<span class="token punctuation">;</span> <span class="token number">4</span>     <span class="token keyword">int</span> oldThr <span class="token operator">=</span> threshold<span class="token punctuation">;</span> <span class="token number">5</span>     <span class="token keyword">int</span> newCap<span class="token punctuation">,</span> newThr <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token number">6</span>     <span class="token keyword">if</span> <span class="token punctuation">(</span>oldCap <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token number">7</span>         <span class="token comment">// 超过最大值就不再扩充了</span> <span class="token number">8</span>         <span class="token keyword">if</span> <span class="token punctuation">(</span>oldCap <span class="token operator">>=</span> MAXIMUM_CAPACITY<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token number">9</span>             threshold <span class="token operator">=</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span>MAX_VALUE<span class="token punctuation">;</span><span class="token number">10</span>             <span class="token keyword">return</span> oldTab<span class="token punctuation">;</span><span class="token number">11</span>         <span class="token punctuation">&#125;</span><span class="token number">12</span>         <span class="token comment">// 没超过最大值，就扩充为原来的2倍</span><span class="token number">13</span>         <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>newCap <span class="token operator">=</span> oldCap <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> MAXIMUM_CAPACITY <span class="token operator">&amp;&amp;</span><span class="token number">14</span>                  oldCap <span class="token operator">>=</span> DEFAULT_INITIAL_CAPACITY<span class="token punctuation">)</span><span class="token number">15</span>             newThr <span class="token operator">=</span> oldThr <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// double threshold</span><span class="token number">16</span>     <span class="token punctuation">&#125;</span><span class="token number">17</span>     <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>oldThr <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token comment">// initial capacity was placed in threshold</span><span class="token number">18</span>         newCap <span class="token operator">=</span> oldThr<span class="token punctuation">;</span><span class="token number">19</span>     <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>               <span class="token comment">// zero initial threshold signifies using defaults</span><span class="token number">20</span>         newCap <span class="token operator">=</span> DEFAULT_INITIAL_CAPACITY<span class="token punctuation">;</span><span class="token number">21</span>         newThr <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">(</span>DEFAULT_LOAD_FACTOR <span class="token operator">*</span> DEFAULT_INITIAL_CAPACITY<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token number">22</span>     <span class="token punctuation">&#125;</span><span class="token number">23</span>     <span class="token comment">// 计算新的resize上限</span><span class="token number">24</span>     <span class="token keyword">if</span> <span class="token punctuation">(</span>newThr <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token number">25</span> <span class="token number">26</span>         <span class="token keyword">float</span> ft <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">float</span><span class="token punctuation">)</span>newCap <span class="token operator">*</span> loadFactor<span class="token punctuation">;</span><span class="token number">27</span>         newThr <span class="token operator">=</span> <span class="token punctuation">(</span>newCap <span class="token operator">&lt;</span> MAXIMUM_CAPACITY <span class="token operator">&amp;&amp;</span> ft <span class="token operator">&lt;</span> <span class="token punctuation">(</span><span class="token keyword">float</span><span class="token punctuation">)</span>MAXIMUM_CAPACITY <span class="token operator">?</span><span class="token number">28</span>                   <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>ft <span class="token operator">:</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span>MAX_VALUE<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token number">29</span>     <span class="token punctuation">&#125;</span><span class="token number">30</span>     threshold <span class="token operator">=</span> newThr<span class="token punctuation">;</span><span class="token number">31</span>     <span class="token annotation punctuation">@SuppressWarnings</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span><span class="token string">"rawtypes"</span>，<span class="token string">"unchecked"</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token number">32</span>         <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> newTab <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">[</span>newCap<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token number">33</span>     table <span class="token operator">=</span> newTab<span class="token punctuation">;</span><span class="token number">34</span>     <span class="token keyword">if</span> <span class="token punctuation">(</span>oldTab <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token number">35</span>         <span class="token comment">// 把每个bucket都移动到新的buckets中</span><span class="token number">36</span>         <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> oldCap<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token number">37</span>             <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> e<span class="token punctuation">;</span><span class="token number">38</span>             <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> oldTab<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token number">39</span>                 oldTab<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span><span class="token number">40</span>                 <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span>next <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token number">41</span>                     newTab<span class="token punctuation">[</span>e<span class="token punctuation">.</span>hash <span class="token operator">&amp;</span> <span class="token punctuation">(</span>newCap <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> e<span class="token punctuation">;</span><span class="token number">42</span>                 <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>e <span class="token keyword">instanceof</span> <span class="token class-name">TreeNode</span><span class="token punctuation">)</span><span class="token number">43</span>                     <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span><span class="token punctuation">)</span>e<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> newTab<span class="token punctuation">,</span> j<span class="token punctuation">,</span> oldCap<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token number">44</span>                 <span class="token keyword">else</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 链表优化重hash的代码块</span><span class="token number">45</span>                     <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> loHead <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">,</span> loTail <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span><span class="token number">46</span>                     <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> hiHead <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">,</span> hiTail <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span><span class="token number">47</span>                     <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> next<span class="token punctuation">;</span><span class="token number">48</span>                     <span class="token keyword">do</span> <span class="token punctuation">&#123;</span><span class="token number">49</span>                         next <span class="token operator">=</span> e<span class="token punctuation">.</span>next<span class="token punctuation">;</span><span class="token number">50</span>                         <span class="token comment">// 原索引</span><span class="token number">51</span>                         <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span>hash <span class="token operator">&amp;</span> oldCap<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token number">52</span>                             <span class="token keyword">if</span> <span class="token punctuation">(</span>loTail <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token number">53</span>                                 loHead <span class="token operator">=</span> e<span class="token punctuation">;</span><span class="token number">54</span>                             <span class="token keyword">else</span><span class="token number">55</span>                                 loTail<span class="token punctuation">.</span>next <span class="token operator">=</span> e<span class="token punctuation">;</span><span class="token number">56</span>                             loTail <span class="token operator">=</span> e<span class="token punctuation">;</span><span class="token number">57</span>                         <span class="token punctuation">&#125;</span><span class="token number">58</span>                         <span class="token comment">// 原索引+oldCap</span><span class="token number">59</span>                         <span class="token keyword">else</span> <span class="token punctuation">&#123;</span><span class="token number">60</span>                             <span class="token keyword">if</span> <span class="token punctuation">(</span>hiTail <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token number">61</span>                                 hiHead <span class="token operator">=</span> e<span class="token punctuation">;</span><span class="token number">62</span>                             <span class="token keyword">else</span><span class="token number">63</span>                                 hiTail<span class="token punctuation">.</span>next <span class="token operator">=</span> e<span class="token punctuation">;</span><span class="token number">64</span>                             hiTail <span class="token operator">=</span> e<span class="token punctuation">;</span><span class="token number">65</span>                         <span class="token punctuation">&#125;</span><span class="token number">66</span>                     <span class="token punctuation">&#125;</span> <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> next<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token number">67</span>                     <span class="token comment">// 原索引放到bucket里</span><span class="token number">68</span>                     <span class="token keyword">if</span> <span class="token punctuation">(</span>loTail <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token number">69</span>                         loTail<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span><span class="token number">70</span>                         newTab<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> loHead<span class="token punctuation">;</span><span class="token number">71</span>                     <span class="token punctuation">&#125;</span><span class="token number">72</span>                     <span class="token comment">// 原索引+oldCap放到bucket里</span><span class="token number">73</span>                     <span class="token keyword">if</span> <span class="token punctuation">(</span>hiTail <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token number">74</span>                         hiTail<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span><span class="token number">75</span>                         newTab<span class="token punctuation">[</span>j <span class="token operator">+</span> oldCap<span class="token punctuation">]</span> <span class="token operator">=</span> hiHead<span class="token punctuation">;</span><span class="token number">76</span>                     <span class="token punctuation">&#125;</span><span class="token number">77</span>                 <span class="token punctuation">&#125;</span><span class="token number">78</span>             <span class="token punctuation">&#125;</span><span class="token number">79</span>         <span class="token punctuation">&#125;</span><span class="token number">80</span>     <span class="token punctuation">&#125;</span><span class="token number">81</span>     <span class="token keyword">return</span> newTab<span class="token punctuation">;</span><span class="token number">82</span> <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="HashMap扩容过程"><a href="#HashMap扩容过程" class="headerlink" title="HashMap扩容过程"></a>HashMap扩容过程</h3>扩容的时候，使用的是2次幂的扩展(指长度扩为原来2倍)，所以，元素的位置要么是在原位置，要么是在原位置再移动2次幂的位置。<br><img src="https://img-blog.csdnimg.cn/img_convert/96e3364cd31de8c7acd58eba62d739df.png" alt="在这里插入图片描述"></li><li>第一个是扩容前的key1和key2两种key确定索引位置的示例，</li><li>第二个是表示扩容后key1和key2两种key确定索引位置的示例，</li><li>其中hash1是key1对应的哈希与高位运算结果。</li><li>元素在重新计算hash之后，因为n变为2倍，那么n-1的mask范围在高位多1</li></ul><p>因此新的索引就会发生这样的变化：<br><img src="https://img-blog.csdnimg.cn/img_convert/0f244ba2da9810f8ed091f94cd418e8c.png" alt="在这里插入图片描述"></p><p>因此，在扩充HashMap的时候，只需要看看原来的hash值新增的那个bit是1还是0，<br>是0的话索引没变，是1的话索引变成“原索引+oldCap”</p><ul><li>这样省去了重新计算hash值的时间</li><li>而且新增的1位是0还是1可以认为是随机的，因此resize的过程，均匀的把之前的冲突的节点分散到新的bucket了。<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3></li><li>扩容是一个特别耗性能的操作，所以当程序员在使用HashMap的时候，估算map的大小，初始化的时候给一个大致的数值，避免map进行频繁的扩容。</li><li>装载因子是可以修改的，也可以大于1，但是建议不要轻易修改，0.75是一个比较好的折中数字</li><li>HashMap是线程不安全的，不要在并发的环境中同时操作HashMap</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HashMap </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java集合之HashMap(一)</title>
      <link href="/posts/48402.html"/>
      <url>/posts/48402.html</url>
      
        <content type="html"><![CDATA[<p>在讲HashMap之前，先说说Java中的集合框架</p><h2 id="Java-的集合框架"><a href="#Java-的集合框架" class="headerlink" title="Java 的集合框架"></a>Java 的集合框架</h2><p>Java 中集合主要分为java.util.Collection和java.util.Map两大接口<br><img src="https://img-blog.csdnimg.cn/img_convert/4fac0065e86e60ecbf2699e3b2f62f29.png" alt="在这里插入图片描述"></p><h2 id="List，Set，Map三者区别"><a href="#List，Set，Map三者区别" class="headerlink" title="List，Set，Map三者区别"></a>List，Set，Map三者区别</h2><ul><li>List：线性表，必须按照顺序保存元素，有序，允许重复；</li><li>Queue：队列，按照排队规则来确定对象产生的顺序，有序，允许重复；</li><li>Set：集合，一组可变数量的数据项，无序，不能重复</li><li>Map：使用键值对存储。Map会维护与Key有关联的值。两个Key可以引用相<br>同的对象，但Key不能重复， 典型的Key是String类型， 但也可以是任何对象。</li></ul><p>java.util.Map接口的实现可用于表示“键”（key）和“值”（value）对象之间的映射。一个映射表示一组“键”对象，其中每一个“键”对象都映射到一个“值”对象。因此可以通过键来查找值。</p><h2 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h2><h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><ul><li><p>Map是以键值对（key-value）的形式存储的对象之间的映射，key-value是以java.util.Map.Entry类型的对象实例存在。</p></li><li><p>Map可以使用键来查找值，一个映射中不能包含重复的键，但值是可以重复的。每个键最多只能映射到一个值。</p></li></ul><h3 id="HashMap-实现类"><a href="#HashMap-实现类" class="headerlink" title="HashMap 实现类"></a>HashMap 实现类</h3><p>HashMap是java.util.Map接口最常用的一个实现类，前面所学的HashSet底层就是通过HashMap来实现的，HashMap允许使用null键和null值。null作为键只能有一个</p><h3 id="HashMap的构造方法"><a href="#HashMap的构造方法" class="headerlink" title="HashMap的构造方法"></a>HashMap的构造方法</h3><ul><li><p>HashMap()：构造一个新的空映射；默认的初始容量为 16（最常用），负载系数为 0.75；</p></li><li><p>HashMap(int initialCapacity)：构造一个新的空映射； 具有指定的初始容量，负载系数为 0.75；</p></li><li><p>HashMap(int initialCapacity, float loadFactor)：构造一个新的空映射； 支持的 HashMap 实例具有指定的初始容量和指定的负载系数；</p></li><li><p>HashSet(Map&lt;? extends K, ? extends V&gt; m)：构造一个新映射，其中包含指定映射相同。</p></li></ul><h3 id="HashMap常用的成员方法"><a href="#HashMap常用的成员方法" class="headerlink" title="HashMap常用的成员方法"></a>HashMap常用的成员方法</h3><ul><li>void clear()：从该映射中删除所有映射；</li><li>Set&lt;Map, Entry&lt;K, V&gt;&gt; entrySet：返回此映射中包含的映射的集合；</li><li>V get(Object key)：返回指定键映射到的值，如果该映射不包含键的映射，则返回 null；</li><li>Set<K> keySet：返回此映射中包含的键的结合；</li><li>V put(K key, V value)：将指定值与此映射中指定键关联；</li><li>V remove(Object key)：如果存在，则从此映射中删除指定键的映射。</li><li>Collection<V> values：返回此映射中包含的集合。</li></ul><h2 id="HashMap数据结构"><a href="#HashMap数据结构" class="headerlink" title="HashMap数据结构"></a>HashMap数据结构</h2><h3 id="JDK1-8前"><a href="#JDK1-8前" class="headerlink" title="JDK1.8前"></a>JDK1.8前</h3><ul><li>HashMap 底层是数组和链表结合在一起使用也就是链表散列。</li><li>HashMap 通过key 的hashCode经过扰动函数处理过后得到hash值，然后通过(n - 1) &amp; hash判断当前元素存放的位置</li><li>所谓扰动函数指的就是HashMap 的hash 方法。使用hash 方法也就是扰动函数是为了防止一些实现<br>比较差的hashCode()方法</li><li>使用扰动函数之后可以减少碰撞<h3 id="拉链法"><a href="#拉链法" class="headerlink" title="拉链法"></a>拉链法</h3>将链表和数组相结合。也就是创建个链表数组，数组中每一格就是一个链表。若遇到哈希冲突，则将冲突的值加到链表后面</li></ul><p><img src="https://img-blog.csdnimg.cn/img_convert/611211a0e9004528a3813de546eb32f7.png" alt="在这里插入图片描述"></p><h3 id="JDK1-8后"><a href="#JDK1-8后" class="headerlink" title="JDK1.8后"></a>JDK1.8后</h3><ul><li>JDK1 .8之后在解决哈希冲突时有了很大的变化，当链表长度大于阈值(默认为8)时，将链表转化为红黑树，以减少搜索时间。</li><li>而链表长度小于6时，又会将红黑树转化成链表<br><img src="https://img-blog.csdnimg.cn/img_convert/46ceed32e8935bf794ea942e36ffef5f.png" alt="在这里插入图片描述"><h2 id="HashMap装载因子"><a href="#HashMap装载因子" class="headerlink" title="HashMap装载因子"></a>HashMap装载因子</h2><h4 id="装载因子为什么是0-75"><a href="#装载因子为什么是0-75" class="headerlink" title="装载因子为什么是0.75"></a>装载因子为什么是0.75</h4>提高空间利用率和 减少查询成本的折中，主要是泊松分布，0.75的话碰撞最小，</li></ul><p>HashMap有两个参数影响其性能：初始容量和装载因子。容量是哈希表中桶的数量，初始容量只是哈希表在创建时的容量。加载因子是哈希表在其容量自动扩容之前可以达到多满的一种度量。<br>当哈希表中的条目数超出了加载因子与当前容量的乘积时，则要对该哈希表进行扩容，扩容后的哈希表将具有两倍的原容量。</p><h4 id="过高过低会怎么样"><a href="#过高过低会怎么样" class="headerlink" title="过高过低会怎么样"></a>过高过低会怎么样</h4><ul><li><p>加载因子过高，例如为1，虽然减少了空间开销，提高了空间利用率，但同时也增加了查询时间成本；</p></li><li><p>加载因子过低，例如0.5，虽然可以减少查询时间成本，但是空间利用率很低，同时提高了rehash操作的次数。</p></li><li><p>选择0.75作为默认的加载因子，完全是时间和空间成本上寻求的一种折中选择</p></li></ul><p>在设置初始容量时应该考虑到映射中所需的条目数及其加载因子，以便最大限度地减少rehash操作次数，所以，一般在使用HashMap时建议根据预估值设置初始容量，减少扩容操作。</p><h2 id="HashMap的put方法"><a href="#HashMap的put方法" class="headerlink" title="HashMap的put方法"></a>HashMap的put方法</h2><p><img src="https://img-blog.csdnimg.cn/img_convert/9d28c63bc8e68d95b66aaefd15b0fee3.png" alt="在这里插入图片描述"></p><ol><li><p>判断HashMap的数组table[i]是否为空或为null，否则执行resize()进行扩容；</p></li><li><p>根据键值key计算hashcode得到插入的数组索引i，如果table[i]==null，直接新建节点添加，转向步骤6，如果table[i]不为空，转向步骤3；</p></li><li><p>判断table[i]的元素是否和key一样，如果相同直接覆盖value，否则转向④，这里的相同指的是hashCode以及equals；也就是完全相同</p></li><li><p>判断table[i] 是否为treeNode，即table[i] 是否是红黑树，如果是红黑树，则直接在树中插入键值对，否则转向步骤5；</p></li><li><p>遍历table[i]，判断链表长度是否大于8，大于8的话把链表转换为红黑树，在红黑树中执行插入操作，否则进行链表的插入操作；遍历过程中若发现key已经存在直接覆盖value；</p></li><li><p>插入成功后，判断实际存在的键值对数量size是否超过了最大容量threshold，如果超过，进行扩容。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HashMap </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分布式理论CAP和BASE</title>
      <link href="/posts/65138.html"/>
      <url>/posts/65138.html</url>
      
        <content type="html"><![CDATA[<h1 id="CAP理论"><a href="#CAP理论" class="headerlink" title="CAP理论"></a>CAP理论</h1><p>所谓CAP理论，就是分布式系统下的：</p><ul><li>一致性（C：Consistency）</li><li>可用性（A：Availability）</li><li>分区容忍性（P：Partition tolerance）</li></ul><h4 id="一致性（C：Consistency）"><a href="#一致性（C：Consistency）" class="headerlink" title="一致性（C：Consistency）"></a>一致性（C：Consistency）</h4><p>在分布式环境下，一致性是指数据在多个副本之间能否保持一致的特性。在一致性的需求下，当一个系统在数据一致的状态下执行更新操作后，应该保证系统的数据仍然处于一直的状态。</p><ul><li>对于将数据分布在不同分布式节点上的系统来说，如果对A节点的数据进行了更新操作，并且更新成功</li><li>却没有使得B节点上的数据得到同步的更新，对第二个节点的数据进行读取操作时，获取的是脏数据</li><li>这就是典型的分布式数据不一致的情况。</li><li>在分布式系统中，如果能够做到针对一个数据项的更新操作执行成功后，所有的用户都可以读取到其最新的值，那么这样的系统就被认为具有强一致性</li></ul><h4 id="可用性（A：Availability）"><a href="#可用性（A：Availability）" class="headerlink" title="可用性（A：Availability）"></a>可用性（A：Availability）</h4><p>可用性是指系统提供的服务必须一直处于可用的状态，对于用户的每一个操作请求总是能够在有限的时间内返回结果。关键是”有限时间内”和”返回结果”。例如银行系统</p><ul><li>“有限时间内”是一个操作请求，系统必须能够在指定的时间内返回对应的处理结果</li><li>如果超过了这个时间范围，那么系统就被认为是不可用的</li><li>“有限的时间内”是指系统设计之初就设计好的运行指标</li><li>对于用户请求，系统必须存在一个合理的响应时间</li></ul><p>“返回结果”是可用性的另一个非常重要的指标，它要求系统在完成对用户请求的处理后，返回一个正常的响应结果。正常的响应结果通常能够明确地反映出队请求的处理结果，即成功或失败，而不是一个让用户感到困惑的返回结果。</p><h4 id="分区容忍性（P：Partition-tolerance）"><a href="#分区容忍性（P：Partition-tolerance）" class="headerlink" title="分区容忍性（P：Partition tolerance）"></a>分区容忍性（P：Partition tolerance）</h4><p>分区容忍性约束了一个分布式系统具有如下特性：分布式系统在遇到任何网络分区故障的时候，仍然需要能够保证对外提供满足一致性和可用性的服务，除非是整个网络环境都发生了故障。</p><ul><li>网络分区是指在分布式系统中，不同的节点分布在不同的区域（机房或异地网络）中</li><li>由于一些特殊的原因导致这些网络之间无法连通，但各个网络的内部网络是正常的</li><li>从而导致整个系统的网络环境被切分成了若干个孤立的分区</li></ul><h2 id="如何取舍"><a href="#如何取舍" class="headerlink" title="如何取舍"></a>如何取舍</h2><p>一个分布式系统无法同时满足一致性、可用性、分区容忍性三个特点，所以我们就需要抛弃一样：</p><ul><li>CA：放弃分区容忍性，加强一致性和可用性，单机数据库</li><li>AP：放弃一致性（保证最终一致性），追求分区容忍性和可用性，大多数使用缓存的系统均采用这种方案</li><li>CP：放弃可用性，追求一致性和分区容忍性，很少系统会选择这种策略<h4 id="CA-without-P："><a href="#CA-without-P：" class="headerlink" title="CA without P："></a>CA without P：</h4></li><li>如果不要求P（不允许分区），则C（强一致性）和A（可用性）是可以保证的。</li><li>但放弃P的同时也就意味着放弃了系统的扩展性</li><li>此时的系统都不应该称为分布式系统，就是传统的单机数据库</li></ul><h4 id="CP-without-A："><a href="#CP-without-A：" class="headerlink" title="CP without A："></a>CP without A：</h4><ul><li>如果放弃可用性，相当于每个请求都需要在服务器之间保持强一致</li><li>而P（分区）会导致同步时间无限延长(也就是等待数据同步完才能正常访问服务)，</li><li>一旦发生网络故障或者消息丢失等情况，就要等待所有数据全部一致了之后再让用户访问系统</li><li>这种情况下用户体验会很差，很少系统会采用这种策略</li></ul><h4 id="AP-wihtout-C："><a href="#AP-wihtout-C：" class="headerlink" title="AP wihtout C："></a>AP wihtout C：</h4><ul><li>要保证系统的高可用，并且允许分区，则需要放弃一致性。一旦分区发生，节点之间可能会失去联系，数据就有可能不一致</li><li>为了高可用，每个节点只能用本地数据提供服务，而这样会导致全局数据的不一致性。</li><li>典型的应用就是电商抢购，你打开网页的时候，页面显示有库存的，当你下单的时候，系统提示你下单失败，商品已售完。</li><li>这其实就是先在 A（可用性）方面保证系统可以正常的服务，然后在数据的一致性方面做了些牺牲，但会保证最终一致性</li><li>这种场景下，用户体验可能不好，但可以保证系统的可用性，避免高并发下系统的崩溃</li></ul><h1 id="BASE理论"><a href="#BASE理论" class="headerlink" title="BASE理论"></a>BASE理论</h1><p>BASE是Basically Available（基本可用）、Soft state（软状态）和Eventually consistent（最终一致性）三个短语的单词首字母的缩写。</p><ul><li>Basically Available（基本可用）</li><li>Soft state（软状态）</li><li>Eventually consistent（最终一致性）</li></ul><p>BASE理论是对CAP中一致性和可用性权衡的结果，是大规模分布式系统实践的总结， 是基于CAP定理逐步演化而来的。<br>BASE理论的核心思想是：即使无法做到强一致性，但每个应用都可以根据自身业务特点，采用适当的方式来使系统达到最终一致性。</p><h4 id="Basically-Available（基本可用）"><a href="#Basically-Available（基本可用）" class="headerlink" title="Basically Available（基本可用）"></a>Basically Available（基本可用）</h4><p>基本可用是指分布式系统在出现不可预知故障的时候，允许损失部分可用性<br>部分可用性是指部分功能无法提供，响应时间变长</p><ul><li><p>响应时间变长。正常情况下，一个电商网站查询商品需要在0.5秒之内返回给用户相应的查询结果，但由于出现故障，查询结果的响应时间增加了1~2秒甚至更长</p></li><li><p>系统功能上的损失：正常情况下，一个电商网站上进行购物的时候，消费者几乎能够顺利完成每一笔订单，但由于系统用户购物高峰，为了保护电商系统的稳定性，部分用户可能会购物失败</p></li></ul><h4 id="Soft-state（软状态）"><a href="#Soft-state（软状态）" class="headerlink" title="Soft state（软状态）"></a>Soft state（软状态）</h4><p>软状态指允许系统中的数据存在中间状态，并认为该中间状态的存在不会影响系统的整体可用性，即允许系统在不同节点的数据副本之间进行数据同步的过程存在延时</p><h4 id="Eventually-consistent（最终一致性）"><a href="#Eventually-consistent（最终一致性）" class="headerlink" title="Eventually consistent（最终一致性）"></a>Eventually consistent（最终一致性）</h4><ul><li>最终一致性强调的是所有的数据副本，在经过一段时间的同步之后，最终都能够达到数据一致的状态</li><li>最终一致性的本质是需要系统保证最终数据能够达到一致，而不需要实时保证系统数据的强一致性</li><li>大部分使用缓存的系统都需要保存最终一致性<h2 id="BASE总结"><a href="#BASE总结" class="headerlink" title="BASE总结"></a>BASE总结</h2>BASE理论面向的是大型高可用可扩展的分布式系统，和传统的事物ACID特性是相反的，它完全不同于ACID的强一致性模型，而是通过牺牲强一致性来获得可用性，并允许数据在一段时间内是不一致的，但最终达到一致状态。<br>但在实际的分布式场景中，不同业务单元和组件对数据一致性的要求是不同的，因此在具体的分布式系统架构设计过程中，ACID特性和BASE理论往往又会结合在一起。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 分布式微服务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CAP </tag>
            
            <tag> BASE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring两大特性:IOC和AOP</title>
      <link href="/posts/9268.html"/>
      <url>/posts/9268.html</url>
      
        <content type="html"><![CDATA[<h1 id="IOC（Inverse-of-Control）控制反转"><a href="#IOC（Inverse-of-Control）控制反转" class="headerlink" title="IOC（Inverse of Control）控制反转"></a>IOC（Inverse of Control）控制反转</h1><p>说起控制反转，首先要了解一下软件设计的一个重要思想：依赖倒置</p><h2 id="依赖倒置原则"><a href="#依赖倒置原则" class="headerlink" title="依赖倒置原则"></a>依赖倒置原则</h2><p>假如现在要造一台手机，先设计处理器，然后根据处理器的规格设计主板，接着根据主板设计机身，最后根据机身设计好整个手机。<br>“依赖”关系：手机依赖机身，机身依赖主板，主板依赖处理器。</p><p><img src="https://img-blog.csdnimg.cn/20210720150809684.png" alt="在这里插入图片描述"><br>这种设计方案下，一旦有某个零部件需要调整规格，<br>比如处理器需要升级，那么主板是按照处理器设计的，就要修改主板规格，修改主板规格后，机身是按照主板设计的，所以机身也需要修改，那么整个设计方案都需要改动，非常麻烦；<br>如果将依赖倒置，就会是这样的：<br><img src="https://img-blog.csdnimg.cn/20210720151324299.png" alt="在这里插入图片描述"><br>我们先设计手机的轮廓，然后根据手机的轮廓来设计机身，根据机身来设计主板，最后根据主板来设计处理器。<br>依赖关系就反转过来了：处理器依赖主板， 主板依赖机身， 机身依赖手机。</p><h2 id="依赖注入"><a href="#依赖注入" class="headerlink" title="依赖注入"></a>依赖注入</h2><p>上层决定需要做什么，下层去实现这样的需求，但是上层并不用管下层是怎么实现的。这样就不会出现前面的“牵一发动全身”的情况。依赖注入（Dependency Injection），就是来实现控制反转的。所谓依赖注入，就是把底层类作为参数传入上层类，实现上层类对下层类的“控制”。</p><p>把有依赖关系的类放到容器中，解析出这些类的实例，就是依赖注入。目的是实现类的解耦。</p><h2 id="IOC容器"><a href="#IOC容器" class="headerlink" title="IOC容器"></a>IOC容器</h2><ul><li><p>IOC容器可以自动对你的类进行初始化，你只需要维护一个Configuration，而不用每次初始化一辆车都要亲手去写那一大段初始化的代码。</p></li><li><p>我们在创建实例的时候不需要了解其中的细节。</p></li><li><p>IoC容器实际上就是个Map (key, value) ， Map中存放的是各种对象。</p></li><li><p>将对象之间的相互依赖关系交给IoC 容器来管理，并由IoC 容器完成对象的注入。这样可以很大程度上简化应用的开发，把应用从复杂的依赖关系中解放出来。</p></li><li><p>IoC 容器就像是一个工厂一样，当我们需要创建一个对象的时候，只需要配置好配置文件/注解即可，完全不用考虑对象是如何被创建出来的。</p></li><li><p>在实际的开发过程中一个Service类可能有几百甚至上千个类作为它的底层，假如我们需要实例化这个Service,你可能要每次都要搞清这个Service所有底层类的构造函数，这可能会把人逼疯。如果利用IoC的话，你只需要配置好，然后在需要的地方引用就行了，这大大增加了项目的可维护性且降低了开发难度。</p></li><li><p>我们需要的控制反转（IoC），就是上层控制下层，而不是下层控制着上层</p></li><li><p>IoC是一种设计思想， 就是将原本在程序中手动创建对象的控制权，交由Spring框架中的IOC容器来管理 </p></li></ul><p><img src="https://img-blog.csdnimg.cn/2021072015195877.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Vwc3RyZWFtNDgw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>IOC的思想最核心的地方在于，资源不由使用资源的双方管理，而由不使用资源的第三方管理，这可以带来很多好处。</p><ul><li>资源集中管理，实现资源的可配置和易管理</li><li>降低了使用资源双方耦合度<h2 id="IOC初始化过程"><a href="#IOC初始化过程" class="headerlink" title="IOC初始化过程"></a>IOC初始化过程</h2><img src="https://img-blog.csdnimg.cn/20210720153933500.png" alt="在这里插入图片描述"></li></ul><h1 id="AOP-Aspect-Or-iented-Programming-面向切面编程"><a href="#AOP-Aspect-Or-iented-Programming-面向切面编程" class="headerlink" title="AOP(Aspect-Or iented Programming) 面向切面编程"></a>AOP(Aspect-Or iented Programming) 面向切面编程</h1><p>AOP能够将那些与业务无关，却为业务模块所共同调用的逻辑或责任(例如事务处理、日志管理、权限控制等)封装起来，便于减少系统的重复代码，降低模块间的耦合度，并有利于未来的可拓展性和可维护性。</p><p>Spring AOP就是基于动态代理的，如果要代理的对象，实现了某个接口，那么Spring AOP会使用JDK Proxy,去创建代理对象，而对于没有实现接口的对象，就无法使用JDK Proxy 去进行代理了，这时候Spring AOP会 使用Cglib，这时候Spring AOP会使用Cglib 生成一个被代理 对象的子类来作为代理，</p><p>使用AOP之后我们可以把一些通用功能抽象出来，在需要用到的地方直接使用即可，这样大大简化了代码量。我们需要增加新功能时也方便，这样也提高了系统扩展性。日志功能、事务管理等等场景都用到了AOP</p><h1 id="Spring中Bean的作用域"><a href="#Spring中Bean的作用域" class="headerlink" title="Spring中Bean的作用域"></a>Spring中Bean的作用域</h1><ul><li>singleton :唯一bean实例，Spring 中的bean 默认都是单例的</li><li>prototype :每次请求都会创建个新的 bean 实例</li><li>request :每次HTTP请求都会产生一个 新的bean,该bean仅在 当前HTTP request内有效</li><li>session :每一次HTTP请求都会产生一个新的bean, 该bean仅在当前HTTP session内有效</li><li>global -session:全 局session作用域，仅仅在基于portlet的web应用中才有意义，Spring5已经没有了</li><li>Portlet是 能够生成语义代码(例如: HTML) 片段的小型Java Web插件。它们基于</li><li>portlet容器，可以像servlet- 样处理HTTP请求。但是，与servlet 不同，每个portlet都有<br>不同的会话<h1 id="Spring中Bean的线程安全"><a href="#Spring中Bean的线程安全" class="headerlink" title="Spring中Bean的线程安全"></a>Spring中Bean的线程安全</h1>单例bean存在线程问题，主要是因为当多个线程操作同一个对象的时候，对这个对象的非静态成员变量的写操作会存在线程<h2 id="解决方法："><a href="#解决方法：" class="headerlink" title="解决方法："></a>解决方法：</h2></li><li>在Bean对象中尽量避免定义可变的成员变量</li><li>在类中定义一个ThreadLocal成员变量，将需要的可变成员变量保存在ThreadLocal中</li></ul>]]></content>
      
      
      <categories>
          
          <category> 框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> IOC </tag>
            
            <tag> AOP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何保证缓存与数据库的一致性？</title>
      <link href="/posts/24534.html"/>
      <url>/posts/24534.html</url>
      
        <content type="html"><![CDATA[<h2 id="常见的缓存更新策略"><a href="#常见的缓存更新策略" class="headerlink" title="常见的缓存更新策略"></a>常见的缓存更新策略</h2><ul><li>先更新缓存，再更新数据库</li><li>先更新数据库，再更新缓存</li><li>先删除缓存，再更新数据库</li><li>先更新数据库，再删除缓存</li><li>延时双删-更新数据库前后均删除缓存</li></ul><p>如果系统不存在并发情况，这些策略都没问题，但是一旦协同并发上来后，这些策略都有问题，具体采用那些策略，需要根据具体的业务分析</p><h2 id="先更新缓存，再更新数据库"><a href="#先更新缓存，再更新数据库" class="headerlink" title="先更新缓存，再更新数据库"></a>先更新缓存，再更新数据库</h2><p>这种策略一般不会使用，比如我们想象一种场景，我们先更新缓存，然后更新数据库，但是某些原因更新数据库失败了，那么肯定就会导致数据不一致。而且这个不一致，还会导致这次更新直接丢失了<br>因为大多数系统中，缓存是不会再写入数据库的，等到缓存失效，这次更新就彻底丢失了<br><img src="https://img-blog.csdnimg.cn/20210719154652512.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Vwc3RyZWFtNDgw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="先更新数据库，再更新缓存"><a href="#先更新数据库，再更新缓存" class="headerlink" title="先更新数据库，再更新缓存"></a>先更新数据库，再更新缓存</h2><p>这种缓存更新策略也被称为双写，会将脏数据更新到缓存中，想象一种场景，</p><ul><li>线程1更新数据库，数据库为1，但没来的及更新缓存</li><li>线程2也进来更新数据库，数据库为2</li><li>线程2速度比较快，马上更新了缓存，缓存为2</li><li>线程1更新缓存。缓存为1</li></ul><p>就导致数据库中的数据为线程2更新的，而缓存中的数据为线程1更新的，肯定不一致。</p><p><img src="https://img-blog.csdnimg.cn/20210719154157164.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Vwc3RyZWFtNDgw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="先删除缓存，再更新数据库"><a href="#先删除缓存，再更新数据库" class="headerlink" title="先删除缓存，再更新数据库"></a>先删除缓存，再更新数据库</h2><p>这种策略会导致请求的数据和实际数据库的数据不一致，如图，如果线程2再删除缓存和更新缓存操作之间发生了查询请求，那么请求到的数据就是旧数据，放入缓存的数据也为旧数据</p><ul><li>线程1要更新数据库，就会先删除缓存</li><li>线程2要查询数据，发现没有缓存</li><li>则线程2去查询数据库，此时得到的数据为1</li><li>线程2查询数据后，将数据写入缓存，缓存中数据为1</li><li>线程1更新数据库为2</li><li>缓存与数据库数据不一致<br><img src="https://img-blog.csdnimg.cn/20210719160019340.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Vwc3RyZWFtNDgw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>如果不给缓存设置过期时间，那么缓存中的数据会一直都有脏数据</li></ul><h2 id="先更新数据库，再删除缓存"><a href="#先更新数据库，再删除缓存" class="headerlink" title="先更新数据库，再删除缓存"></a>先更新数据库，再删除缓存</h2><p>这个策略是目前用的比较多的，但是在特定情况下还是会有一些问题，模拟场景</p><ul><li>缓存刚好到过期时间</li><li>线程1查询数据库为1</li><li>线程2更新数据库为2</li><li>线程2删除缓存</li><li>线程1更新缓存为1</li></ul><p><img src="https://img-blog.csdnimg.cn/20210719160908687.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Vwc3RyZWFtNDgw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ul><li>不过好在这种场景需要更新数据库的时间远远小于查询数据库的时间，</li><li>但实际上，查询数据库的操作远远快于写操作</li><li>所以这次情况发生的概率相对来说比较少</li></ul><h2 id="延时双删-更新数据库前后均删除缓存"><a href="#延时双删-更新数据库前后均删除缓存" class="headerlink" title="延时双删-更新数据库前后均删除缓存"></a>延时双删-更新数据库前后均删除缓存</h2><p>这种策略是比较推荐的策略，主要流程是</p><ul><li>更新数据库前，删除缓存</li><li>更新数据库</li><li>延时一定的时间，再删除缓存</li></ul><p>这种策略可以确保读请求结束，写请求可以删除读请求造成的脏数据</p>]]></content>
      
      
      <categories>
          
          <category> 缓存 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 一致性 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线程复用-线程池</title>
      <link href="/posts/27356.html"/>
      <url>/posts/27356.html</url>
      
        <content type="html"><![CDATA[<h2 id="线程池是什么"><a href="#线程池是什么" class="headerlink" title="线程池是什么"></a>线程池是什么</h2><ul><li><p>池化技术能够减少资源对象的创建次数，提高程序的响应性能，特别是在高并发下这种提高更加明显</p></li><li><p>线程池是一种多线程处理形式,处理过程中将任务添加到队列,然后在创建线程后自动启动这些任务</p><h2 id="为什么要用线程池"><a href="#为什么要用线程池" class="headerlink" title="为什么要用线程池"></a>为什么要用线程池</h2><p>主要是为了减少每次获取资源的消耗，提高对资源的利用率。线程池提供了一种限制和管理资源(包括执行一个任务)。每个线程池还维护一些基本统计信息，例如已完成任务的数量。</p></li><li><p>降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。</p></li><li><p>提高响应速度。当任务到达时，任务可以不需要的等到线程创建就能立即执行。</p></li><li><p>提高线程的可管理性。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系<br>统的稳定性，使用线程池可以进行统一的分配，调优和监控。</p></li></ul><h2 id="JDK源码中线程池参数的定义"><a href="#JDK源码中线程池参数的定义" class="headerlink" title="JDK源码中线程池参数的定义"></a>JDK源码中线程池参数的定义</h2><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/** * Creates a new &#123;@code ThreadPoolExecutor&#125; with the given initial * parameters. * * @param corePoolSize the number of threads to keep in the pool, even *        if they are idle, unless &#123;@code allowCoreThreadTimeOut&#125; is set * @param maximumPoolSize the maximum number of threads to allow in the *        pool * @param keepAliveTime when the number of threads is greater than *        the core, this is the maximum time that excess idle threads *        will wait for new tasks before terminating. * @param unit the time unit for the &#123;@code keepAliveTime&#125; argument * @param workQueue the queue to use for holding tasks before they are *        executed.  This queue will hold only the &#123;@code Runnable&#125; *        tasks submitted by the &#123;@code execute&#125; method. * @param threadFactory the factory to use when the executor *        creates a new thread * @param handler the handler to use when execution is blocked *        because the thread bounds and queue capacities are reached * /</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="corePoolSize：核心线程池数量"><a href="#corePoolSize：核心线程池数量" class="headerlink" title="corePoolSize：核心线程池数量"></a>corePoolSize：核心线程池数量</h4><p>线程池中一直保持的线程的数量，即使线程空闲。除非设置了 allowCoreThreadTimeOut</p><h4 id="maximumPoolSize：最大线程池数量"><a href="#maximumPoolSize：最大线程池数量" class="headerlink" title="maximumPoolSize：最大线程池数量"></a>maximumPoolSize：最大线程池数量</h4><p>指定线程池中允许的最大的线程数</p><h4 id="keepAliveTime：空闲线程存活时间"><a href="#keepAliveTime：空闲线程存活时间" class="headerlink" title="keepAliveTime：空闲线程存活时间"></a>keepAliveTime：空闲线程存活时间</h4><p>当线程数大于核心线程数的时候，超出核心线程数的线程在最大多长时间没有接到新任务就会终止释放 ，最终线程池维持在 corePoolSize 大小；<br>即超过corePoolSize的空闲线程，在多长时间内会被销毁</p><h4 id="unit：keepAliveTime的时间单位"><a href="#unit：keepAliveTime的时间单位" class="headerlink" title="unit：keepAliveTime的时间单位"></a>unit：keepAliveTime的时间单位</h4><h4 id="workQueue：阻塞队列"><a href="#workQueue：阻塞队列" class="headerlink" title="workQueue：阻塞队列"></a>workQueue：阻塞队列</h4><p>阻塞队列，用来存储等待执行的任务，如果当前对线程的需求超过了 corePoolSize大小， 就会放在这里 等待空闲线程执行.</p><h4 id="threadFactory：创建线程工厂"><a href="#threadFactory：创建线程工厂" class="headerlink" title="threadFactory：创建线程工厂"></a>threadFactory：创建线程工厂</h4><p>创建线程的工厂，比如指定线程名等，使用默认即可</p><h4 id="handler：拒绝策略"><a href="#handler：拒绝策略" class="headerlink" title="handler：拒绝策略"></a>handler：拒绝策略</h4><p>拒绝策略，如果当前任务太多来不及处理，线程池就会使用拒绝策略。</p><h4 id="JDK默认有以下拒绝策略"><a href="#JDK默认有以下拒绝策略" class="headerlink" title="JDK默认有以下拒绝策略"></a>JDK默认有以下拒绝策略</h4><ul><li>AbortPolicy策略:该策略会直接抛出异常，阻止系统正常工作。</li><li>CallerRunsPolicy 策略:只要线程池未关闭，该策略直接在调用者线程中，运行当前被<br>丟弃的任务。显然这样做不会真的丢弃任务，但是，任务提交线程的性能极有可能会急<br>剧下降。</li><li>DiscardOledestPolicy 策略:该策略将丢弃最老的一个请求，也就是即将被执行的一个任<br>务，并尝试再次提交当前任务。</li><li>DiscardPolicy策略:该策略默默地丟弃无法处理的任务，不予任何处理。如果允许任务<br>丢失，我觉得这可能是最好的一种方案了吧!</li></ul><h2 id="线程池使用Demo"><a href="#线程池使用Demo" class="headerlink" title="线程池使用Demo"></a>线程池使用Demo</h2><h3 id="使用ThreadPoolExecutor创建一个线程池"><a href="#使用ThreadPoolExecutor创建一个线程池" class="headerlink" title="使用ThreadPoolExecutor创建一个线程池"></a>使用ThreadPoolExecutor创建一个线程池</h3><p><img src="https://img-blog.csdnimg.cn/20210718095128177.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Vwc3RyZWFtNDgw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>RunnableTest实现Runnable接口<br><img src="https://img-blog.csdnimg.cn/20210718095142552.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Vwc3RyZWFtNDgw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>运行结果：<br><img src="https://img-blog.csdnimg.cn/20210718095243766.png" alt="在这里插入图片描述"></p><h2 id="运行流程"><a href="#运行流程" class="headerlink" title="运行流程"></a>运行流程</h2><h4 id="线程池运行流程"><a href="#线程池运行流程" class="headerlink" title="线程池运行流程"></a>线程池运行流程</h4><ol><li>初始化线程池，准备好 corePoolSize数量的核心线程，准备接受任务</li><li>新的任务进来，用 corePoolSize准备好的空闲线程执行。<br>(1) 、corePoolSize满了，就将再进来的任务放入阻塞队列中。空闲的 corePoolSize就会自己去阻塞队列获取任务执行<br>(2) 、阻塞队列满了，就直接开新线程执行，最大只能开到 max 指定的数量<br>(3) 、maximumPoolSize 都执行好了。maximumPoolSize 数量空闲的线程会在 keepAliveTime 指定的时间后自动销毁。最终保持到corePoolSize大小<br>(4) 、如果线程数开到了 maximumPoolSize 的数量，还有新任务进来，就会使用 handler指定的拒绝策略进行处理</li><li>所有的线程创建都是由指定的 threadFactory创建的。<br><img src="https://img-blog.csdnimg.cn/20210718090854523.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Vwc3RyZWFtNDgw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li></ol><h4 id="经典面试题："><a href="#经典面试题：" class="headerlink" title="经典面试题："></a>经典面试题：</h4><ul><li>题目：一个线程池 corePoolSize：10；maximumPoolSize：30；workQueue：50 ；100的 并发进来如何分配线程的</li><li>答案：先有 10 个线程进入核心线程池直接得到执行，接下来 50 个进入阻塞队列排队，在多开 20个线程达到最大线程池数量继续执行。现在已经有 80 个线程被安排上了。剩下 20 个线程使用拒绝策略。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线程池 </tag>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线程与进程</title>
      <link href="/posts/52642.html"/>
      <url>/posts/52642.html</url>
      
        <content type="html"><![CDATA[<h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><ul><li>是指计算机中已运行的程序，它是一个动态执行的过程。假设我们电脑上同时运行了浏览器、QQ 以及代码编辑器三个软件，这三个软件之所以同时运行，就是进程所起的作用。<br><img src="https://img-blog.csdnimg.cn/20210717164449702.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Vwc3RyZWFtNDgw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2></li><li>是操作系统能够进行运算调度的最小单位。大部分情况下，它被包含在进程之中，是进程中的实际运作单位。也就是说一个进程可以包含多个线程， 因此线程也被称为轻量级进程。<br><img src="https://img-blog.csdnimg.cn/20210717164530654.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Vwc3RyZWFtNDgw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><h2 id="线程的状态"><a href="#线程的状态" class="headerlink" title="线程的状态"></a>线程的状态</h2>线程从创建到最终的消亡，要经历若干个状态。一般来说，线程包括以下这几个状态：</li><li>创建(new)    新建状态，尚未启动的线程处于此状态；</li><li>就绪(runnable) 新建状态后，当前线程没有获得CPU时间片，等待CPU时间片轮转</li><li>运行(running) 可运行状态，Java 虚拟机中执行的线程处于此状态；</li><li>阻塞(blocked)  阻塞状态，等待监视器锁定而被阻塞的线程处于此状态；</li><li>等待(waiting)等待状态，无限期等待另一线程执行特定操作的线程处于此状态；</li><li>定时等待(time waiting)定时等待状态，在指定等待时间内等待另一线程执行操作的线程处于此状态；</li><li>消亡（dead）结束状态，已退出的线程处于此状态。</li></ul><h2 id="使用多线程可能遇到的问题"><a href="#使用多线程可能遇到的问题" class="headerlink" title="使用多线程可能遇到的问题"></a>使用多线程可能遇到的问题</h2><ul><li>并发编程的目的就是为了能提高程序的执行效率提高程序运行速度，但是并发编程并不总是能提高程序<br>运行速度的，而且并发编程可能会遇到很多问题，比如:内存泄漏、上下文切换、死锁还有受限于硬件<br>和软件的资源闲置问题。</li></ul><h2 id="初始化线程"><a href="#初始化线程" class="headerlink" title="初始化线程"></a>初始化线程</h2><p>在Java中初始化线程有四种方法</p><ul><li>继承 Thread 类，重写 run() 方法，该方法代表线程要执行的任务；</li><li>实现 Runnable 接口，实现 run() 方法，该方法代表线程要执行的任务；</li><li>实现 Callable 接口，实现 call() 方法，call() 方法作为线程的执行体，具有返回值，并且可以对异常进行声明和抛出。</li><li> 使用线程池<h3 id="继承Thread类"><a href="#继承Thread类" class="headerlink" title="继承Thread类"></a>继承Thread类</h3>Thread 类是一个线程类，位于 java.lang 包下。用于创建线程</li></ul><h4 id="Thread-类的构造方法"><a href="#Thread-类的构造方法" class="headerlink" title="Thread 类的构造方法"></a>Thread 类的构造方法</h4><ul><li>Thread()：创建一个线程对象；</li><li>Thread(String name)：创建一个指定名称的线程对象；</li><li>Thread(Runnable target)：创建一个基于 Runnable 接口实现类的线程对象；</li><li>Thread(Runnable target, String name)：创建一个基于 Runnable 接口实现类，并具有指定名称的线程对象。<h4 id="Thread-类的常用方法"><a href="#Thread-类的常用方法" class="headerlink" title="Thread 类的常用方法"></a>Thread 类的常用方法</h4></li><li>void run()：线程相关的代码写在该方法中，一般需要重写；</li><li>void start()：启动当前线程；</li><li>static void sleep(long m)：使当前线程休眠 m 毫秒；</li><li>void join()：优先执行调用 join() 方法的线程。</li></ul><p>run() 方法是一个非常重要的方法，它是用于编写线程执行体的方法</p><h4 id="继承Thread类创建线程"><a href="#继承Thread类创建线程" class="headerlink" title="继承Thread类创建线程"></a>继承Thread类创建线程</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/**    * 继承Thread类    */</span>   <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Thread01</span> <span class="token keyword">extends</span> <span class="token class-name">Thread</span><span class="token punctuation">&#123;</span>       <span class="token annotation punctuation">@Override</span>       <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>           <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"当前线程ID："</span><span class="token operator">+</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"运行结果："</span> <span class="token operator">+</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token punctuation">&#125;</span>   <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>main方法创建一个线程</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"线程-开始"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">Thread01</span> thread01 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread01</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>thread01<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"线程-结束"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行结果<br><img src="https://img-blog.csdnimg.cn/20210717163318105.png" alt="在这里插入图片描述"></p><h3 id="实现Runnable接口"><a href="#实现Runnable接口" class="headerlink" title="实现Runnable接口"></a>实现Runnable接口</h3><h4 id="使用Runnable接口的原因"><a href="#使用Runnable接口的原因" class="headerlink" title="使用Runnable接口的原因"></a>使用Runnable接口的原因</h4><ul><li>Java 不支持多继承，所有的类都只允许继承一个父类，可以认为继承也是一种资源；</li><li>但可以实现多个接口。如果继承了 Thread 类就无法继承其它类，这不利于扩展；</li><li>继承 Thread 类通常只重写 run() 方法，其他方法一般不会重写；</li><li>继承整个 Thread 类成本过高，开销过大。实现Runnable接口更轻量；</li></ul><h4 id="实现Runnable接口创建线程"><a href="#实现Runnable接口创建线程" class="headerlink" title="实现Runnable接口创建线程"></a>实现Runnable接口创建线程</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/** * 实现Runnable接口 */</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Runnable01</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span><span class="token punctuation">&#123;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"当前线程ID："</span><span class="token operator">+</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"运行结果："</span> <span class="token operator">+</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">*</span><span class="token number">10000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>main方法创建一个线程</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"线程-开始"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">Runnable01</span> runnable01 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Runnable01</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>runnable01<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"线程-结束"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行结果<br><img src="https://img-blog.csdnimg.cn/20210717164001866.png" alt="在这里插入图片描述"></p><h3 id="实现Callable接口-FutureTask-接口"><a href="#实现Callable接口-FutureTask-接口" class="headerlink" title="实现Callable接口 + FutureTask 接口"></a>实现Callable接口 + FutureTask 接口</h3><p>由于上述两种方式没有返回结果，JDK1.5后加入了Callable接口 + FutureTask 接口</p><h4 id="使用Callable接口和FutureTask接口的原因"><a href="#使用Callable接口和FutureTask接口的原因" class="headerlink" title="使用Callable接口和FutureTask接口的原因"></a>使用Callable接口和FutureTask接口的原因</h4><ul><li>继承 Thread 类和实现 Runnable 接口这两种创建线程的方式都没有返回值。</li><li>线程执行完毕后，无法得到执行结果。</li><li>为了解决这个问题，Java 5 后，提供了 Callable 接口和 Future 接口；</li><li>通过Callable接口和FutureTask接口，可以在线程执行结束后，返回执行结果。</li></ul><h4 id="实现Callable接口-FutureTask接口创建线程"><a href="#实现Callable接口-FutureTask接口创建线程" class="headerlink" title="实现Callable接口 + FutureTask接口创建线程"></a>实现Callable接口 + FutureTask接口创建线程</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/** * 实现Callable接口 + FutureTask (可以获取返回结果，处理异常) */</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Callable01</span> <span class="token keyword">implements</span> <span class="token class-name">Callable</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span><span class="token punctuation">&#123;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token class-name">Integer</span> <span class="token function">call</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"当前线程ID："</span><span class="token operator">+</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"运行结果："</span> <span class="token operator">+</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> result <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> result<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>main方法创建一个线程</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">ExecutionException</span><span class="token punctuation">,</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"线程-开始"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">FutureTask</span> futureTask <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FutureTask</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Callable01</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>futureTask<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//等待线程运行结束，获取返回值</span>    <span class="token class-name">Integer</span> integer <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Integer</span><span class="token punctuation">)</span> futureTask<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"线程-结束"</span><span class="token operator">+</span>integer<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行结果<br><img src="https://img-blog.csdnimg.cn/20210717164245946.png" alt="在这里插入图片描述"></p><h3 id="以上三种方式利弊分析"><a href="#以上三种方式利弊分析" class="headerlink" title="以上三种方式利弊分析"></a>以上三种方式利弊分析</h3><ul><li>继承Thread类和实现Runnalbe接口方式创建线程，主进程无法获取线程的运算结果。有些需要返回结果的场景无法使用</li><li>实现Callable接口 + FutureTask :主进程可以获取线程的运算结果，但是不利于控制服务器中的线程资源。</li><li>如果大量的线程创建，可能导致服务器资源耗尽，所以我们需要使用线程池；</li></ul><h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><h4 id="为什么要用线程池"><a href="#为什么要用线程池" class="headerlink" title="为什么要用线程池"></a>为什么要用线程池</h4><ul><li>降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。</li><li>提高响应速度。当任务到达时，任务可以不需要的等到线程创建就能立即执行。</li><li>提高线程的可管理性。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系<br>统的稳定性，使用线程池可以进行统一的分配， 调优和监控。</li><li>通过线程池性能稳定，也可以获取执行结果，并捕获异常。</li><li>但是，在业务复杂情况下，一个异步调用可能会依赖于另一个异步调用的执行结果。</li></ul><h4 id="创建线程池"><a href="#创建线程池" class="headerlink" title="创建线程池"></a>创建线程池</h4><p>《阿里巴巴Java开发手册》中强制线程池不允许使用Executors 去创建，而是通过ThreadPoolExecutor的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险</p><h5 id="方式一：Executors-newFixedThreadPool"><a href="#方式一：Executors-newFixedThreadPool" class="headerlink" title="方式一：Executors.newFixedThreadPool()"></a>方式一：Executors.newFixedThreadPool()</h5><p>使用ExecutorService 创建一个线程池</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//保证当前系统中线程池是有限个，每个异步任务，提交给线程池让他自己去执行</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">ExecutorService</span> service <span class="token operator">=</span> <span class="token class-name">Executors</span><span class="token punctuation">.</span><span class="token function">newFixedThreadPool</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>将线程放入线程池中</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Thread01</span> thread01 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread01</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>service<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span>thread01<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>运行结果<br><img src="https://img-blog.csdnimg.cn/20210717172736624.png" alt="在这里插入图片描述"></p><h5 id="方式二：new-ThreadPoolExecutor-）推荐"><a href="#方式二：new-ThreadPoolExecutor-）推荐" class="headerlink" title="方式二：new ThreadPoolExecutor(）推荐"></a>方式二：new ThreadPoolExecutor(）推荐</h5><p><img src="https://img-blog.csdnimg.cn/20210717182532571.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Vwc3RyZWFtNDgw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线程 </tag>
            
            <tag> 进程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何解决缓存穿透，缓存击穿，缓存雪崩</title>
      <link href="/posts/36907.html"/>
      <url>/posts/36907.html</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><p>在我们日常的开发中，都要数据库来进行数据的存储，当系统的用户量上来之后，系统需要承受大量的并发操作，特别是对数据库的操作，是主页访问量瞬间较大的时候，单一使用数据库来保存数据的系统会因为面向磁盘，磁盘读/写速度比较慢的问题而存在严重的性能弊端，一瞬间成千上万的请求到来，需要系统在极短的时间内完成成千上万次的读/写操作，这个时候往往不是数据库能够承受的，极其容易造成数据库系统瘫痪，最终导致服务宕机的严重生产问题。</p><p>为了克服这些高并发的问题，系统通常会引入缓存技术，将一些经常访问的热点数据放在缓存中，<br>由于缓存是基于内存的数据库，能够承载大量的并发请求，并且提供一定的持久化功能。</p><p>Redis非关系型数据库就是缓存技术中的一种<br><img src="https://img-blog.csdnimg.cn/20210620163655896.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Vwc3RyZWFtNDgw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="引入缓存后的系统架构图"><a href="#引入缓存后的系统架构图" class="headerlink" title="引入缓存后的系统架构图"></a>引入缓存后的系统架构图</h2><ul><li> 请求数据时，先去查看缓存中有没有需要的数据</li><li>如果缓存中有(缓存命中)，就直接返回</li><li>如果缓存中没有，就去请求数据库，并将结果缓存，然后返回<br><img src="https://img-blog.csdnimg.cn/20210620163550786.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Vwc3RyZWFtNDgw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li></ul><p>但是引入Redis缓存技术又有可能出现缓存穿透，缓存击穿，缓存雪崩等问题。</p><h2 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>缓存穿透是指请求一个一定不存在的数据，由于缓存中没有，系统就会去查询数据库，而数据库也没有，从数据库查不到数据则不写入缓存，这将导致这个不存在的数据每次请求都要到数据库去查询<br>恶意的攻击者可能利用这个这个漏洞，不断高并发的请求这个没有的数据，导致数据库无法承载，甚至宕机。<br><img src="https://img-blog.csdnimg.cn/20210620164855217.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Vwc3RyZWFtNDgw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><h4 id="空结果缓存"><a href="#空结果缓存" class="headerlink" title="空结果缓存"></a>空结果缓存</h4><ul><li>即使数据库中没有这个数据，系统也将这个这个结果进行缓存，并设置短暂的过期时间</li><li>当下一个请求进来是，就可以在缓存中名字这个数据，并将空结果返回</li><li>如果后续数据更新，这个数据存在数据库中了，由于外面设置了过期时间，缓存中很快就会有这个数据了</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token class-name">ResponseVo</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">List</span><span class="token punctuation">&lt;</span><span class="token class-name">CategoryVo</span><span class="token punctuation">></span><span class="token punctuation">></span></span> <span class="token function">selectAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">String</span> categoryJson <span class="token operator">=</span> stringRedisTemplate<span class="token punctuation">.</span><span class="token function">opsForValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"category"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//如果缓存中没有，查数据库</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token class-name">StringUtils</span><span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span>categoryJson<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">//查询数据库</span>            <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">CategoryVo</span><span class="token punctuation">></span></span> categoryVoList <span class="token operator">=</span> <span class="token function">selectAllFromDb</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token class-name">StringUtils</span><span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span>categoryVoList<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token comment">//库中没有此数据，存入一个空值,过期时间为5分钟,解决缓存穿透问题</span>                stringRedisTemplate<span class="token punctuation">.</span><span class="token function">opsForValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token string">"category"</span><span class="token punctuation">,</span><span class="token string">""</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span>MINUTES<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token keyword">return</span> <span class="token class-name">ResponseVo</span><span class="token punctuation">.</span><span class="token function">success</span><span class="token punctuation">(</span>categoryVoList<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">CategoryVo</span><span class="token punctuation">></span></span> categoryVoList <span class="token operator">=</span> gson<span class="token punctuation">.</span><span class="token function">fromJson</span><span class="token punctuation">(</span>categoryJson<span class="token punctuation">,</span><span class="token keyword">new</span> <span class="token class-name">TypeToken</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">List</span><span class="token punctuation">&lt;</span><span class="token class-name">CategoryVo</span><span class="token punctuation">></span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">.</span><span class="token function">getType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token class-name">ResponseVo</span><span class="token punctuation">.</span><span class="token function">success</span><span class="token punctuation">(</span>categoryVoList<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h2><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><ul><li>缓存雪崩是指在我们设置缓存默认采用了相同的过期时间，导致缓存在某一时刻全部失效</li><li>大量的请求全部转发到数据库，数据库的瞬时流量过大，导致数据库无法承载而宕机。</li></ul><h3 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案"></a>解决方案</h3><p>将数据放入缓存时，设置随机过期时间，避免缓存的数据同时失效<br><img src="https://img-blog.csdnimg.cn/20210620165929912.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Vwc3RyZWFtNDgw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h2><h3 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h3><ul><li>对于一些设置了过期时间的数据，在某些时间节点被超高并发地访问，是一种非常“热点”的数据。</li><li>这个时候，缓存数据突然过期，大量的请求高并发的查询数据库，导致数据库瞬时流量过大</li><li>这个和缓存雪崩的区别在于这里针对某一个数据缓存，而缓存雪崩是是很多很多数据同时失效。<h3 id="解决方案-2"><a href="#解决方案-2" class="headerlink" title="解决方案"></a>解决方案</h3></li><li>加锁，给查询数据库的操作加锁，大量的并发请求同时需要查询数据库，同时竞争一个锁</li><li>只有得到锁的请求，才能去查询数据库</li><li>当请求查询数据库后，将数据缓存，其他请求就可以命中缓存</li></ul><p><img src="https://img-blog.csdnimg.cn/20210620171324599.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Vwc3RyZWFtNDgw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="业务流程"><a href="#业务流程" class="headerlink" title="业务流程"></a>业务流程</h3><ul><li>先去缓存中判断缓存中有没有</li><li>没有就去查数据库，只有一个线程可以获得锁</li><li>查数据库，获得结果</li><li>将结果放入缓存</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">CategoryVo</span><span class="token punctuation">></span></span> <span class="token function">selectAllFromDb</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">//加本地锁，解决缓存击穿</span>        <span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Category</span><span class="token punctuation">></span></span> categories <span class="token operator">=</span> categoryMapper<span class="token punctuation">.</span><span class="token function">selectList</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">CategoryVo</span><span class="token punctuation">></span></span> categoryVoList <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token class-name">Category</span> category <span class="token operator">:</span> categories<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>category<span class="token punctuation">.</span><span class="token function">getParentId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token punctuation">(</span>ROOT_PARENT_ID<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                    <span class="token class-name">CategoryVo</span> categoryVo <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CategoryVo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token class-name">BeanUtils</span><span class="token punctuation">.</span><span class="token function">copyProperties</span><span class="token punctuation">(</span>category<span class="token punctuation">,</span>categoryVo<span class="token punctuation">)</span><span class="token punctuation">;</span>                    categoryVoList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>categoryVo<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>            <span class="token comment">//查询子目录</span>            <span class="token function">findSubCategory</span><span class="token punctuation">(</span>categoryVoList<span class="token punctuation">,</span>categories<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">//查到结果后将结果序列化，写入缓存，并设置一个随机的过期时间，解决缓存雪崩问题</span>            <span class="token comment">//生成5-15之间的一个随机数,设置缓存随机在5-15分钟内过期</span>            <span class="token class-name">Random</span> random <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Random</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> randomNum <span class="token operator">=</span> random<span class="token punctuation">.</span><span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">5</span><span class="token punctuation">;</span>            stringRedisTemplate<span class="token punctuation">.</span><span class="token function">opsForValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token string">"category"</span><span class="token punctuation">,</span>            gson<span class="token punctuation">.</span><span class="token function">toJson</span><span class="token punctuation">(</span>categoryVoList<span class="token punctuation">)</span><span class="token punctuation">,</span>randomNum<span class="token punctuation">,</span><span class="token class-name">TimeUnit</span><span class="token punctuation">.</span>MINUTES<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> categoryVoList<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="锁不住"><a href="#锁不住" class="headerlink" title="锁不住"></a>锁不住</h3><ul><li>这种情况其实是锁不住的，我们可以想象这样一种场景：</li><li>大量的请求都在竞争锁，只有一个线程获得了锁，去执行查询数据库的操作</li><li>其他线程被阻塞，待到锁释放，这些线程还是会一一竞争锁，去查询数据库</li><li>导致缓存并没有生效，所有我们应该再线程获得锁之后，再去缓存中判断</li><li>缓存中确实没有，我们才去查数据库<br><img src="https://img-blog.csdnimg.cn/20210620172126757.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Vwc3RyZWFtNDgw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>尽管把判断缓存，和查数据库都放在一个同步代码块中<br>仍然不能保证只查一次数据库，再来想象一种场景</li><li>当第一个竞争到锁的线程查询数据库完成，释放锁</li><li>还没来得及将结果放入缓存，第二个线程竞争到了锁</li><li>判断缓存中没有（第一个线程没来得及放入缓存）</li><li>第二个线程再查询了一次数据库，或者还有第三个，第四个</li><li>所有我们应该把放入缓存的操作都放在同一个同步代码块中</li><li>这样就可以保证只查了一次数据库<br><img src="https://img-blog.csdnimg.cn/20210620172655453.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Vwc3RyZWFtNDgw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2></li><li>以上只是业务较为简单的情况下的解决方案，而且使用synchronized会导致性能大幅下降</li></ul>]]></content>
      
      
      <categories>
          
          <category> 缓存 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
            <tag> 缓存高并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git之版本回退和分支合并</title>
      <link href="/posts/39129.html"/>
      <url>/posts/39129.html</url>
      
        <content type="html"><![CDATA[<h1 id="版本回退"><a href="#版本回退" class="headerlink" title="版本回退"></a>版本回退</h1><ul><li>有时候开发一个功能，发现思路不对，需要回退到某个版本。</li><li>使用git进行版本控制，就可以随意回退到任意版本</li><li>这种操作叫 回滚<h2 id="git-log"><a href="#git-log" class="headerlink" title="git -log"></a>git -log</h2></li><li>该命令显示从最近到最远的提交日志。</li><li>每一次提交都有对应的 commit id 和 commit message。</li><li>使用  –pretty=oneline 参数，显示更清晰<br><img src="https://img-blog.csdnimg.cn/20210616101619746.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Vwc3RyZWFtNDgw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li></ul><h2 id="git-reset-–hard-id"><a href="#git-reset-–hard-id" class="headerlink" title="git reset –hard id"></a>git reset –hard id</h2><ul><li>根据 id 回退到指定的版本；<br><img src="https://img-blog.csdnimg.cn/20210616101840932.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Vwc3RyZWFtNDgw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><h2 id="git-push-origin-HEAD-–force"><a href="#git-push-origin-HEAD-–force" class="headerlink" title="git push origin HEAD –force"></a>git push origin HEAD –force</h2></li><li>推送到远程仓库，让远程仓库和本地仓库保存版本一致<br><img src="https://img-blog.csdnimg.cn/20210616102154647.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Vwc3RyZWFtNDgw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210616102241485.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Vwc3RyZWFtNDgw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><h2 id="git-reflog"><a href="#git-reflog" class="headerlink" title="git -reflog"></a>git -reflog</h2></li><li>查看操作命令历史<br><img src="https://img-blog.csdnimg.cn/20210616102406978.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Vwc3RyZWFtNDgw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><h2 id="撤销操作"><a href="#撤销操作" class="headerlink" title="撤销操作"></a>撤销操作</h2></li><li>如果突然不想回退了，可以找到需要回退的Id</li><li>按照上面的方法，使用git reset –hard id命令</li><li>就可以又回到之前的版本了</li></ul><p><img src="https://img-blog.csdnimg.cn/20210616102823374.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Vwc3RyZWFtNDgw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/2021061610280945.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Vwc3RyZWFtNDgw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h1 id="合并分支"><a href="#合并分支" class="headerlink" title="合并分支"></a>合并分支</h1><h2 id="git-branch"><a href="#git-branch" class="headerlink" title="git branch"></a>git branch</h2><ul><li>列出你所有的分支、创建新分支、删除分支及重命名分支。<br><img src="https://img-blog.csdnimg.cn/20210616103444346.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Vwc3RyZWFtNDgw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li></ul><h2 id="git-checkout"><a href="#git-checkout" class="headerlink" title="git checkout"></a>git checkout</h2><ul><li>切换分支，或者检出内容到工作目录。</li></ul><p><img src="https://img-blog.csdnimg.cn/2021061610350565.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Vwc3RyZWFtNDgw,size_16,color_FFFFFF,t_70" alt="切换到master主分支"></p><h2 id="git-pull-origin-master"><a href="#git-pull-origin-master" class="headerlink" title="git pull origin master"></a>git pull origin master</h2><ul><li>建议每次操作前，都将远程代码pull下来<br><img src="https://img-blog.csdnimg.cn/2021061610363877.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Vwc3RyZWFtNDgw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li></ul><h2 id="git-merge-dev"><a href="#git-merge-dev" class="headerlink" title="git merge dev"></a>git merge dev</h2><ul><li>合并一个或者多个分支到你已经检出的分支中。 然后它将当前分支指针移动到合并结果上。</li><li>把dev分支的代码合并到master上</li><li>我这里已经是一致了的<br><img src="https://img-blog.csdnimg.cn/202106161039128.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Vwc3RyZWFtNDgw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li></ul>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 版本控制 </tag>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis基础</title>
      <link href="/posts/26216.html"/>
      <url>/posts/26216.html</url>
      
        <content type="html"><![CDATA[<h1 id="Redis介绍"><a href="#Redis介绍" class="headerlink" title="Redis介绍"></a>Redis介绍</h1><ul><li>Redis支持数据的持久化，可以将内存中的数据保存在磁盘中，重启的时候可以再次加载进行使用。</li><li>Redis不仅仅支持简单的key-value类型的数据，同时还提供list，set，zset，hash等数据结构的存储。</li><li>Redis支持数据的备份，即master-slave模式的数据备份。</li></ul><h1 id="Redis的数据结构"><a href="#Redis的数据结构" class="headerlink" title="Redis的数据结构"></a>Redis的数据结构</h1><h2 id="Redis有五种数据结构"><a href="#Redis有五种数据结构" class="headerlink" title="Redis有五种数据结构"></a>Redis有五种数据结构</h2><h4 id="字符串-String"><a href="#字符串-String" class="headerlink" title="字符串(String)"></a>字符串(String)</h4><ul><li>字符串类型是非常常见的一种类型，Redis中的字符串类型和很多编程语言里的字符串类型差不多，但相对要灵活些。<h4 id="字符串列表-list"><a href="#字符串列表-list" class="headerlink" title="字符串列表(list)"></a>字符串列表(list)</h4></li><li>列表可以看作是个双端队列，可以在列表两端推入和弹出元素。对列表的不同操作可以实现其他编程语言中的堆栈（同一端进出）和队列（一端进，另一端出）数据结构。</li></ul><h4 id="字符串集合-set"><a href="#字符串集合-set" class="headerlink" title="字符串集合(set)"></a>字符串集合(set)</h4><ul><li>set：集合最显著的特点应该就是其中的元素互不相同。用户可以快速对集合进行插入，删除，检查某元素是否在集合中的操作。此外，多个集合间也能很方便的执行交、并、差集运算。</li></ul><h4 id="哈希-hash"><a href="#哈希-hash" class="headerlink" title="哈希(hash)"></a>哈希(hash)</h4><ul><li>hash：Redis中的散列可以让用户将多个键值对存储到一个Redis键中，可以把这种数据聚集看作是关系数据库中的行，或者文档数据库中的文档。</li></ul><h4 id="有序字符串集合-sorted-set"><a href="#有序字符串集合-sorted-set" class="headerlink" title="有序字符串集合(sorted set)"></a>有序字符串集合(sorted set)</h4><ul><li>zset：有序集合存储着成员与分值（权值，在Redis中以IEEE 754双精度浮点数的格式存储）之间的映射，并且提供了分值处理命令。适用于按照权值获取元素的情况。如热门帖子获取、基于投票数排序文章等。</li></ul><h1 id="Redis常用命令"><a href="#Redis常用命令" class="headerlink" title="Redis常用命令"></a>Redis常用命令</h1><h3 id="字符串-String-1"><a href="#字符串-String-1" class="headerlink" title="字符串(String)"></a>字符串(String)</h3><ul><li>set key value             # 设置key对应的值为string类型的value</li><li>get key                         # 获取指定key的value值</li><li>del key                       # 删除指定key的值</li><li>getset key  value         #先获取key的值，再设置key的值为value</li><li>incr key                        #对key的值做自增操作，返回新的值</li><li>decr key                    #对key的值做自减操作，返回新的值</li><li>incrby key integer        #对key的value增加指定数值</li><li>decrby key integer    #对key的value减指定数值</li><li>append key value        #给指定key的字符串追加数值</li></ul><h3 id="哈希-hash-1"><a href="#哈希-hash-1" class="headerlink" title="哈希(hash)"></a>哈希(hash)</h3><p>String Key和String Value的map容器</p><ul><li>hset key field value    向散列key中添加一个键值对</li><li>hget key field    获取散列key中的一个键的值</li><li>hmset key field1 value1 [field2 value2 …]    向散列key中添加一个或多个键值对</li><li>hmget key field1 [field2 … ]    获取散列key中的一个或多个键的值</li><li>hdel key field1 [field2 … ]    删除散列中的一个或多个键值对，返回成功删除的键值对数量</li><li>hlen key    返回散列包含的键值对数量</li><li>hincrby key field integer    给散列中指定field的值加上integer</li><li>hexists key field    测试指定field是否在散列中存在</li><li>hkeys key    返回散列中所有field</li><li>hvals key    返回散列中所有value</li><li>hgetall key    返回散列中所有键值对</li></ul><h3 id="字符串列表-list-1"><a href="#字符串列表-list-1" class="headerlink" title="字符串列表(list)"></a>字符串列表(list)</h3><h4 id="类似数据结构中的链表，有以下三种存储方式"><a href="#类似数据结构中的链表，有以下三种存储方式" class="headerlink" title="类似数据结构中的链表，有以下三种存储方式"></a>类似数据结构中的链表，有以下三种存储方式</h4><ul><li>ArrayList使用数组方式存储</li><li>LinkedList使用双向链接方式</li><li>双向链表中增加数据</li><li>双向链表中删除数据</li></ul><h4 id="常用list命令"><a href="#常用list命令" class="headerlink" title="常用list命令"></a>常用list命令</h4><ul><li>lpush key value1 [value2…]    在key对应的list的头部（左端）添加元素</li><li>rpush key value1 [value2…]    在key对应的list的尾部（右端）添加元素</li><li>lpop key    移除并返回key对应的list的头部（左端）元素</li><li>rpop key    移除并返回key对应的list的尾部（右端）元素</li><li>lindex key offset    返回列表中偏移量为offset的元素</li><li>lrange key start end (0代表第一个元素，-1代表最后一个元素)    返回列表中从start偏移量到end偏移量中的元素，包含两个端点元素（只返回，原list不变）</li><li>ltrim key start end    对列表进行修剪，只保留从start偏移量到end偏移量的元素，包含两个端点</li><li>llen key    返回对应列表的长度</li></ul><h4 id="其他命令"><a href="#其他命令" class="headerlink" title="其他命令"></a>其他命令</h4><ul><li>blpop key1 [key2…] timeout    从第一个非空列表中弹出位于头部（左端）的元素，或者在timeout秒内阻塞并等待可弹出元素的出现</li><li>brpop key1 [key2…] timeout    从第一个非空列表中弹出位于尾部（右端）的元素，或者在timeout秒内阻塞并等待可弹出元素的出现</li><li>rpoplpush source-key dest-key    从source-key列表中弹出位于最右端的元素，然后把这个元素插入dest-key列表的最左端，并向用户返回该元素</li><li>brpoplpush source-key dest-key timeout    从source-key列表中弹出位于最右端的元素，然后把这个元素插入dest-key列表的最左端，并向用户返回该元素。如果source-key为空，则在timeout秒内阻塞并等待可弹出元素的出现</li></ul><h3 id="字符串集合-set-1"><a href="#字符串集合-set-1" class="headerlink" title="字符串集合(set)"></a>字符串集合(set)</h3><h4 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h4><ul><li>sadd key value1 [value2…]    将一个或多个元素添加到集合中，并返回添加成功的元素的个数</li><li>srem key value1 [value2…]    从集合中移除一个或多个元素，返回移除成功的元素的个数</li><li>sismember key value    检查元素value是否在集合key中，存在返回1，不存在返回0</li><li>scard key    返回集合包含的元素个数</li><li>smembers key    返回集合包含的全部元素</li><li>srandmember key [count]    随机返回集合中的一个或多个元素。当count为正数时，返回的元素不会重复；当count为负数时，返回的元素有可能会重复</li><li>spop key    随机移除集合中的某个元素，被返回给用户</li><li>smove source-key des-key value    如果集合source-key中包含元素value，则移除它，并添加到dest-key中；成功移除并添加则返回1，否则返回0</li></ul><h4 id="其他命令-1"><a href="#其他命令-1" class="headerlink" title="其他命令"></a>其他命令</h4><ul><li>sdiff key1 [key2…]    返回所有集合的差集</li><li>sdiffstore dest-key key1 [key2…]    将计算所得的差集中的元素添加到dest-key中</li><li>sinter key1 [key2…]    返回所有集合的交集</li><li>sinterstore dest-key key1 [key2…]    将计算所得的交集中的元素添加到dest-key中</li><li>sunion key1 [key2…]    返回所有集合的并集</li><li>sunionstore dest-key key1 [key2…]    将计算所得的并集中的元素添加到dest-key中</li></ul><h3 id="有序字符串集合-sorted-set-1"><a href="#有序字符串集合-sorted-set-1" class="headerlink" title="有序字符串集合(sorted set)"></a>有序字符串集合(sorted set)</h3><ul><li>zadd key score1 member1 [score2 member2 … ]    将带有给定分值的成员你添加到有序集合中。注意分值在前，成员在后</li><li>zrem key member1 [member2 … ]    从有序集合中删除指定成员，并返回成功删除的元素个数</li><li>zcard key    返回有序集合包含的成员个数</li><li>zincrby key increment member    给指定成员的分值加上increment</li><li>zcount key min max    返回分值介于min和max之间的成员数量</li><li>zrank key memeber    返回指定成员在有序集合中的排名，成员按照score从小到大排序</li><li>zrevrank key memeber    返回指定成员在有序集合中的排名 ，成员按照score从大到小排序</li><li>zscore key member    返回指定成员的分值</li><li>zrange key start stop [WITHSCORES]    返回有序集合中排名介于start和stop之间的成员，如果给定了可选的 WITHSCORES选项，则连带成员分值一并返回</li><li>zrevrange key start stop [WITHSCORES]    同上，结果按score逆序</li><li>zrangebyscore key min max [WITHSCORES]    返回分值介于min和max之间的成员</li><li>zremrangebyrank key start stop    删除集合中排名在start和stop之间的成员</li><li>zremrangebyscore key min max    删除集合中分值在min和max之间的成员</li></ul><h3 id="key的相关命令"><a href="#key的相关命令" class="headerlink" title="key的相关命令"></a>key的相关命令</h3><h4 id="Key定义注意点"><a href="#Key定义注意点" class="headerlink" title="Key定义注意点"></a>Key定义注意点</h4><ul><li>不要过长</li><li>不要过短</li><li>在项目中应该遵循统一的命名规范</li></ul><h4 id="常用命令-1"><a href="#常用命令-1" class="headerlink" title="常用命令"></a>常用命令</h4><ul><li>exists key    测试指定key是否存在</li><li>del key1 [key2 …]    删除给定key</li><li>type key    返回给定key的类型</li><li>keys pattern    以正则表达式的形式，返回匹配的所有key </li><li>keys *(返回所有key)</li><li>rename oldkey newkey    修改key的名字</li><li>dbsize    查看数据库中key的数量（并不是所谓的大小）</li><li>expire key seconds    为key指定过期时间，到期自动删除</li><li>ttl key    查看key的剩余时间</li><li>select index    选择数据库（默认16个数据库，index为0-15）</li><li>move key index    将key移动到指定数据库</li><li>flushdb    清空当前数据库key</li><li>flushall    清空所有数据库key</li></ul><h1 id="Redis的事务"><a href="#Redis的事务" class="headerlink" title="Redis的事务"></a>Redis的事务</h1><h4 id="Redis-事务可以一次执行多个命令，-并且带有以下三个重要的保证："><a href="#Redis-事务可以一次执行多个命令，-并且带有以下三个重要的保证：" class="headerlink" title="Redis 事务可以一次执行多个命令， 并且带有以下三个重要的保证："></a>Redis 事务可以一次执行多个命令， 并且带有以下三个重要的保证：</h4><ul><li>批量操作在发送 EXEC 命令前被放入队列缓存。</li><li>收到 EXEC 命令后进入事务执行，事务中任意命令执行失败，其余的命令依然被执行。</li><li>在事务执行过程，其他客户端提交的命令请求不会插入到事务执行命令序列中。</li></ul><h4 id="一个事务从开始到执行会经历以下三个阶段："><a href="#一个事务从开始到执行会经历以下三个阶段：" class="headerlink" title="一个事务从开始到执行会经历以下三个阶段："></a>一个事务从开始到执行会经历以下三个阶段：</h4><ul><li>开始事务。</li><li>命令入队。</li><li>执行事务。</li></ul><h2 id="事务的常用命令"><a href="#事务的常用命令" class="headerlink" title="事务的常用命令"></a>事务的常用命令</h2><ul><li>discard 取消事务，放弃执行事务块内的所有命令。</li><li>exec 执行所有事务块内的命令。</li><li>multi 标记一个事务块的开始。</li><li>umwatch 取消 WATCH 命令对所有 key 的监视。</li><li>watch key [key …]<br>监视一个(或多个) key ，如果在事务执行之前这个(或这些) key 被其他命令所改动，那么事务将被打断。</li></ul><h1 id="Redis的持久化-数据从内存同步到硬盘"><a href="#Redis的持久化-数据从内存同步到硬盘" class="headerlink" title="Redis的持久化-数据从内存同步到硬盘"></a>Redis的持久化-数据从内存同步到硬盘</h1><h2 id="两种持久化方式："><a href="#两种持久化方式：" class="headerlink" title="两种持久化方式："></a>两种持久化方式：</h2><ul><li>RDB方式</li><li>AOF方式</li></ul><h2 id="持久化使用的方式："><a href="#持久化使用的方式：" class="headerlink" title="持久化使用的方式："></a>持久化使用的方式：</h2><ul><li>RDB方式：<br>默认支持，在指定的时间间隔内，将内存中的数据集快照写入到磁盘</li><li>AOF方式：<br>日志的形式记录服务器处理的每一个操作，服务器启动之初，读取文件，重新构建数据库</li><li>无持久化：<br>通过配置继用Redis持久化功能，Redis缓存机制</li><li>同时使用RDB和AOF</li></ul><h2 id="RDB方式的持久化"><a href="#RDB方式的持久化" class="headerlink" title="RDB方式的持久化"></a>RDB方式的持久化</h2><h4 id="优势："><a href="#优势：" class="headerlink" title="优势："></a>优势：</h4><ul><li>数据库只包含一个文件，通过文件备份策略，定期配置，恢复系统灾难</li><li>压缩文件转移到其他介质上</li><li>性能最大化，redis开始持久化时，分叉出进程，由子进程完成持久化的工作<br>，避免服务器进程执行I/O操作，启动效率高</li></ul><h4 id="劣势："><a href="#劣势：" class="headerlink" title="劣势："></a>劣势：</h4><ul><li>无法高可用：系统一定在定时持久化之前宕机，数据还没写入，数据已经丢失</li><li>通过fock分叉子进程完成工作，数据集大的时候，服务器需要停止几百毫秒甚至1秒</li></ul><h4 id="默认配置配置：查看redis-conf配置文件"><a href="#默认配置配置：查看redis-conf配置文件" class="headerlink" title="默认配置配置：查看redis.conf配置文件"></a>默认配置配置：查看redis.conf配置文件</h4><ul><li>save 900 1 #每900秒至少1个key变化，持久化一次，到内存一个快照</li><li>save 300 10 #每300秒至少10个key变化，往硬盘写一次</li><li>save 60 10000 #每60秒至少10000个key变化，写一次</li><li>dbfilename dump.rdb #数据的文件名</li><li>dir ./ #保存的路径，redis路径下</li></ul><h2 id="AOF持久化方式"><a href="#AOF持久化方式" class="headerlink" title="AOF持久化方式"></a>AOF持久化方式</h2><h4 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h4><ul><li>同步写入频率高</li><li>不破坏写入日志数据</li><li>当数据过大，可启动修改重写机制，保证修改数据的更新</li><li>日志文件格式清晰，便于重建数据</li></ul><h4 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h4><ul><li>效率低</li><li>文件偏大于rdb文件</li></ul><h4 id="配置过程："><a href="#配置过程：" class="headerlink" title="配置过程："></a>配置过程：</h4><ul><li>编辑redis.conf配置文件</li><li>找到 appendonly no 修改为 yes</li></ul>]]></content>
      
      
      <categories>
          
          <category> 缓存 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>外教资源供需平台项目设计</title>
      <link href="/posts/28350.html"/>
      <url>/posts/28350.html</url>
      
        <content type="html"><![CDATA[<h1 id="外教资源供需平台项目设计"><a href="#外教资源供需平台项目设计" class="headerlink" title="外教资源供需平台项目设计"></a>外教资源供需平台项目设计</h1><h2 id="项目摘要"><a href="#项目摘要" class="headerlink" title="项目摘要"></a>项目摘要</h2><ul><li>据统计,目前在上海市长期期工作的外籍人员达3.7万余人,主要来自美国、日本、韩国、徳国、澳大利亚等国家,取得学士学位占95%以上,主要从事信息、计算机、教育、咨洵、科学研究和综合技术服务工作。</li><li>现在上海有很多外国人，可以提供外语家教、展会模特、翻译。本课题的目标建立-一个微信小程序，在上海的外国人可以登录并发布自己的信息，如哪个国家的、母语是什么，什么时间有空、在上海哪个区、可以提供什么服务等。中国人通过这个平台，可以查找自己需要的外国人资源，也可以发布招聘外教的信息。</li><li>项目目的是通过设计一个微信小程序，建立外语教学方面的外教资源联系。连接所有需要外教服务和提供外教服务的用户，让这些人群拥有一个交流的平台。使用当下流行的微信小程序进行设计开发</li></ul><h2 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h2><h3 id="技术可行性"><a href="#技术可行性" class="headerlink" title="技术可行性"></a>技术可行性</h3><h4 id="Java简介"><a href="#Java简介" class="headerlink" title="Java简介"></a>Java简介</h4><ul><li>Java是一种可以撰写跨平台应用软件的面向对象的程序设计语言。Java 技术具有卓越的通用性、高效性、平台移植性和安全性，广泛应用于PC、数据中心、游戏控制台、科学超级计算机、移动电话和互联网，同时拥有全球最大的开发者专业社群。Java作为一门精准的语言，可以使开发者规范自己的程序结构,防止出现结构混乱的情况。同时，其内存回收站可以有效回收内存，防止程序浪费资源，影响机器性能。<h4 id="SpringBoot简介"><a href="#SpringBoot简介" class="headerlink" title="SpringBoot简介"></a>SpringBoot简介</h4></li><li>SpringBoot是由Pivotal团队在2013年开始研发、2014年4月发布第一个版本的全新开源的轻量级框架。它基于Spring4.0设计，不仅继承了Spring框架原有的优秀特性，而且还通过简化配置来进一步简化了Spring应用的整个搭建和开发过程。另外SpringBoot通过集成大量的框架使得依赖包的版本冲突，以及引用的不稳定性等问题得到了很好的解决。</li></ul><h4 id="Mybatis简介"><a href="#Mybatis简介" class="headerlink" title="Mybatis简介"></a>Mybatis简介</h4><ul><li>MyBatis 是一款优秀的持久层框架，它支持自定义 SQL、存储过程以及高级映射。MyBatis 免除了几乎所有的 JDBC 代码以及设置参数和获取结果集的工作。MyBatis 可以通过简单的 XML 或注解来配置和映射原始类型、接口和 Java POJO（Plain Old Java Objects，普通老式 Java 对象）为数据库中的记录。<h4 id="MySQL简介"><a href="#MySQL简介" class="headerlink" title="MySQL简介"></a>MySQL简介</h4></li><li>MySQL是最流行的关系型数据库管理系统，在WEB应用方面MySQL是最好的RDBMS<br> (Relational Database Management System,关系数据库管理系统)应用软件之一。MySQL是一种关联数据库管理系统，具有极高的灵活性。MySQL 所使用的SQL语言是用于访问数据库的最常用标准化语言。MySQL体积小、速度快、总体拥有成本低，尤其是开放源码这一特点，-般中小型网站的开发都选择MySQL作为网站数据库。<h4 id="微信小程序"><a href="#微信小程序" class="headerlink" title="微信小程序"></a>微信小程序</h4></li><li>微信小程序是一种全新的连接用户与服务的方式，它可以在微信内被便捷地获取和传播，同时具有出色的使用体验</li></ul><h3 id="功能需求"><a href="#功能需求" class="headerlink" title="功能需求"></a>功能需求</h3><ol><li>用户按照身份进行登录，展示不同的界面和不同的功能，如用户登录可以看到外教的信息，外教登录可以看到用户的招聘信息。</li><li>中国人的用户可以发布招聘信息，可以看到外教信息，如照片，国家、语言、所在区域，授课时间等。可以选择其中的外教，可通过电话联系，可免费预约试听。</li><li>外教可以发布自己可以提供的服务，展示自己的信息，如照片，国家、语言、所在区域，授课时间等。</li><li>用户可以编辑自己的个人信息，发布招聘内容和发布外教服务；管理自己的发布内容，管理自己的预约情况，修改密码等常用的用户管理功能。</li></ol><h2 id="技术选型与架构"><a href="#技术选型与架构" class="headerlink" title="技术选型与架构"></a>技术选型与架构</h2><ul><li>Java版本：1.8</li><li>数据库：MySQL</li><li>框架：SpringBoot + MyBatis</li><li>服务器：Tomcat</li><li>前端：微信小程序</li><li>开发工具：Idea 2020，微信开发者工具</li><li>版本管理工具：Maven</li><li>版本控制工具：GitHub</li><li>其他工具：Navicat</li></ul><h2 id="总体设计"><a href="#总体设计" class="headerlink" title="总体设计"></a>总体设计</h2><p><img src="https://img-blog.csdnimg.cn/2021020313571184.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Vwc3RyZWFtNDgw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="系统整体结构图"><a href="#系统整体结构图" class="headerlink" title="系统整体结构图"></a>系统整体结构图</h3><p><img src="https://img-blog.csdnimg.cn/20210203135627639.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Vwc3RyZWFtNDgw,size_16,color_FFFFFF,t_70"></p><h3 id="系统架构"><a href="#系统架构" class="headerlink" title="系统架构"></a>系统架构</h3><p><img src="https://img-blog.csdnimg.cn/20210203135725113.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Vwc3RyZWFtNDgw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="关系模式设计"><a href="#关系模式设计" class="headerlink" title="关系模式设计"></a>关系模式设计</h2><h3 id="数据库E-R图"><a href="#数据库E-R图" class="headerlink" title="数据库E-R图"></a>数据库E-R图</h3><p><img src="https://img-blog.csdnimg.cn/2021020314015669.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Vwc3RyZWFtNDgw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="数据库关系模型"><a href="#数据库关系模型" class="headerlink" title="数据库关系模型"></a>数据库关系模型</h3><ul><li>用户(用户ID，姓名，年龄，性别，地址，电话，国籍，语言，类型)</li><li>主键：用户ID</li></ul><ul><li>招聘(招聘ID，用户ID，时间，地点，需求，电话，内容)</li><li>主键：招聘ID，外键：用户ID</li></ul><ul><li>外教(外教ID，用户ID，时间，地点，服务，电话，内容)</li><li>主键：外教ID，外键：用户ID</li></ul><h3 id="数据库表设计"><a href="#数据库表设计" class="headerlink" title="数据库表设计"></a>数据库表设计</h3><p><img src="https://img-blog.csdnimg.cn/20210203141255494.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Vwc3RyZWFtNDgw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210203141310211.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Vwc3RyZWFtNDgw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210203141327230.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Vwc3RyZWFtNDgw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="系统各功能实现"><a href="#系统各功能实现" class="headerlink" title="系统各功能实现"></a>系统各功能实现</h2><h3 id="登录功能"><a href="#登录功能" class="headerlink" title="登录功能"></a>登录功能</h3><ul><li>打开小程序，进入登录界面，输入账号和密码，点击登录，系统会判断用户的账号和密码，已经用户的身份，根据用户的身份进入不同的页面。小程序会访问后端服务器的一个登录接口，将账号和密码打包送往服务器进行验证，验证成功返回该用户的信息，验证失败则显示账号密码错误或者账号未注册。<br><img src="https://img-blog.csdnimg.cn/20210203141358229.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Vwc3RyZWFtNDgw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li></ul><h3 id="用户招聘列表"><a href="#用户招聘列表" class="headerlink" title="用户招聘列表"></a>用户招聘列表</h3><ul><li>小程序第一页，用户发布的招聘。打开进入小程序，即可看到所有的用户发布的招聘信息，点击其中一个即可进入页面查看详细的招聘描述，点击下方的电话预约按钮即可拨打电话与外教联系，预约试听。<br><img src="https://img-blog.csdnimg.cn/20210203141432633.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Vwc3RyZWFtNDgw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li></ul><h3 id="外教服务列表"><a href="#外教服务列表" class="headerlink" title="外教服务列表"></a>外教服务列表</h3><ul><li>外教服务列表位于小程序中间的导航栏，点击即可显示所有外教发布的可提供外教服务的服务信息，选择其中一个，点击进入即可查看详细的外教服务内容，点击下方的电话预约即可预约相应的外教，申请试听。<br><img src="https://img-blog.csdnimg.cn/20210203141635358.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Vwc3RyZWFtNDgw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li></ul><h3 id="拨打电话预约"><a href="#拨打电话预约" class="headerlink" title="拨打电话预约"></a>拨打电话预约</h3><ul><li>调用拨打电话的接口，拨打用户发布招聘中预留的电话，或者外教发布的服务预留的电话，与对方联系具体的情况和预约试听。<br><img src="https://img-blog.csdnimg.cn/20210203141657371.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Vwc3RyZWFtNDgw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li></ul><h3 id="查看和编辑用户个人信息"><a href="#查看和编辑用户个人信息" class="headerlink" title="查看和编辑用户个人信息"></a>查看和编辑用户个人信息</h3><ul><li>在导航栏“我的”中，点击信息维护即可查看个人的所有信息，点击编辑信息即可修改个人的所有信息。<br><img src="https://img-blog.csdnimg.cn/20210203141724215.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Vwc3RyZWFtNDgw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li></ul><h3 id="发布招聘-服务"><a href="#发布招聘-服务" class="headerlink" title="发布招聘/服务"></a>发布招聘/服务</h3><ul><li>用户可以发布招聘，寻找合适的外教，外教可以发布服务，寻找合适的用户。根据不同的用户，实现不同的功能。实现代码见附录六<br><img src="https://img-blog.csdnimg.cn/20210203141812159.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Vwc3RyZWFtNDgw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li></ul><h3 id="发布管理"><a href="#发布管理" class="headerlink" title="发布管理"></a>发布管理</h3><ul><li><p>外国用户都可以看到自己发布的招聘或者服务，可以编辑自己发布的招聘或者服务，也可以删除自己发布的内容，点击删除即可删除发布。<br><img src="https://img-blog.csdnimg.cn/20210203141856252.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Vwc3RyZWFtNDgw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="修改密码功能"><a href="#修改密码功能" class="headerlink" title="修改密码功能"></a>修改密码功能</h3></li><li><p>用户点击修改密码，进入修改密码界面，需要用户输入旧密码，新密码，确认新密码，系统会验证旧密码的正确性，和两次新密吗的一致性，通过则修改密码。修改成功后重新登录。<br><img src="https://img-blog.csdnimg.cn/20210203141915550.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Vwc3RyZWFtNDgw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2></li><li><p>Spring Boot是基于Spring框架开发的全新框架，其设计目的是简化新Spring应用的初始化搭建和开发过程。它整合了许多框架和第三方库配置，几乎可以达到“开箱即用”。这两个特性，让我在这次开发中省去了很多代码的开发时间，springboot是一款非常优秀的后端框架。</p></li><li><p>微信小程序微信小程序是一种全新的连接用户与服务的方式，它可以在微信内被便捷地获取和传播，同时具有出色的使用体验。非常适合作为小项目的前端设计。</p></li><li><p><a href="https://github.com/stream1080/foreignteacher">项目源码</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 微信小程序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>外教供需平台微信小程序</title>
      <link href="/posts/53908.html"/>
      <url>/posts/53908.html</url>
      
        <content type="html"><![CDATA[<h1 id="外教资源供需平台项目设计"><a href="#外教资源供需平台项目设计" class="headerlink" title="外教资源供需平台项目设计"></a>外教资源供需平台项目设计</h1><h2 id="项目摘要"><a href="#项目摘要" class="headerlink" title="项目摘要"></a>项目摘要</h2><ul><li>据统计,目前在上海市长期期工作的外籍人员达3.7万余人,主要来自美国、日本、韩国、徳国、澳大利亚等国家,取得学士学位占95%以上,主要从事信息、计算机、教育、咨洵、科学研究和综合技术服务工作。</li><li>现在上海有很多外国人，可以提供外语家教、展会模特、翻译。本课题的目标建立-一个微信小程序，在上海的外国人可以登录并发布自己的信息，如哪个国家的、母语是什么，什么时间有空、在上海哪个区、可以提供什么服务等。中国人通过这个平台，可以查找自己需要的外国人资源，也可以发布招聘外教的信息。</li><li>项目目的是通过设计一个微信小程序，建立外语教学方面的外教资源联系。连接所有需要外教服务和提供外教服务的用户，让这些人群拥有一个交流的平台。使用当下流行的微信小程序进行设计开发</li></ul><h2 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h2><h3 id="技术可行性"><a href="#技术可行性" class="headerlink" title="技术可行性"></a>技术可行性</h3><h4 id="Java简介"><a href="#Java简介" class="headerlink" title="Java简介"></a>Java简介</h4><ul><li>Java是一种可以撰写跨平台应用软件的面向对象的程序设计语言。Java 技术具有卓越的通用性、高效性、平台移植性和安全性，广泛应用于PC、数据中心、游戏控制台、科学超级计算机、移动电话和互联网，同时拥有全球最大的开发者专业社群。Java作为一门精准的语言，可以使开发者规范自己的程序结构,防止出现结构混乱的情况。同时，其内存回收站可以有效回收内存，防止程序浪费资源，影响机器性能。<h4 id="SpringBoot简介"><a href="#SpringBoot简介" class="headerlink" title="SpringBoot简介"></a>SpringBoot简介</h4></li><li>SpringBoot是由Pivotal团队在2013年开始研发、2014年4月发布第一个版本的全新开源的轻量级框架。它基于Spring4.0设计，不仅继承了Spring框架原有的优秀特性，而且还通过简化配置来进一步简化了Spring应用的整个搭建和开发过程。另外SpringBoot通过集成大量的框架使得依赖包的版本冲突，以及引用的不稳定性等问题得到了很好的解决。</li></ul><h4 id="Mybatis简介"><a href="#Mybatis简介" class="headerlink" title="Mybatis简介"></a>Mybatis简介</h4><ul><li>MyBatis 是一款优秀的持久层框架，它支持自定义 SQL、存储过程以及高级映射。MyBatis 免除了几乎所有的 JDBC 代码以及设置参数和获取结果集的工作。MyBatis 可以通过简单的 XML 或注解来配置和映射原始类型、接口和 Java POJO（Plain Old Java Objects，普通老式 Java 对象）为数据库中的记录。<h4 id="MySQL简介"><a href="#MySQL简介" class="headerlink" title="MySQL简介"></a>MySQL简介</h4></li><li>MySQL是最流行的关系型数据库管理系统，在WEB应用方面MySQL是最好的RDBMS<br> (Relational Database Management System,关系数据库管理系统)应用软件之一。MySQL是一种关联数据库管理系统，具有极高的灵活性。MySQL 所使用的SQL语言是用于访问数据库的最常用标准化语言。MySQL体积小、速度快、总体拥有成本低，尤其是开放源码这一特点，-般中小型网站的开发都选择MySQL作为网站数据库。<h4 id="微信小程序"><a href="#微信小程序" class="headerlink" title="微信小程序"></a>微信小程序</h4></li><li>微信小程序是一种全新的连接用户与服务的方式，它可以在微信内被便捷地获取和传播，同时具有出色的使用体验</li></ul><h3 id="功能需求"><a href="#功能需求" class="headerlink" title="功能需求"></a>功能需求</h3><ol><li>用户按照身份进行登录，展示不同的界面和不同的功能，如用户登录可以看到外教的信息，外教登录可以看到用户的招聘信息。</li><li>中国人的用户可以发布招聘信息，可以看到外教信息，如照片，国家、语言、所在区域，授课时间等。可以选择其中的外教，可通过电话联系，可免费预约试听。</li><li>外教可以发布自己可以提供的服务，展示自己的信息，如照片，国家、语言、所在区域，授课时间等。</li><li>用户可以编辑自己的个人信息，发布招聘内容和发布外教服务；管理自己的发布内容，管理自己的预约情况，修改密码等常用的用户管理功能。</li></ol><h2 id="技术选型与架构"><a href="#技术选型与架构" class="headerlink" title="技术选型与架构"></a>技术选型与架构</h2><ul><li>Java版本：1.8</li><li>数据库：MySQL</li><li>框架：SpringBoot + MyBatis</li><li>服务器：Tomcat</li><li>前端：微信小程序</li><li>开发工具：Idea 2020，微信开发者工具</li><li>版本管理工具：Maven</li><li>版本控制工具：GitHub</li><li>其他工具：Navicat</li></ul><h2 id="总体设计"><a href="#总体设计" class="headerlink" title="总体设计"></a>总体设计</h2><p><img src="https://img-blog.csdnimg.cn/2021020313571184.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Vwc3RyZWFtNDgw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="系统整体结构图"><a href="#系统整体结构图" class="headerlink" title="系统整体结构图"></a>系统整体结构图</h3><p><img src="https://img-blog.csdnimg.cn/20210203135627639.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Vwc3RyZWFtNDgw,size_16,color_FFFFFF,t_70"></p><h3 id="系统架构"><a href="#系统架构" class="headerlink" title="系统架构"></a>系统架构</h3><p><img src="https://img-blog.csdnimg.cn/20210203135725113.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Vwc3RyZWFtNDgw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="关系模式设计"><a href="#关系模式设计" class="headerlink" title="关系模式设计"></a>关系模式设计</h2><h3 id="数据库E-R图"><a href="#数据库E-R图" class="headerlink" title="数据库E-R图"></a>数据库E-R图</h3><p><img src="https://img-blog.csdnimg.cn/2021020314015669.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Vwc3RyZWFtNDgw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="数据库关系模型"><a href="#数据库关系模型" class="headerlink" title="数据库关系模型"></a>数据库关系模型</h3><ul><li>用户(用户ID，姓名，年龄，性别，地址，电话，国籍，语言，类型)</li><li>主键：用户ID</li></ul><ul><li>招聘(招聘ID，用户ID，时间，地点，需求，电话，内容)</li><li>主键：招聘ID，外键：用户ID</li></ul><ul><li>外教(外教ID，用户ID，时间，地点，服务，电话，内容)</li><li>主键：外教ID，外键：用户ID</li></ul><h3 id="数据库表设计"><a href="#数据库表设计" class="headerlink" title="数据库表设计"></a>数据库表设计</h3><p><img src="https://img-blog.csdnimg.cn/20210203141255494.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Vwc3RyZWFtNDgw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210203141310211.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Vwc3RyZWFtNDgw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210203141327230.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Vwc3RyZWFtNDgw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="系统各功能实现"><a href="#系统各功能实现" class="headerlink" title="系统各功能实现"></a>系统各功能实现</h2><h3 id="登录功能"><a href="#登录功能" class="headerlink" title="登录功能"></a>登录功能</h3><ul><li>打开小程序，进入登录界面，输入账号和密码，点击登录，系统会判断用户的账号和密码，已经用户的身份，根据用户的身份进入不同的页面。小程序会访问后端服务器的一个登录接口，将账号和密码打包送往服务器进行验证，验证成功返回该用户的信息，验证失败则显示账号密码错误或者账号未注册。<br><img src="https://img-blog.csdnimg.cn/20210203141358229.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Vwc3RyZWFtNDgw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li></ul><h3 id="用户招聘列表"><a href="#用户招聘列表" class="headerlink" title="用户招聘列表"></a>用户招聘列表</h3><ul><li>小程序第一页，用户发布的招聘。打开进入小程序，即可看到所有的用户发布的招聘信息，点击其中一个即可进入页面查看详细的招聘描述，点击下方的电话预约按钮即可拨打电话与外教联系，预约试听。<br><img src="https://img-blog.csdnimg.cn/20210203141432633.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Vwc3RyZWFtNDgw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li></ul><h3 id="外教服务列表"><a href="#外教服务列表" class="headerlink" title="外教服务列表"></a>外教服务列表</h3><ul><li>外教服务列表位于小程序中间的导航栏，点击即可显示所有外教发布的可提供外教服务的服务信息，选择其中一个，点击进入即可查看详细的外教服务内容，点击下方的电话预约即可预约相应的外教，申请试听。<br><img src="https://img-blog.csdnimg.cn/20210203141635358.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Vwc3RyZWFtNDgw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li></ul><h3 id="拨打电话预约"><a href="#拨打电话预约" class="headerlink" title="拨打电话预约"></a>拨打电话预约</h3><ul><li>调用拨打电话的接口，拨打用户发布招聘中预留的电话，或者外教发布的服务预留的电话，与对方联系具体的情况和预约试听。<br><img src="https://img-blog.csdnimg.cn/20210203141657371.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Vwc3RyZWFtNDgw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li></ul><h3 id="查看和编辑用户个人信息"><a href="#查看和编辑用户个人信息" class="headerlink" title="查看和编辑用户个人信息"></a>查看和编辑用户个人信息</h3><ul><li>在导航栏“我的”中，点击信息维护即可查看个人的所有信息，点击编辑信息即可修改个人的所有信息。<br><img src="https://img-blog.csdnimg.cn/20210203141724215.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Vwc3RyZWFtNDgw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li></ul><h3 id="发布招聘-服务"><a href="#发布招聘-服务" class="headerlink" title="发布招聘/服务"></a>发布招聘/服务</h3><ul><li>用户可以发布招聘，寻找合适的外教，外教可以发布服务，寻找合适的用户。根据不同的用户，实现不同的功能。实现代码见附录六<br><img src="https://img-blog.csdnimg.cn/20210203141812159.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Vwc3RyZWFtNDgw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li></ul><h3 id="发布管理"><a href="#发布管理" class="headerlink" title="发布管理"></a>发布管理</h3><ul><li><p>外国用户都可以看到自己发布的招聘或者服务，可以编辑自己发布的招聘或者服务，也可以删除自己发布的内容，点击删除即可删除发布。<br><img src="https://img-blog.csdnimg.cn/20210203141856252.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Vwc3RyZWFtNDgw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="修改密码功能"><a href="#修改密码功能" class="headerlink" title="修改密码功能"></a>修改密码功能</h3></li><li><p>用户点击修改密码，进入修改密码界面，需要用户输入旧密码，新密码，确认新密码，系统会验证旧密码的正确性，和两次新密吗的一致性，通过则修改密码。修改成功后重新登录。<br><img src="https://img-blog.csdnimg.cn/20210203141915550.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Vwc3RyZWFtNDgw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2></li><li><p>Spring Boot是基于Spring框架开发的全新框架，其设计目的是简化新Spring应用的初始化搭建和开发过程。它整合了许多框架和第三方库配置，几乎可以达到“开箱即用”。这两个特性，让我在这次开发中省去了很多代码的开发时间，springboot是一款非常优秀的后端框架。</p></li><li><p>微信小程序微信小程序是一种全新的连接用户与服务的方式，它可以在微信内被便捷地获取和传播，同时具有出色的使用体验。非常适合作为小项目的前端设计。</p></li><li><p><a href="https://github.com/stream1080/foreignteacher">项目源码</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 微信小程序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot+Mybatis+Swagger2整合(下)</title>
      <link href="/posts/43064.html"/>
      <url>/posts/43064.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h4 id="书接上回"><a href="#书接上回" class="headerlink" title="书接上回"></a>书接上回</h4><p>上一篇文章我们讲了 SpringBoot整合Mybatis，没看的小伙伴可以点击链接看一下</p><ul><li><a href="https://blog.csdn.net/upstream480/article/details/113528828">SpringBoot+Mybatis+Swagger2整合(上)</a></li></ul><p>这一篇我们接着讲整合Swagger2实现自动化测试和API接口文档</p><h4 id="Swagger2介绍"><a href="#Swagger2介绍" class="headerlink" title="Swagger2介绍"></a>Swagger2介绍</h4><ul><li><p>我们做开发的时候，经常需要对一些功能进行测试，一个一个的测试非常麻烦。</p></li><li><p>Swagger2 可以识别控制器中的方法，然后自动生成可视化的测试界面。后端开-发人员编写完 Spring Boot 后端接口后，直接可视化测试就行了。不需要编写测试类和测试方法，也不需要与前端开发确认接口是否正常。</p></li><li><p>现在非常流行前后端分离开发，因此前后端开发人员的交流就成了问题，接口文档应运而生</p></li><li><p>如果给控制器方法添加注解，还能自动生成在线 API 文档，方便前端开发人员使用和交流。</p><h2 id="代码配置"><a href="#代码配置" class="headerlink" title="代码配置"></a>代码配置</h2><h4 id="在pom-xml中引入Swagger2的依赖"><a href="#在pom-xml中引入Swagger2的依赖" class="headerlink" title="在pom.xml中引入Swagger2的依赖"></a>在pom.xml中引入Swagger2的依赖</h4></li><li><p>springfox-swagger2 引入 swagger2相关的依赖包</p></li><li><p>springfox-swagger-ui 引入 swagger-ui相关的依赖包</p></li></ul><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token comment">&lt;!-- 引入swagger2相关依赖 --></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>io.springfox<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>springfox-swagger2<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>2.9.2<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span><span class="token comment">&lt;!-- 引入添加swagger-ui相关依赖 --></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>io.springfox<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>springfox-swagger-ui<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>2.9.2<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="配置Swagger相关的功能"><a href="#配置Swagger相关的功能" class="headerlink" title="配置Swagger相关的功能"></a>配置Swagger相关的功能</h4><ul><li>在项目目录下新建一个package，命名为config</li><li>在config中新建一个命名为Swagger2Config的class文件</li><li>添加注解@Configuration  告诉Spring容器，这个类是一个配置类</li><li>添加@EnableSwagger2  启用Swagger2的各项功能</li><li>通过 @Bean 标注的方法将对 Swagger2 功能的设置放入容器。<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">package</span> <span class="token namespace">com<span class="token punctuation">.</span>example<span class="token punctuation">.</span>demo<span class="token punctuation">.</span>config</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>context<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span></span><span class="token class-name">Bean</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>context<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span></span><span class="token class-name">Configuration</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">springfox<span class="token punctuation">.</span>documentation<span class="token punctuation">.</span>builders<span class="token punctuation">.</span></span><span class="token class-name">ApiInfoBuilder</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">springfox<span class="token punctuation">.</span>documentation<span class="token punctuation">.</span>builders<span class="token punctuation">.</span></span><span class="token class-name">PathSelectors</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">springfox<span class="token punctuation">.</span>documentation<span class="token punctuation">.</span>builders<span class="token punctuation">.</span></span><span class="token class-name">RequestHandlerSelectors</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">springfox<span class="token punctuation">.</span>documentation<span class="token punctuation">.</span>service<span class="token punctuation">.</span></span><span class="token class-name">ApiInfo</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">springfox<span class="token punctuation">.</span>documentation<span class="token punctuation">.</span>spi<span class="token punctuation">.</span></span><span class="token class-name">DocumentationType</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">springfox<span class="token punctuation">.</span>documentation<span class="token punctuation">.</span>spring<span class="token punctuation">.</span>web<span class="token punctuation">.</span>plugins<span class="token punctuation">.</span></span><span class="token class-name">Docket</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">springfox<span class="token punctuation">.</span>documentation<span class="token punctuation">.</span>swagger2<span class="token punctuation">.</span>annotations<span class="token punctuation">.</span></span><span class="token class-name">EnableSwagger2</span><span class="token punctuation">;</span><span class="token annotation punctuation">@Configuration</span> <span class="token comment">// 告诉Spring容器，这个类是一个配置类</span><span class="token annotation punctuation">@EnableSwagger2</span> <span class="token comment">// 启用Swagger2功能</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Swagger2Config</span> <span class="token punctuation">&#123;</span>    <span class="token comment">/**     * 配置Swagger2相关的bean     */</span>    <span class="token annotation punctuation">@Bean</span>    <span class="token keyword">public</span> <span class="token class-name">Docket</span> <span class="token function">createRestApi</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Docket</span><span class="token punctuation">(</span><span class="token class-name">DocumentationType</span><span class="token punctuation">.</span>SWAGGER_2<span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">apiInfo</span><span class="token punctuation">(</span><span class="token function">apiInfo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">select</span><span class="token punctuation">(</span><span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">apis</span><span class="token punctuation">(</span><span class="token class-name">RequestHandlerSelectors</span><span class="token punctuation">.</span><span class="token function">basePackage</span><span class="token punctuation">(</span><span class="token string">"com"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">// com包下所有API都交给Swagger2管理</span>                <span class="token punctuation">.</span><span class="token function">paths</span><span class="token punctuation">(</span><span class="token class-name">PathSelectors</span><span class="token punctuation">.</span><span class="token function">any</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">/**     * API文档地址：http://127.0.0.1:8080/swagger-ui.html#/     *     * 此处主要是API文档页面显示信息     */</span>    <span class="token keyword">private</span> <span class="token class-name">ApiInfo</span> <span class="token function">apiInfo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ApiInfoBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">title</span><span class="token punctuation">(</span><span class="token string">"项目API"</span><span class="token punctuation">)</span> <span class="token comment">// 标题</span>                <span class="token punctuation">.</span><span class="token function">description</span><span class="token punctuation">(</span><span class="token string">"整个项目的各个API"</span><span class="token punctuation">)</span> <span class="token comment">// 描述</span>                <span class="token punctuation">.</span><span class="token function">termsOfServiceUrl</span><span class="token punctuation">(</span><span class="token string">"http://www.baidu.com"</span><span class="token punctuation">)</span> <span class="token comment">// 服务网址，一般写公司地址</span>                <span class="token punctuation">.</span><span class="token function">version</span><span class="token punctuation">(</span><span class="token string">"1.0"</span><span class="token punctuation">)</span> <span class="token comment">// 版本</span>                <span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h4 id="生成在线API文档"><a href="#生成在线API文档" class="headerlink" title="生成在线API文档"></a>生成在线API文档</h4><ul><li>在各个controller中添加@Api注解</li><li>@Api(tags = “用户管理API”) 类文档显示的接口名称</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@RestController</span><span class="token annotation punctuation">@Api</span><span class="token punctuation">(</span>tags <span class="token operator">=</span> <span class="token string">"用户管理API"</span><span class="token punctuation">)</span> <span class="token comment">// 类文档显示内容</span><span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span><span class="token string">"/admin"</span><span class="token punctuation">)</span>   <span class="token comment">//地址映射的注解</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">UserController</span> <span class="token punctuation">&#123;</span>    <span class="token annotation punctuation">@Autowired</span>    <span class="token keyword">private</span> <span class="token class-name">UserService</span> userService<span class="token punctuation">;</span>    <span class="token comment">/**     * 获取用户列表     * @return     */</span>    <span class="token annotation punctuation">@ApiOperation</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">"获取用户列表信息"</span><span class="token punctuation">)</span> <span class="token comment">// 接口文档显示内容</span>    <span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">"listuser"</span><span class="token punctuation">,</span>method <span class="token operator">=</span> <span class="token class-name">RequestMethod</span><span class="token punctuation">.</span>GET<span class="token punctuation">)</span>    <span class="token keyword">private</span> <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span><span class="token class-name">Object</span><span class="token punctuation">></span></span> <span class="token function">listUser</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span><span class="token class-name">Object</span><span class="token punctuation">></span></span> modelMap <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span><span class="token class-name">Object</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">User</span><span class="token punctuation">></span></span> list <span class="token operator">=</span> userService<span class="token punctuation">.</span><span class="token function">getUserList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        modelMap<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"userList"</span><span class="token punctuation">,</span>list<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> modelMap<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">/**     * 通过用户Id获取用户信息     *     * @return     */</span>    <span class="token annotation punctuation">@ApiOperation</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">"通过用户Id获取用户信息"</span><span class="token punctuation">)</span> <span class="token comment">// 接口文档显示内容</span>    <span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">"/getuserbyid"</span><span class="token punctuation">,</span> method <span class="token operator">=</span> <span class="token class-name">RequestMethod</span><span class="token punctuation">.</span>GET<span class="token punctuation">)</span>    <span class="token keyword">private</span> <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">></span></span> <span class="token function">getUserById</span><span class="token punctuation">(</span><span class="token class-name">Integer</span> userId<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">></span></span> modelMap <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 获取用户信息</span>        <span class="token class-name">User</span> user <span class="token operator">=</span> userService<span class="token punctuation">.</span><span class="token function">getUserById</span><span class="token punctuation">(</span>userId<span class="token punctuation">)</span><span class="token punctuation">;</span>        modelMap<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"user"</span><span class="token punctuation">,</span> user<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> modelMap<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">/**     * 添加用户信息     *     * @param userStr     * @param request     * @return     * @throws IOException     * @throws JsonMappingException     * @throws JsonParseException     */</span>    <span class="token annotation punctuation">@ApiOperation</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">"添加用户信息"</span><span class="token punctuation">)</span> <span class="token comment">// 接口文档显示内容</span>    <span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">"/adduser"</span><span class="token punctuation">,</span> method <span class="token operator">=</span> <span class="token class-name">RequestMethod</span><span class="token punctuation">.</span>POST<span class="token punctuation">)</span>    <span class="token keyword">private</span> <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span><span class="token class-name">Object</span><span class="token punctuation">></span></span> <span class="token function">addUser</span><span class="token punctuation">(</span><span class="token annotation punctuation">@RequestBody</span> <span class="token class-name">User</span> user<span class="token punctuation">)</span>            <span class="token keyword">throws</span> <span class="token class-name">JsonParseException</span><span class="token punctuation">,</span> <span class="token class-name">JsonMappingException</span><span class="token punctuation">,</span> <span class="token class-name">IOException</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">></span></span> modelMap <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        modelMap<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"success"</span><span class="token punctuation">,</span> userService<span class="token punctuation">.</span><span class="token function">addUser</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> modelMap<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">/**     * 修改用户信息     *     * @param userStr     * @param request     * @return     * @throws IOException     * @throws JsonMappingException     * @throws JsonParseException     */</span>    <span class="token annotation punctuation">@ApiOperation</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">"修改用户信息"</span><span class="token punctuation">)</span> <span class="token comment">// 接口文档显示内容</span>    <span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">"/modifyuser"</span><span class="token punctuation">,</span> method <span class="token operator">=</span> <span class="token class-name">RequestMethod</span><span class="token punctuation">.</span>POST<span class="token punctuation">)</span>    <span class="token keyword">private</span> <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">></span></span> <span class="token function">modifyUser</span><span class="token punctuation">(</span><span class="token annotation punctuation">@RequestBody</span> <span class="token class-name">User</span> user<span class="token punctuation">)</span>            <span class="token keyword">throws</span> <span class="token class-name">JsonParseException</span><span class="token punctuation">,</span> <span class="token class-name">JsonMappingException</span><span class="token punctuation">,</span> <span class="token class-name">IOException</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">></span></span> modelMap <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        modelMap<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"success"</span><span class="token punctuation">,</span> userService<span class="token punctuation">.</span><span class="token function">modifyUser</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> modelMap<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">/**     * 删除用户信息     * @param userId     * @return     */</span>    <span class="token annotation punctuation">@ApiOperation</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">"删除用户信息"</span><span class="token punctuation">)</span> <span class="token comment">// 接口文档显示内容</span>    <span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">"/removeuser"</span><span class="token punctuation">,</span> method <span class="token operator">=</span> <span class="token class-name">RequestMethod</span><span class="token punctuation">.</span>GET<span class="token punctuation">)</span>    <span class="token keyword">private</span> <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">></span></span> <span class="token function">removeUser</span><span class="token punctuation">(</span><span class="token class-name">Integer</span> userId<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">></span></span> modelMap <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        modelMap<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"success"</span><span class="token punctuation">,</span> userService<span class="token punctuation">.</span><span class="token function">deleteUser</span><span class="token punctuation">(</span>userId<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> modelMap<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="启动项目，测试swagger2的相关功能"><a href="#启动项目，测试swagger2的相关功能" class="headerlink" title="启动项目，测试swagger2的相关功能"></a>启动项目，测试swagger2的相关功能</h4><ul><li><p>启动项目</p></li><li><p>在浏览器上访问  <a href="http://127.0.0.1:8080/swagger-ui.html#/">http://127.0.0.1:8080/swagger-ui.html#/</a><br><img src="https://img-blog.csdnimg.cn/20210202224223153.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Vwc3RyZWFtNDgw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p></li><li><p>API中使用的参数模型<br><img src="https://img-blog.csdnimg.cn/20210202224343716.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Vwc3RyZWFtNDgw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p></li><li><p>至此，我们的在线API文档就完成了，前端开发人员就可以根据这个文档使用各个API接口进行开发了，接下来我们进入测试环节</p><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><h4 id="测试添加用户API"><a href="#测试添加用户API" class="headerlink" title="测试添加用户API"></a>测试添加用户API</h4></li><li><p>点击第一个添加用户API<br><img src="https://img-blog.csdnimg.cn/20210202224703156.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Vwc3RyZWFtNDgw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p></li><li><p>点击Try it out进行测试</p></li><li><p>输入测试参数，点击Execute执行测试方法<br><img src="https://img-blog.csdnimg.cn/20210202224851388.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Vwc3RyZWFtNDgw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p></li><li><p>返回结果，success：true 说明添加用户成功<br><img src="https://img-blog.csdnimg.cn/20210202225022490.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Vwc3RyZWFtNDgw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h4 id="测试根据Id查询用户信息API"><a href="#测试根据Id查询用户信息API" class="headerlink" title="测试根据Id查询用户信息API"></a>测试根据Id查询用户信息API</h4></li><li><p>点击第二个方法，根据用户Id获取用户信息</p></li><li><p>输入用户Id，也就是刚刚我们添加的哪一个，点击Execute执行<br><img src="https://img-blog.csdnimg.cn/20210202225219789.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Vwc3RyZWFtNDgw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p></li><li><p>返回结果为刚刚我们添加的测试用户的信息，测试成功<br><img src="https://img-blog.csdnimg.cn/20210202225450138.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Vwc3RyZWFtNDgw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p></li><li><p>依次测试其他的各个API</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2></li><li><p>我们用两篇文章讲解了SpringBoot+Mybatis+Swagger2整合，实现springboot与数据库的连接和自动生成API文档，并且进行了测试各个API的功能。</p></li><li><p>这个项目可以作为一个模板，以后进行其他的项目的时候，就可以直接用这个模板进行修改或者扩充，省去配置mybatis和swagger2的时间。大家下载下来直接在这个基础上进行修改就可以了，我还在上面添加了Junit的测试模块，方便大家使用。</p></li><li><p><a href="https://github.com/stream1080/springboot-mybatis-swagger2">Github项目源码</a></p></li><li><p><a href="https://gitee.com/stream1080/springboot-mybatis-swagger2">Gitee项目源码</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring Boot </tag>
            
            <tag> Mybatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot+Mybatis+Swagger2整合(上)</title>
      <link href="/posts/14393.html"/>
      <url>/posts/14393.html</url>
      
        <content type="html"><![CDATA[<h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><ul><li>Spring家族框架已经统治Java后端开发很多年了，很多大型项目都是用SSM(Spring+SpringMVC+Mybatis)作为后端框架。而且在可预知的未来，Spring没有被替代的可能。</li><li>但是SSM项目配置起来非常繁琐，需要写大量的配置文件，为了简化开发的步骤，防止把时间浪费在没用必要的配置上。SpringBoot应运而生。</li><li>Spring Boot 为简化 Spring 应用开发而生，Spring Boot 中的 Boot 一词，即为快速启动的意思。Spring Boot 可以在零配置情况下一键启动，简洁而优雅。</li></ul><h4 id="SpringBoot"><a href="#SpringBoot" class="headerlink" title="SpringBoot"></a>SpringBoot</h4><p>为了让 Spring 开发者痛快到底，Spring 团队做了以下设计：</p><ul><li>简化依赖，提供整合的依赖项，告别逐一添加依赖项的烦恼；</li><li>简化配置，提供约定俗成的默认配置，告别编写各种配置的繁琐；</li><li>简化部署，内置 servlet 容器，开发时一键即运行。可打包为 jar 文件，部署时一行命令即启动；</li><li>简化监控，提供简单方便的运行监控方式。</li></ul><p>基于以上设计目的，Spring 团队推出了 Spring Boot 。</p><h4 id="Mybatis"><a href="#Mybatis" class="headerlink" title="Mybatis"></a>Mybatis</h4><ul><li>MyBatis 是企业级应用数据持久层框架，他与 Hibernate 和 JPA都是<br>ORM 对象 - 关系映射框架，使用 Hibernate ，开发者可以不考虑 SQL 语句的编写与执行，直接操作对象即可。</li><li>但是MyBatis 是需要手工编写 SQL 语句的。应用越复杂对SQL的性能要求就跟高，能够手工编写SQL语句的Mybatis就展现出灵活性。MyBatis 是更加简单，更容易上手的框架，但是功能也是相对简陋点。而且在国内，Mybatis用的比较多。</li></ul><h4 id="Swagger2"><a href="#Swagger2" class="headerlink" title="Swagger2"></a>Swagger2</h4><ul><li><p>我们做开发的时候，经常需要对一些功能进行测试，一个一个的测试非常麻烦。</p></li><li><p>Swagger2 可以识别控制器中的方法，然后自动生成可视化的测试界面。后端开发人员编写完 Spring Boot 后端接口后，直接可视化测试就行了。不用编写测试类和测试方法，不用联系前端开发确认接口是否正常。</p></li><li><p>现在非常流行前后端分离开发，因此前后端开发人员的交流就成了问题，接口文档应运而生</p></li><li><p>如果给控制器方法添加注解，还能自动生成在线 API 文档，方便前端开发人员使用和交流。</p></li></ul><h4 id="整合springboot-mybatis-swagger2"><a href="#整合springboot-mybatis-swagger2" class="headerlink" title="整合springboot+mybatis+swagger2"></a>整合springboot+mybatis+swagger2</h4><p>虽然springboot简化了spring的配置，但是整合这些组件仍然需要不少的时间。这篇教程就演示一下如何整合这三个组件。</p><h2 id="整合SpringBoot-Mybatis"><a href="#整合SpringBoot-Mybatis" class="headerlink" title="整合SpringBoot+Mybatis"></a>整合SpringBoot+Mybatis</h2><h4 id="创建数据库和表"><a href="#创建数据库和表" class="headerlink" title="创建数据库和表"></a>创建数据库和表</h4><p>创建一个名为demo的数据库，并创建一个名为“tb_user”的表用于测试</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token constant">CREATE</span> <span class="token constant">TABLE</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">tb_user</span><span class="token template-punctuation string">`</span></span> <span class="token punctuation">(</span>  <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">user_id</span><span class="token template-punctuation string">`</span></span> <span class="token function">int</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token constant">NOT</span> <span class="token constant">NULL</span> <span class="token constant">AUTO_INCREMENT</span><span class="token punctuation">,</span>  <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">user_name</span><span class="token template-punctuation string">`</span></span> <span class="token function">varchar</span><span class="token punctuation">(</span><span class="token number">200</span><span class="token punctuation">)</span> <span class="token constant">DEFAULT</span> <span class="token constant">NULL</span><span class="token punctuation">,</span>  <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">age</span><span class="token template-punctuation string">`</span></span> <span class="token function">int</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token constant">DEFAULT</span> <span class="token constant">NULL</span><span class="token punctuation">,</span>  <span class="token constant">PRIMARY</span> <span class="token constant">KEY</span> <span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">user_id</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span> <span class="token constant">USING</span> <span class="token constant">BTREE</span><span class="token punctuation">,</span>  <span class="token constant">UNIQUE</span> <span class="token constant">KEY</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">area_name_UNIQUE</span><span class="token template-punctuation string">`</span></span> <span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">user_name</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token constant">ENGINE</span><span class="token operator">=</span>InnoDB <span class="token constant">AUTO_INCREMENT</span><span class="token operator">=</span><span class="token number">8</span> <span class="token constant">DEFAULT</span> <span class="token constant">CHARSET</span><span class="token operator">=</span>utf8<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h4><ul><li>创建一个springboot项目，版本选择2.4.2。添加web需要的依赖</li></ul><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token operator">&lt;</span>dependency<span class="token operator">></span>    <span class="token operator">&lt;</span>groupId<span class="token operator">></span>org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>boot<span class="token operator">&lt;</span><span class="token operator">/</span>groupId<span class="token operator">></span>    <span class="token operator">&lt;</span>artifactId<span class="token operator">></span>spring<span class="token operator">-</span>boot<span class="token operator">-</span>starter<span class="token operator">-</span>test<span class="token operator">&lt;</span><span class="token operator">/</span>artifactId<span class="token operator">></span>    <span class="token operator">&lt;</span>scope<span class="token operator">></span>test<span class="token operator">&lt;</span><span class="token operator">/</span>scope<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>dependency<span class="token operator">></span><span class="token operator">&lt;</span>dependency<span class="token operator">></span>    <span class="token operator">&lt;</span>groupId<span class="token operator">></span>org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>boot<span class="token operator">&lt;</span><span class="token operator">/</span>groupId<span class="token operator">></span>    <span class="token operator">&lt;</span>artifactId<span class="token operator">></span>spring<span class="token operator">-</span>boot<span class="token operator">-</span>starter<span class="token operator">-</span>web<span class="token operator">&lt;</span><span class="token operator">/</span>artifactId<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>dependency<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>在pom.xml下添加MySQL和mybatis的依赖</li></ul><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span>mysql数据库<span class="token operator">--</span><span class="token operator">></span>      <span class="token operator">&lt;</span>dependency<span class="token operator">></span>          <span class="token operator">&lt;</span>groupId<span class="token operator">></span>mysql<span class="token operator">&lt;</span><span class="token operator">/</span>groupId<span class="token operator">></span>          <span class="token operator">&lt;</span>artifactId<span class="token operator">></span>mysql<span class="token operator">-</span>connector<span class="token operator">-</span>java<span class="token operator">&lt;</span><span class="token operator">/</span>artifactId<span class="token operator">></span>          <span class="token operator">&lt;</span>scope<span class="token operator">></span>runtime<span class="token operator">&lt;</span><span class="token operator">/</span>scope<span class="token operator">></span>      <span class="token operator">&lt;</span><span class="token operator">/</span>dependency<span class="token operator">></span>      <span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span>mybatis相关的依赖<span class="token operator">--</span><span class="token operator">></span>      <span class="token operator">&lt;</span>dependency<span class="token operator">></span>          <span class="token operator">&lt;</span>groupId<span class="token operator">></span>org<span class="token punctuation">.</span>mybatis<span class="token punctuation">.</span>spring<span class="token punctuation">.</span>boot<span class="token operator">&lt;</span><span class="token operator">/</span>groupId<span class="token operator">></span>          <span class="token operator">&lt;</span>artifactId<span class="token operator">></span>mybatis<span class="token operator">-</span>spring<span class="token operator">-</span>boot<span class="token operator">-</span>starter<span class="token operator">&lt;</span><span class="token operator">/</span>artifactId<span class="token operator">></span>          <span class="token operator">&lt;</span>version<span class="token operator">></span><span class="token number">1.3</span><span class="token number">.1</span><span class="token operator">&lt;</span><span class="token operator">/</span>version<span class="token operator">></span>      <span class="token operator">&lt;</span><span class="token operator">/</span>dependency<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="配置application-properties文件"><a href="#配置application-properties文件" class="headerlink" title="配置application.properties文件"></a>配置application.properties文件</h4><ul><li>这个文件是springboot项目的配置文件，我们在里面添加一些mysql的连接信息，和mybatis配置文件的位置</li></ul><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"># 配置数据库驱动 ，新版本需要加上cjspring<span class="token punctuation">.</span>datasource<span class="token punctuation">.</span>driver<span class="token operator">-</span><span class="token keyword">class</span><span class="token operator">-</span>name<span class="token operator">=</span>com<span class="token punctuation">.</span>mysql<span class="token punctuation">.</span>cj<span class="token punctuation">.</span>jdbc<span class="token punctuation">.</span>Driver# 配置数据库urlspring<span class="token punctuation">.</span>datasource<span class="token punctuation">.</span>url<span class="token operator">=</span>jdbc<span class="token operator">:</span>mysql<span class="token operator">:</span><span class="token operator">/</span><span class="token operator">/</span><span class="token number">127.0</span><span class="token number">.0</span><span class="token number">.1</span><span class="token operator">:</span><span class="token number">3306</span><span class="token operator">/</span>demo<span class="token operator">?</span>useUnicode<span class="token operator">=</span><span class="token boolean">true</span><span class="token operator">&amp;</span>characterEncoding<span class="token operator">=</span>utf<span class="token operator">-</span><span class="token number">8</span><span class="token operator">&amp;</span>serverTimezone<span class="token operator">=</span><span class="token constant">UTC</span># 配置数据库用户名spring<span class="token punctuation">.</span>datasource<span class="token punctuation">.</span>username<span class="token operator">=</span>root# 配置数据库密码spring<span class="token punctuation">.</span>datasource<span class="token punctuation">.</span>password<span class="token operator">=</span>root# 指定MyBatis配置文件位置mybatis<span class="token punctuation">.</span>mapper<span class="token operator">-</span>locations<span class="token operator">=</span>classpath<span class="token operator">:</span>mapper<span class="token comment">/*.xml# 开启驼峰命名转换 user_name --> userNamemybatis.configuration.map-underscore-to-camel-case=true</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="编写entity文件"><a href="#编写entity文件" class="headerlink" title="编写entity文件"></a>编写entity文件</h4><ul><li>在项目目录下建立一个名为entity的package，新建一个User的class文件,这是一个实体类，用于存放数据库访问对象</li></ul><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">package</span> com<span class="token punctuation">.</span>example<span class="token punctuation">.</span>demo<span class="token punctuation">.</span>entity<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">User</span> <span class="token punctuation">&#123;</span>    <span class="token comment">//主键，唯一识别Id</span>    <span class="token keyword">private</span> Integer userId<span class="token punctuation">;</span>    <span class="token comment">//姓名</span>    <span class="token keyword">private</span> String userName<span class="token punctuation">;</span>    <span class="token comment">//年龄</span>    <span class="token keyword">private</span> Integer age<span class="token punctuation">;</span>    <span class="token keyword">public</span> Integer <span class="token function">getUserId</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> userId<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setUserId</span><span class="token punctuation">(</span><span class="token parameter">Integer userId</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>userId <span class="token operator">=</span> userId<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> String <span class="token function">getUserName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> userName<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setUserName</span><span class="token punctuation">(</span><span class="token parameter">String userName</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>userName <span class="token operator">=</span> userName<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> Integer <span class="token function">getAge</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> age<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setAge</span><span class="token punctuation">(</span><span class="token parameter">Integer age</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="编写dao文件"><a href="#编写dao文件" class="headerlink" title="编写dao文件"></a>编写dao文件</h4><ul><li>在项目目录下新建一个package，命名为dao。在dao目录下新建一个UserDao的class文件</li></ul><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">package</span> com<span class="token punctuation">.</span>example<span class="token punctuation">.</span>demo<span class="token punctuation">.</span>dao<span class="token punctuation">;</span><span class="token keyword">import</span> com<span class="token punctuation">.</span>example<span class="token punctuation">.</span>demo<span class="token punctuation">.</span>entity<span class="token punctuation">.</span>User<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>ibatis<span class="token punctuation">.</span>annotations<span class="token punctuation">.</span>Mapper<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>stereotype<span class="token punctuation">.</span>Repository<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>List<span class="token punctuation">;</span>@Mapper       <span class="token comment">//标识这个类是一个数据访问层的bean，由spring容器管理</span>@Repository   <span class="token comment">//将这个mapper的bean注册到spring容器，不加也行</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">UserDao</span> <span class="token punctuation">&#123;</span>    <span class="token comment">/**     * 查询所有用户     * @return     */</span>    List<span class="token operator">&lt;</span>User<span class="token operator">></span> <span class="token function">queryUser</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">/**     * 根据用户Id查询用户     * @param userId     * @return     */</span>    User <span class="token function">queryUserById</span><span class="token punctuation">(</span>int userId<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">/**     * 增加用户     * @param user     * @return     */</span>    int <span class="token function">insertUser</span><span class="token punctuation">(</span>User user<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">/**     * 修改用户信息     * @param user     * @return     */</span>    int <span class="token function">updateUser</span><span class="token punctuation">(</span>User user<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">/**     * 删除用户     * @param userId     * @return     */</span>    int <span class="token function">deleteUser</span><span class="token punctuation">(</span>int userId<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>@Mapper       //标识这个类是一个数据访问层的bean，由spring容器管理</li><li>@Repository   //将这个mapper的bean注册到spring容器，不加也行。不加的话，编译器会报错，但不影响程序的运行。强迫症的同学可以在Idea修改一下代码审查的级别<br><img src="https://img-blog.csdnimg.cn/20210201210209291.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Vwc3RyZWFtNDgw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li></ul><h4 id="编写service文件"><a href="#编写service文件" class="headerlink" title="编写service文件"></a>编写service文件</h4><ul><li><p>UserService的接口interface文件</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">package</span> com<span class="token punctuation">.</span>example<span class="token punctuation">.</span>demo<span class="token punctuation">.</span>service<span class="token punctuation">;</span><span class="token keyword">import</span> com<span class="token punctuation">.</span>example<span class="token punctuation">.</span>demo<span class="token punctuation">.</span>entity<span class="token punctuation">.</span>User<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>List<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">UserService</span> <span class="token punctuation">&#123;</span>    <span class="token comment">/**     *     * 获取用户列表     * @return     */</span>    List<span class="token operator">&lt;</span>User<span class="token operator">></span> <span class="token function">getUserList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">/**     * 根据用户Id获取用户信息     * @param userId     * @return     */</span>    User <span class="token function">getUserById</span><span class="token punctuation">(</span>int userId<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">/**     * 增加用户信息     * @param user     * @return     */</span>    boolean <span class="token function">addUser</span><span class="token punctuation">(</span>User user<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">/**     * 修改用户信息     * @param user     * @return     */</span>    boolean <span class="token function">modifyUser</span><span class="token punctuation">(</span>User user<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">/**     * 删除用户信息     * @param userId     * @return     */</span>    boolean <span class="token function">deleteUser</span><span class="token punctuation">(</span>int userId<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>UserServiceImpl的实现类</p></li></ul><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">package</span> com<span class="token punctuation">.</span>example<span class="token punctuation">.</span>demo<span class="token punctuation">.</span>service<span class="token punctuation">.</span>Impl<span class="token punctuation">;</span><span class="token keyword">import</span> com<span class="token punctuation">.</span>example<span class="token punctuation">.</span>demo<span class="token punctuation">.</span>dao<span class="token punctuation">.</span>UserDao<span class="token punctuation">;</span><span class="token keyword">import</span> com<span class="token punctuation">.</span>example<span class="token punctuation">.</span>demo<span class="token punctuation">.</span>entity<span class="token punctuation">.</span>User<span class="token punctuation">;</span><span class="token keyword">import</span> com<span class="token punctuation">.</span>example<span class="token punctuation">.</span>demo<span class="token punctuation">.</span>service<span class="token punctuation">.</span>UserService<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>beans<span class="token punctuation">.</span>factory<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>Autowired<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>stereotype<span class="token punctuation">.</span>Service<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>transaction<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>Transactional<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>List<span class="token punctuation">;</span>@Service  <span class="token comment">//标识这个bean是service层的，并交给spring容器管理</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">UserServiceImpl</span> <span class="token keyword">implements</span> <span class="token class-name">UserService</span> <span class="token punctuation">&#123;</span>    @Autowired    <span class="token keyword">private</span> UserDao userDao<span class="token punctuation">;</span>    @Override    <span class="token keyword">public</span> List<span class="token operator">&lt;</span>User<span class="token operator">></span> <span class="token function">getUserList</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> userDao<span class="token punctuation">.</span><span class="token function">queryUser</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    @Override    <span class="token keyword">public</span> User <span class="token function">getUserById</span><span class="token punctuation">(</span><span class="token parameter">int userId</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> userDao<span class="token punctuation">.</span><span class="token function">queryUserById</span><span class="token punctuation">(</span>userId<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    @Transactional    @Override    <span class="token keyword">public</span> boolean <span class="token function">addUser</span><span class="token punctuation">(</span><span class="token parameter">User user</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>user<span class="token punctuation">.</span><span class="token function">getUserId</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span><span class="token string">""</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>user<span class="token punctuation">.</span><span class="token function">getUserId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>                int effectedNum <span class="token operator">=</span> userDao<span class="token punctuation">.</span><span class="token function">insertUser</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>effectedNum <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>                    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">RuntimeException</span><span class="token punctuation">(</span><span class="token string">"添加用户失败"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span>Exception e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">RuntimeException</span><span class="token punctuation">(</span><span class="token string">"添加用户失败"</span> <span class="token operator">+</span> e<span class="token punctuation">.</span><span class="token function">getMessage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">RuntimeException</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token string">"用户信息不能为空"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    @Override    <span class="token keyword">public</span> boolean <span class="token function">modifyUser</span><span class="token punctuation">(</span><span class="token parameter">User user</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>user<span class="token punctuation">.</span><span class="token function">getUserId</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>user<span class="token punctuation">.</span><span class="token function">getUserId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>                int effectedNum <span class="token operator">=</span> userDao<span class="token punctuation">.</span><span class="token function">updateUser</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>effectedNum <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>                    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">RuntimeException</span><span class="token punctuation">(</span><span class="token string">"更新用户信息失败"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span>Exception e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">RuntimeException</span><span class="token punctuation">(</span><span class="token string">"更新用户信息失败"</span> <span class="token operator">+</span> e<span class="token punctuation">.</span><span class="token function">getMessage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">RuntimeException</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token string">"用户信息不能为空"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    @Override    <span class="token keyword">public</span> boolean <span class="token function">deleteUser</span><span class="token punctuation">(</span><span class="token parameter">int userId</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>userId <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>                int effectedNum <span class="token operator">=</span> userDao<span class="token punctuation">.</span><span class="token function">deleteUser</span><span class="token punctuation">(</span>userId<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>effectedNum <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>                    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">RuntimeException</span><span class="token punctuation">(</span><span class="token string">"删除用户信息失败"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span>Exception e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">RuntimeException</span><span class="token punctuation">(</span><span class="token string">"删除用户信息失败"</span> <span class="token operator">+</span> e<span class="token punctuation">.</span><span class="token function">getMessage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">RuntimeException</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token string">"用户Id不能为空"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>@Service  //标识这个bean是service层的，并交给spring容器管理</li></ul><h4 id="编写mapper文件"><a href="#编写mapper文件" class="headerlink" title="编写mapper文件"></a>编写mapper文件</h4><ul><li>在resources目录下新建一个目录名为mapper，在mapper目录下新建UserDao.xml文件</li></ul><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token operator">&lt;</span><span class="token operator">?</span>xml version<span class="token operator">=</span><span class="token string">"1.0"</span> encoding<span class="token operator">=</span><span class="token string">"UTF-8"</span><span class="token operator">?</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">!</span><span class="token constant">DOCTYPE</span> mapper        <span class="token constant">PUBLIC</span> <span class="token string">"-//mybatis.org//DTD Mapper 3.0//EN"</span>        <span class="token string">"http://mybatis.org/dtd/mybatis-3-mapper.dtd"</span><span class="token operator">></span><span class="token operator">&lt;</span>mapper namespace<span class="token operator">=</span><span class="token string">"com.example.demo.dao.UserDao"</span><span class="token operator">></span>    <span class="token operator">&lt;</span>select id<span class="token operator">=</span><span class="token string">"queryUser"</span> resultType<span class="token operator">=</span><span class="token string">"com.example.demo.entity.User"</span><span class="token operator">></span>        <span class="token constant">SELECT</span> user_id<span class="token punctuation">,</span> user_name<span class="token punctuation">,</span> age        <span class="token constant">FROM</span> tb_user    <span class="token operator">&lt;</span><span class="token operator">/</span>select<span class="token operator">></span>    <span class="token operator">&lt;</span>select id<span class="token operator">=</span><span class="token string">"queryUserById"</span> resultType<span class="token operator">=</span><span class="token string">"com.example.demo.entity.User"</span><span class="token operator">></span>        <span class="token constant">SELECT</span> user_id<span class="token punctuation">,</span> user_name<span class="token punctuation">,</span> age        <span class="token constant">FROM</span> tb_user        <span class="token constant">WHERE</span>            user_id <span class="token operator">=</span> #<span class="token punctuation">&#123;</span>userId<span class="token punctuation">&#125;</span>    <span class="token operator">&lt;</span><span class="token operator">/</span>select<span class="token operator">></span>    <span class="token operator">&lt;</span>insert id<span class="token operator">=</span><span class="token string">"insertUser"</span> useGeneratedKeys<span class="token operator">=</span><span class="token string">"true"</span> keyProperty<span class="token operator">=</span><span class="token string">"userId"</span>            keyColumn<span class="token operator">=</span><span class="token string">"userId"</span> parameterType<span class="token operator">=</span><span class="token string">"com.example.demo.entity.User"</span><span class="token operator">></span>        <span class="token constant">INSERT</span> <span class="token constant">INTO</span>            <span class="token function">tb_user</span><span class="token punctuation">(</span>user_name<span class="token punctuation">,</span> age<span class="token punctuation">)</span>        <span class="token constant">VALUES</span>            <span class="token punctuation">(</span>#<span class="token punctuation">&#123;</span>userName<span class="token punctuation">&#125;</span><span class="token punctuation">,</span>#<span class="token punctuation">&#123;</span>age<span class="token punctuation">&#125;</span><span class="token punctuation">)</span>    <span class="token operator">&lt;</span><span class="token operator">/</span>insert<span class="token operator">></span>    <span class="token operator">&lt;</span>update id<span class="token operator">=</span><span class="token string">"updateUser"</span> parameterType<span class="token operator">=</span><span class="token string">"com.example.demo.entity.User"</span><span class="token operator">></span>        update tb_user        <span class="token operator">&lt;</span>set<span class="token operator">></span>            <span class="token operator">&lt;</span><span class="token keyword">if</span> test<span class="token operator">=</span><span class="token string">"userName != null"</span><span class="token operator">></span>user_name<span class="token operator">=</span>#<span class="token punctuation">&#123;</span>userName<span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token operator">&lt;</span><span class="token operator">/</span><span class="token keyword">if</span><span class="token operator">></span>            <span class="token operator">&lt;</span><span class="token keyword">if</span> test<span class="token operator">=</span><span class="token string">"age != null"</span><span class="token operator">></span>age<span class="token operator">=</span>#<span class="token punctuation">&#123;</span>age<span class="token punctuation">&#125;</span><span class="token operator">&lt;</span><span class="token operator">/</span><span class="token keyword">if</span><span class="token operator">></span>        <span class="token operator">&lt;</span><span class="token operator">/</span>set<span class="token operator">></span>        where            user_id <span class="token operator">=</span> #<span class="token punctuation">&#123;</span>userId<span class="token punctuation">&#125;</span>    <span class="token operator">&lt;</span><span class="token operator">/</span>update<span class="token operator">></span>    <span class="token operator">&lt;</span><span class="token keyword">delete</span> id<span class="token operator">=</span><span class="token string">"deleteUser"</span><span class="token operator">></span>        <span class="token constant">DELETE</span> <span class="token constant">FROM</span>            tb_user        <span class="token constant">WHERE</span>            user_id <span class="token operator">=</span> #<span class="token punctuation">&#123;</span>userId<span class="token punctuation">&#125;</span>    <span class="token operator">&lt;</span><span class="token operator">/</span><span class="token keyword">delete</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>mapper<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre><code>&lt;mapper namespace=&quot;com.example.demo.dao.UserDao&quot;&gt; //添加UserDao的命名空间，引入UserDao</code></pre><ul><li>添加增删改查等5个方法的SQL语句</li></ul><h4 id="编写controller文件"><a href="#编写controller文件" class="headerlink" title="编写controller文件"></a>编写controller文件</h4><p>在项目目录下新建一个名为controller的package，在包内新建一个UserController的class文件，用于web的控制器</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">package</span> com<span class="token punctuation">.</span>example<span class="token punctuation">.</span>demo<span class="token punctuation">.</span>controller<span class="token punctuation">;</span><span class="token keyword">import</span> com<span class="token punctuation">.</span>example<span class="token punctuation">.</span>demo<span class="token punctuation">.</span>entity<span class="token punctuation">.</span>User<span class="token punctuation">;</span><span class="token keyword">import</span> com<span class="token punctuation">.</span>example<span class="token punctuation">.</span>demo<span class="token punctuation">.</span>service<span class="token punctuation">.</span>UserService<span class="token punctuation">;</span><span class="token keyword">import</span> com<span class="token punctuation">.</span>fasterxml<span class="token punctuation">.</span>jackson<span class="token punctuation">.</span>core<span class="token punctuation">.</span>JsonParseException<span class="token punctuation">;</span><span class="token keyword">import</span> com<span class="token punctuation">.</span>fasterxml<span class="token punctuation">.</span>jackson<span class="token punctuation">.</span>databind<span class="token punctuation">.</span>JsonMappingException<span class="token punctuation">;</span><span class="token keyword">import</span> io<span class="token punctuation">.</span>swagger<span class="token punctuation">.</span>annotations<span class="token punctuation">.</span>Api<span class="token punctuation">;</span><span class="token keyword">import</span> io<span class="token punctuation">.</span>swagger<span class="token punctuation">.</span>annotations<span class="token punctuation">.</span>ApiOperation<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>beans<span class="token punctuation">.</span>factory<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>Autowired<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>web<span class="token punctuation">.</span>bind<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>RequestBody<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>web<span class="token punctuation">.</span>bind<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>RequestMapping<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>web<span class="token punctuation">.</span>bind<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>RequestMethod<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>web<span class="token punctuation">.</span>bind<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>RestController<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>io<span class="token punctuation">.</span>IOException<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>HashMap<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>List<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>Map<span class="token punctuation">;</span>@RestController@<span class="token function">Api</span><span class="token punctuation">(</span>tags <span class="token operator">=</span> <span class="token string">"商品API"</span><span class="token punctuation">)</span> <span class="token comment">// 类文档显示内容</span>@<span class="token function">RequestMapping</span><span class="token punctuation">(</span><span class="token string">"/admin"</span><span class="token punctuation">)</span>   <span class="token comment">//地址映射的注解</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">UserController</span> <span class="token punctuation">&#123;</span>    @Autowired    <span class="token keyword">private</span> UserService userService<span class="token punctuation">;</span>    <span class="token comment">/**     * 获取用户列表     * @return     */</span>    @<span class="token function">ApiOperation</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">"获取用户列表信息"</span><span class="token punctuation">)</span> <span class="token comment">// 接口文档显示内容</span>    @<span class="token function">RequestMapping</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">"listuser"</span><span class="token punctuation">,</span>method <span class="token operator">=</span> RequestMethod<span class="token punctuation">.</span><span class="token constant">GET</span><span class="token punctuation">)</span>    <span class="token keyword">private</span> Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span>Object<span class="token operator">></span> <span class="token function">listUser</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span>Object<span class="token operator">></span> modelMap <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span>String<span class="token punctuation">,</span>Object<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        List<span class="token operator">&lt;</span>User<span class="token operator">></span> list <span class="token operator">=</span> userService<span class="token punctuation">.</span><span class="token function">getUserList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        modelMap<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"userList"</span><span class="token punctuation">,</span>list<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> modelMap<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">/**     * 通过用户Id获取用户信息     *     * @return     */</span>    @<span class="token function">ApiOperation</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">"通过用户Id获取用户信息"</span><span class="token punctuation">)</span> <span class="token comment">// 接口文档显示内容</span>    @<span class="token function">RequestMapping</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">"/getuserbyid"</span><span class="token punctuation">,</span> method <span class="token operator">=</span> RequestMethod<span class="token punctuation">.</span><span class="token constant">GET</span><span class="token punctuation">)</span>    <span class="token keyword">private</span> Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Object<span class="token operator">></span> <span class="token function">getUserById</span><span class="token punctuation">(</span><span class="token parameter">Integer userId</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Object<span class="token operator">></span> modelMap <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Object<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 获取用户信息</span>        User user <span class="token operator">=</span> userService<span class="token punctuation">.</span><span class="token function">getUserById</span><span class="token punctuation">(</span>userId<span class="token punctuation">)</span><span class="token punctuation">;</span>        modelMap<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"user"</span><span class="token punctuation">,</span> user<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> modelMap<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">/**     * 添加用户信息     *     * @param userStr     * @param request     * @return     * @throws IOException     * @throws JsonMappingException     * @throws JsonParseException     */</span>    @<span class="token function">ApiOperation</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">"添加用户信息"</span><span class="token punctuation">)</span> <span class="token comment">// 接口文档显示内容</span>    @<span class="token function">RequestMapping</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">"/adduser"</span><span class="token punctuation">,</span> method <span class="token operator">=</span> RequestMethod<span class="token punctuation">.</span><span class="token constant">POST</span><span class="token punctuation">)</span>    <span class="token keyword">private</span> Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span>Object<span class="token operator">></span> <span class="token function">addUser</span><span class="token punctuation">(</span>@RequestBody User user<span class="token punctuation">)</span>            throws JsonParseException<span class="token punctuation">,</span> JsonMappingException<span class="token punctuation">,</span> IOException <span class="token punctuation">&#123;</span>        Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Object<span class="token operator">></span> modelMap <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Object<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        modelMap<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"success"</span><span class="token punctuation">,</span> userService<span class="token punctuation">.</span><span class="token function">addUser</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> modelMap<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">/**     * 修改用户信息     *     * @param userStr     * @param request     * @return     * @throws IOException     * @throws JsonMappingException     * @throws JsonParseException     */</span>    @<span class="token function">ApiOperation</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">"修改用户信息"</span><span class="token punctuation">)</span> <span class="token comment">// 接口文档显示内容</span>    @<span class="token function">RequestMapping</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">"/modifyuser"</span><span class="token punctuation">,</span> method <span class="token operator">=</span> RequestMethod<span class="token punctuation">.</span><span class="token constant">POST</span><span class="token punctuation">)</span>    <span class="token keyword">private</span> Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Object<span class="token operator">></span> <span class="token function">modifyUser</span><span class="token punctuation">(</span>@RequestBody User user<span class="token punctuation">)</span>            throws JsonParseException<span class="token punctuation">,</span> JsonMappingException<span class="token punctuation">,</span> IOException <span class="token punctuation">&#123;</span>        Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Object<span class="token operator">></span> modelMap <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Object<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        modelMap<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"success"</span><span class="token punctuation">,</span> userService<span class="token punctuation">.</span><span class="token function">modifyUser</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> modelMap<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">/**     * 删除用户信息     * @param userId     * @return     */</span>    @<span class="token function">ApiOperation</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">"删除用户信息"</span><span class="token punctuation">)</span> <span class="token comment">// 接口文档显示内容</span>    @<span class="token function">RequestMapping</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">"/removeuser"</span><span class="token punctuation">,</span> method <span class="token operator">=</span> RequestMethod<span class="token punctuation">.</span><span class="token constant">GET</span><span class="token punctuation">)</span>    <span class="token keyword">private</span> Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Object<span class="token operator">></span> <span class="token function">removeUser</span><span class="token punctuation">(</span><span class="token parameter">Integer userId</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Object<span class="token operator">></span> modelMap <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Object<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        modelMap<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"success"</span><span class="token punctuation">,</span> userService<span class="token punctuation">.</span><span class="token function">deleteUser</span><span class="token punctuation">(</span>userId<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> modelMap<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="编写handler文件，用于统一异常处理"><a href="#编写handler文件，用于统一异常处理" class="headerlink" title="编写handler文件，用于统一异常处理"></a>编写handler文件，用于统一异常处理</h4><ul><li>在项目目录下新建一个名为handler的package，在包内新建一个GlobalExceptionHandler的class文件，用于统一异常处理</li></ul><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">package</span> com<span class="token punctuation">.</span>example<span class="token punctuation">.</span>demo<span class="token punctuation">.</span>handler<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>web<span class="token punctuation">.</span>bind<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>ControllerAdvice<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>web<span class="token punctuation">.</span>bind<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>ExceptionHandler<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>web<span class="token punctuation">.</span>bind<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>ResponseBody<span class="token punctuation">;</span><span class="token keyword">import</span> javax<span class="token punctuation">.</span>servlet<span class="token punctuation">.</span>http<span class="token punctuation">.</span>HttpServletRequest<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>HashMap<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>Map<span class="token punctuation">;</span>@ControllerAdvice<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">GlobalExceptionHandler</span> <span class="token punctuation">&#123;</span>    @<span class="token function">ExceptionHandler</span><span class="token punctuation">(</span>value <span class="token operator">=</span> Exception<span class="token punctuation">.</span>class<span class="token punctuation">)</span>    @ResponseBody    <span class="token keyword">public</span> Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Object<span class="token operator">></span> <span class="token function">exceptionHandler</span><span class="token punctuation">(</span>HttpServletRequest req<span class="token punctuation">,</span> Exception e<span class="token punctuation">)</span> throws Exception <span class="token punctuation">&#123;</span>        Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Object<span class="token operator">></span> modelMap <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Object<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        modelMap<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"success"</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        modelMap<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"errMsg"</span><span class="token punctuation">,</span> e<span class="token punctuation">.</span><span class="token function">getMessage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> modelMap<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul><li>项目到这里基本就完成了springboot+muybatis的整合，实现对数据库的增删改查等接口的功能，下一篇将为大家描述整合Swagger2组件进行自动化测试和生成API文档。</li><li><a href="https://blog.csdn.net/upstream480/article/details/113575440">SpringBoot+Mybatis+Swagger2整合(下)</a></li></ul><ul><li><a href="https://github.com/stream1080/springboot-mybatis-swagger2">Github项目源码</a></li><li><a href="https://gitee.com/stream1080/springboot-mybatis-swagger2">Gitee项目源码</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring Boot </tag>
            
            <tag> MyBatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git安装配置</title>
      <link href="/posts/304.html"/>
      <url>/posts/304.html</url>
      
        <content type="html"><![CDATA[<h1 id="Git使用指南"><a href="#Git使用指南" class="headerlink" title="Git使用指南"></a>Git使用指南</h1><h2 id="安装Git"><a href="#安装Git" class="headerlink" title="安装Git"></a>安装Git</h2><p>安装很简单，直接在网上搜索Git，选择合适的平台和版本，下载安装包。一路回车安装完成即可，没有什么难度。<br><img src="https://img-blog.csdnimg.cn/20210130213233579.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Vwc3RyZWFtNDgw,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><h2 id="注册GitHub或者Gitee"><a href="#注册GitHub或者Gitee" class="headerlink" title="注册GitHub或者Gitee"></a>注册GitHub或者Gitee</h2><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">GitHub：https<span class="token operator">:</span><span class="token operator">/</span><span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">github.com</span><span class="token regex-delimiter">/</span></span>gitee：https<span class="token operator">:</span><span class="token operator">/</span><span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">gitee.com</span><span class="token regex-delimiter">/</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>注册很简单，直接在官网注册，填写账户和邮箱信息，中间需要验证邮箱信息。<br>github和gitee两者的功能基本一直，国内访问 Github 速度比较慢，很影响我们的使用。<br>如果你希望体验到 Git 飞一般的速度，可以使用国内的 Git 托管服务——Gitee（gitee.com）。</p><p>Gitee 提供免费的 Git 仓库，还集成了代码质量检测、项目演示等功能。对于团队协作开发，Gitee 还提供了项目管理、代码托管、文档管理的服务，5 人以下小团队免费。</p><h2 id="上传Git公钥"><a href="#上传Git公钥" class="headerlink" title="上传Git公钥"></a>上传Git公钥</h2><p>由于你的本地 Git 仓库和 GitHub 仓库之间的传输是通过SSH加密的，所以我们需要配置验证信息：<br>打开本地安装的Git，使用以下命令生成 SSH Key：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">$ ssh<span class="token operator">-</span>keygen <span class="token operator">-</span>t rsa <span class="token operator">-</span><span class="token constant">C</span> <span class="token string">"youremail@example.com"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><a href="mailto:&#121;&#x6f;&#117;&#x72;&#101;&#109;&#x61;&#105;&#x6c;&#64;&#101;&#120;&#97;&#x6d;&#112;&#x6c;&#x65;&#x2e;&#99;&#111;&#109;">&#121;&#x6f;&#117;&#x72;&#101;&#109;&#x61;&#105;&#x6c;&#64;&#101;&#120;&#97;&#x6d;&#112;&#x6c;&#x65;&#x2e;&#99;&#111;&#109;</a>是你注册Github或者Gitee的邮箱。<br>然后到C盘用户根目录下的.ssh文件下即可找到刚刚生成的公钥和私钥<br>目录：C:\Users\用户名.ssh<br><img src="https://img-blog.csdnimg.cn/20210130214021521.png#pic_center" alt="在这里插入图片描述"><br>id_rsa：生成的私钥，这个不需要上传<br>id_rsa.pub：这是生成的公钥，外面需要把里面的内容复制到Github或者Gitee上面<br>下面以Gitee为例：点击gitee的用户头像，点击设置<br><img src="https://img-blog.csdnimg.cn/20210130214446464.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Vwc3RyZWFtNDgw,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>找到左边一栏的SSH公钥，标题可以随便写，只是用来做标记的。<br>公钥栏就把刚刚id_rsq.pub文件里面的内容粘贴上去即可。<br>点击确认后需要验证用户登录<br><img src="https://img-blog.csdnimg.cn/20210130214540395.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Vwc3RyZWFtNDgw,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>验证结果<br><img src="https://img-blog.csdnimg.cn/20210130215311539.png" alt="在这里插入图片描述"></p><h2 id="创建仓库"><a href="#创建仓库" class="headerlink" title="创建仓库"></a>创建仓库</h2><ol><li>以gitee为例，在首页上面点击“+”，新建仓库<br><img src="https://img-blog.csdnimg.cn/20210131120546636.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Vwc3RyZWFtNDgw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li><li>输入仓库名称和仓库路径，也可以完善其他信息，比如，仓库介绍，开源协议，语言等。之后点击创建<br><img src="https://img-blog.csdnimg.cn/20210131121036282.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Vwc3RyZWFtNDgw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li><li>创建完成后我们可以看到gitee给出的基本配置步骤，我们后面就按照这个步骤来配置仓库和提交项目<br><img src="https://img-blog.csdnimg.cn/20210131123202838.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Vwc3RyZWFtNDgw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li><li>配置过程我们需要使用到一个SSH地址<br><img src="https://img-blog.csdnimg.cn/20210131123321311.png" alt="在这里插入图片描述"></li></ol><h2 id="配置仓库"><a href="#配置仓库" class="headerlink" title="配置仓库"></a>配置仓库</h2><ol><li>在电脑上你的一个存放项目的目录中，右键鼠标点击Git Bash Here，配置仓库的用户名和邮箱地址，在控制台中输入以下命令：</li></ol><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">git config <span class="token operator">--</span>global user<span class="token punctuation">.</span>name <span class="token string">"stream1080"</span>git config <span class="token operator">--</span>global user<span class="token punctuation">.</span>email <span class="token string">"youemail@examplemail.com"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ol start="2"><li>在本地创建本地仓库</li></ol><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">//创建test目录文件</span>mkdir test<span class="token comment">//进入test目录</span>cd test<span class="token comment">//初始化仓库，让test，目录变成一个git仓库</span>git init<span class="token comment">//创建README.md文件</span>touch <span class="token constant">README</span><span class="token punctuation">.</span>md<span class="token comment">//将README.md文件加入到暂存区</span>git add <span class="token constant">README</span><span class="token punctuation">.</span>md<span class="token comment">//设置提交标题，可以是修改的内容标题</span>git commit <span class="token operator">-</span>m <span class="token string">"first commit"</span><span class="token comment">//提交到远程仓库Gitee</span>git remote add origin git@gitee<span class="token punctuation">.</span>com<span class="token operator">:</span>stream1080<span class="token operator">/</span>test<span class="token punctuation">.</span>gitgit push <span class="token operator">-</span>u origin master<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="3"><li>设置演示截图<br><img src="https://img-blog.csdnimg.cn/20210131124635579.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Vwc3RyZWFtNDgw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li><li>提交成功<br><img src="https://img-blog.csdnimg.cn/20210131124845711.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Vwc3RyZWFtNDgw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li><li>检查远程仓库gitee<br><img src="https://img-blog.csdnimg.cn/20210131124917267.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Vwc3RyZWFtNDgw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><h2 id="二次提交"><a href="#二次提交" class="headerlink" title="二次提交"></a>二次提交</h2>创建好仓库后，我们常常需要多次修改代码，完善后再次提交<br>这次我们演示一下修改后如何二次提交</li><li>修改README.md的内容<br><img src="https://img-blog.csdnimg.cn/20210131130531679.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Vwc3RyZWFtNDgw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li><li>提交到远程仓库</li></ol><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">//查看项目中哪些文件发生了变化</span>git status <span class="token comment">//将所有变更文件添加进来</span>git add <span class="token punctuation">.</span> <span class="token comment">//这个时候文件都变成了  modified:   README.md</span>git status <span class="token comment">//标记为第二次提交</span>git commit <span class="token operator">-</span>m <span class="token string">'第二次提交'</span><span class="token comment">//把本地的推送到远程的分支上面即可</span>git push <span class="token comment">//查看结果，已经没用变化的文件了</span>git status  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://img-blog.csdnimg.cn/20210131131959342.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Vwc3RyZWFtNDgw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>微信小程序授权登录</title>
      <link href="/posts/33717.html"/>
      <url>/posts/33717.html</url>
      
        <content type="html"><![CDATA[<h1 id="微信小程序授权登录"><a href="#微信小程序授权登录" class="headerlink" title="微信小程序授权登录"></a>微信小程序授权登录</h1><h2 id="先看微信官方文档如何描述微信小程序的登录"><a href="#先看微信官方文档如何描述微信小程序的登录" class="headerlink" title="先看微信官方文档如何描述微信小程序的登录"></a>先看微信官方文档如何描述微信小程序的登录</h2><p><img src="https://img-blog.csdnimg.cn/20210129222448216.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Vwc3RyZWFtNDgw,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><h4 id="基本步骤如下"><a href="#基本步骤如下" class="headerlink" title="基本步骤如下"></a>基本步骤如下</h4><ol><li><p>小程序调用wx.login接口获取临时登录凭证code，这个code只存在5分钟</p></li><li><p>通过wx.request接口，将临时登录凭证传送到后台服务器code</p></li><li><p>后台服务器接收到前端传送过来的code，整合小程序AppID，AppSecret(小程序密钥)和 “grant_type=authorization_code”。携带这些数据请求auth.code2Session 接口，换取 用户唯一标识 OpenID 和 会话密钥 session_key。请求地址为：<a href="https://api.weixin.qq.com/sns/jscode2session?appid=APPID&amp;secret=SECRET&amp;js_code=JSCODE&amp;grant_type=authorization_code%E3%80%82%E8%AF%B7%E6%B1%82%E6%96%B9%E5%BC%8F%E4%B8%BAGET%E3%80%82!%5B%E5%9C%A8%E8%BF%99%E9%87%8C%E6%8F%92%E5%85%A5%E5%9B%BE%E7%89%87%E6%8F%8F%E8%BF%B0%5D(https://img-blog.csdnimg.cn/20210129223439718.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Vwc3RyZWFtNDgw,size_16,color_FFFFFF,t_70#pic_center)">https://api.weixin.qq.com/sns/jscode2session?appid=APPID&amp;secret=SECRET&amp;js_code=JSCODE&amp;grant_type=authorization_code。请求方式为GET。![在这里插入图片描述](https://img-blog.csdnimg.cn/20210129223439718.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Vwc3RyZWFtNDgw,size_16,color_FFFFFF,t_70#pic_center)</a></p></li><li><p>微信服务器接收后端服务器发送的appid、appsecret、code进行校验。校验通过后向开发者服务器发送session_key、openid。</p></li><li><p>后端服务器接收到微信服务器传送过来的session_key、openid后，自定义用户登录的状态，并反馈到前端。</p></li></ol><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h4 id="方法一：仅在前端实现（不推荐，因为不安全）"><a href="#方法一：仅在前端实现（不推荐，因为不安全）" class="headerlink" title="方法一：仅在前端实现（不推荐，因为不安全）"></a>方法一：仅在前端实现（不推荐，因为不安全）</h4><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token function-variable function">dologin</span><span class="token operator">:</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    wx<span class="token punctuation">.</span><span class="token function">login</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>      <span class="token function">success</span> <span class="token punctuation">(</span><span class="token parameter">res</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token comment">//保存用户信息</span>app<span class="token punctuation">.</span>globalData<span class="token punctuation">.</span>userInfo <span class="token operator">=</span> res<span class="token punctuation">.</span>detail<span class="token punctuation">.</span>userInfo        <span class="token keyword">if</span> <span class="token punctuation">(</span>res<span class="token punctuation">.</span>code<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                  <span class="token comment">//发起网络请求</span>          wx<span class="token punctuation">.</span><span class="token function">request</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>            url<span class="token operator">:</span> <span class="token string">'https://api.weixin.qq.com/sns/jscode2session'</span><span class="token punctuation">,</span>            method<span class="token operator">:</span> <span class="token string">"GET"</span><span class="token punctuation">,</span>            data<span class="token operator">:</span> <span class="token punctuation">&#123;</span>              appid<span class="token operator">:</span><span class="token string">'wxxxxxxxxx'</span><span class="token punctuation">,</span>              secret<span class="token operator">:</span><span class="token string">'xxxxxxxxxxxxxxxxxxxxx'</span><span class="token punctuation">,</span>              js_code<span class="token operator">:</span> res<span class="token punctuation">.</span>code<span class="token punctuation">,</span>              grant_type<span class="token operator">:</span> <span class="token string">'authorization_code'</span>            <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>            <span class="token function-variable function">success</span><span class="token operator">:</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">result</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>              console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span>              <span class="token comment">//返回的openID和session_key</span>            <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>          <span class="token punctuation">&#125;</span><span class="token punctuation">)</span>          wx<span class="token punctuation">.</span><span class="token function">switchTab</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>            url<span class="token operator">:</span> <span class="token string">'../person/person'</span><span class="token punctuation">,</span>          <span class="token punctuation">&#125;</span><span class="token punctuation">)</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>          console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'登录失败！'</span> <span class="token operator">+</span> res<span class="token punctuation">.</span>errMsg<span class="token punctuation">)</span>        <span class="token punctuation">&#125;</span>      <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">)</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="方法二：后端SprinBoot实现"><a href="#方法二：后端SprinBoot实现" class="headerlink" title="方法二：后端SprinBoot实现"></a>方法二：后端SprinBoot实现</h4><p>。。。</p>]]></content>
      
      
      <categories>
          
          <category> 项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 微信小程序 </tag>
            
            <tag> 登录 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>猴子选大王和纸牌游戏</title>
      <link href="/posts/61103.html"/>
      <url>/posts/61103.html</url>
      
        <content type="html"><![CDATA[<h1 id="1-猴子选大王"><a href="#1-猴子选大王" class="headerlink" title="1.猴子选大王"></a>1.猴子选大王</h1><p>一堆猴子都有编号，编号是1，2，3 …m ,这群猴子（m个）按照1-m的顺序围坐一圈，从第1开始数，每数到第N个，该猴子就要离开此圈，这样依次下来，直到圈中只剩下最后一只猴子，则该猴子为大王。</p><h2 id="要求"><a href="#要求" class="headerlink" title="要求"></a>要求</h2><p>输入数据：输入m,n m,n 为整数，n&lt;m<br>输出形式：中文提示按照m个猴子，数n 个数的方法，输出为大王的猴子是几号 ，建立一个函数来实现此功能 </p><h2 id="数据结构设计"><a href="#数据结构设计" class="headerlink" title="数据结构设计"></a>数据结构设计</h2><p>设计一个循环的单链表，使其可以一直循环数数，每数到N个即删除节点，最后留下了的即为大王</p><pre class="line-numbers language-none"><code class="language-none">typedef struct LNode   &#123; int data; struct LNode *next;&#125;LinkNode;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="流程设计"><a href="#流程设计" class="headerlink" title="流程设计"></a>流程设计</h2><p><img src="https://img-blog.csdnimg.cn/20200704215455320.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Vwc3RyZWFtNDgw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ol><li>输入猴子个数m和间隔数n</li><li>判断m，n是否合法，非法则重新输入，合法进入下一步</li><li>建立一个带头节点的循环单链表，代表m个猴子围坐一圈</li><li>遍历循环单链表，数到n的猴子退出，删除节点。重新计数</li><li>当循环单链表中只剩下一只猴子是，即为大王。</li><li>若输入的n为1，猴子依次退出，最后一个为大王</li></ol><h2 id="主要代码"><a href="#主要代码" class="headerlink" title="主要代码"></a>主要代码</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//设计一个循环单链表模拟猴子围坐在一圈</span><span class="token comment">//数到的猴子退出，删除节点</span><span class="token comment">//只剩下一个猴子时，即为大王 </span><span class="token keyword">int</span> <span class="token function">SelectKing</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span> <span class="token keyword">int</span> m<span class="token punctuation">,</span>n<span class="token punctuation">,</span>i<span class="token punctuation">;</span><span class="token comment">//i为当前数到的数 </span>  <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>  <span class="token punctuation">&#123;</span>   <span class="token function">system</span><span class="token punctuation">(</span><span class="token string">"cls"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  cout<span class="token operator">&lt;&lt;</span>endl<span class="token operator">&lt;&lt;</span><span class="token string">"请输入猴子个数m(m为正整数)："</span><span class="token punctuation">;</span>  cin<span class="token operator">>></span>m<span class="token punctuation">;</span>  cout<span class="token operator">&lt;&lt;</span>endl<span class="token operator">&lt;&lt;</span><span class="token string">"输入间隔数n(n为正整数且m>n): "</span><span class="token punctuation">;</span>  cin<span class="token operator">>></span>n<span class="token punctuation">;</span>  <span class="token keyword">if</span><span class="token punctuation">(</span>m<span class="token operator">></span><span class="token number">0</span> <span class="token operator">&amp;&amp;</span> n<span class="token operator">></span><span class="token number">0</span> <span class="token operator">&amp;&amp;</span> m<span class="token operator">></span>n<span class="token punctuation">)</span>    <span class="token keyword">break</span><span class="token punctuation">;</span>   <span class="token keyword">else</span>          <span class="token comment">//异常处理</span>   cout<span class="token operator">&lt;&lt;</span>endl<span class="token operator">&lt;&lt;</span><span class="token string">"输入错误，请重新输入"</span><span class="token operator">&lt;&lt;</span>endl<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>   <span class="token function">system</span><span class="token punctuation">(</span><span class="token string">"pause"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>  LinkNode <span class="token operator">*</span>s<span class="token punctuation">,</span><span class="token operator">*</span>r<span class="token punctuation">,</span><span class="token operator">*</span>p<span class="token punctuation">,</span><span class="token operator">*</span>L<span class="token punctuation">;</span> LNode <span class="token operator">*</span>q<span class="token punctuation">;</span> L <span class="token operator">=</span> <span class="token keyword">new</span><span class="token punctuation">(</span>LinkNode<span class="token punctuation">)</span><span class="token punctuation">;</span> r <span class="token operator">=</span> L<span class="token punctuation">;</span> <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>m<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  s <span class="token operator">=</span> <span class="token keyword">new</span><span class="token punctuation">(</span>LinkNode<span class="token punctuation">)</span><span class="token punctuation">;</span>  s<span class="token operator">-></span>data <span class="token operator">=</span> i<span class="token punctuation">;</span>  r<span class="token operator">-></span>next <span class="token operator">=</span> s<span class="token punctuation">;</span>  r <span class="token operator">=</span> s<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span>  r<span class="token operator">-></span>next <span class="token operator">=</span> L<span class="token operator">-></span>next<span class="token punctuation">;</span> <span class="token comment">//创建循环单链表 </span>  p <span class="token operator">=</span> L<span class="token operator">-></span>next<span class="token punctuation">;</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">if</span><span class="token punctuation">(</span>i <span class="token operator">==</span> n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token comment">//数到n的猴子退出 </span>  <span class="token punctuation">&#123;</span>   q <span class="token operator">=</span> p<span class="token operator">-></span>next<span class="token punctuation">;</span>   p<span class="token operator">-></span>next <span class="token operator">=</span> q<span class="token operator">-></span>next<span class="token punctuation">;</span>   cout<span class="token operator">&lt;&lt;</span>endl<span class="token operator">&lt;&lt;</span><span class="token string">"   第"</span><span class="token operator">&lt;&lt;</span>q<span class="token operator">-></span>data<span class="token operator">&lt;&lt;</span><span class="token string">"个猴子退出,还剩"</span><span class="token operator">&lt;&lt;</span>m<span class="token operator">-</span><span class="token number">1</span><span class="token operator">&lt;&lt;</span><span class="token string">"个猴子"</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>    <span class="token keyword">delete</span> q<span class="token punctuation">;</span>    <span class="token comment">//猴子退出，删除节点 </span>   i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>   m<span class="token operator">--</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">if</span><span class="token punctuation">(</span>n<span class="token operator">==</span><span class="token number">1</span><span class="token punctuation">)</span>  <span class="token comment">//间隔数为1时，猴子依次退出，最后一个即为大王 </span>  <span class="token punctuation">&#123;</span>   cout<span class="token operator">&lt;&lt;</span>endl<span class="token operator">&lt;&lt;</span><span class="token string">"   第"</span><span class="token operator">&lt;&lt;</span>p<span class="token operator">-></span>data<span class="token operator">&lt;&lt;</span><span class="token string">"个猴子退出,还剩"</span><span class="token operator">&lt;&lt;</span>m<span class="token operator">-</span><span class="token number">1</span><span class="token operator">&lt;&lt;</span><span class="token string">"个猴子"</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>    <span class="token keyword">delete</span> q<span class="token punctuation">;</span>     <span class="token comment">//猴子退出，删除节点 </span>   i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>   m<span class="token operator">--</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>   i<span class="token operator">++</span><span class="token punctuation">;</span>  p <span class="token operator">=</span> p<span class="token operator">-></span>next<span class="token punctuation">;</span>  <span class="token keyword">if</span><span class="token punctuation">(</span>m<span class="token operator">==</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token comment">//链表中只剩下一个猴子即为大王 </span>  <span class="token punctuation">&#123;</span>   cout<span class="token operator">&lt;&lt;</span>endl<span class="token operator">&lt;&lt;</span><span class="token string">" 选出第"</span><span class="token operator">&lt;&lt;</span>p<span class="token operator">-></span>data<span class="token operator">&lt;&lt;</span><span class="token string">"个猴子为大王"</span><span class="token operator">&lt;&lt;</span>endl<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>   <span class="token keyword">break</span><span class="token punctuation">;</span>     <span class="token comment">//选出大王，退出循环 </span>  <span class="token punctuation">&#125;</span> <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h2><p><img src="https://img-blog.csdnimg.cn/20200704220158545.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Vwc3RyZWFtNDgw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h1 id="2-纸牌游戏"><a href="#2-纸牌游戏" class="headerlink" title="2.纸牌游戏"></a>2.纸牌游戏</h1><p>编号为1-52张牌，正面向上，从第2张开始，以2为基数，是2的倍数的牌翻一次，直到最后一张牌；然后，从第3张开始，以3为基数，是3的倍数的牌翻一次，直到最后一张牌；然后…从第4张开始，以4为基数，是4的倍数的牌翻一次， 直到最后一张牌；…再依次5的倍数的牌翻一次，6的，7的 直到 以52为基数的 翻过，输出：这时正面向上的牌有哪些？</p><h2 id="数据结构设计-1"><a href="#数据结构设计-1" class="headerlink" title="数据结构设计"></a>数据结构设计</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//设计一个长度为53的线性表，丢弃0节点</span><span class="token comment">//1表示正面向上，0表示正面向下 </span><span class="token keyword">typedef</span> <span class="token keyword">struct</span><span class="token punctuation">&#123;</span> <span class="token keyword">int</span> data<span class="token punctuation">[</span><span class="token number">53</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">int</span> lenght<span class="token punctuation">;</span><span class="token punctuation">&#125;</span>Sqlist<span class="token punctuation">;</span><span class="token comment">//把牌翻一次 </span><span class="token keyword">int</span> <span class="token function">swap</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token keyword">if</span><span class="token punctuation">(</span>i <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>  <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token keyword">else</span>  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="流程设计-1"><a href="#流程设计-1" class="headerlink" title="流程设计"></a>流程设计</h2><p><img src="https://img-blog.csdnimg.cn/20200704221856217.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Vwc3RyZWFtNDgw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ol><li>创建一个长度为53的线性表，丢弃0节点，其他的节点赋值为1，代表正面向上</li><li>编写一个翻转纸牌的函数，若纸牌为1则返回0。若纸牌为0则返回1</li><li>编写两个循环嵌套，从第二张牌开始便利，以2的倍数翻转纸牌，直到最后一张牌。从3开始遍历，以3的倍数翻转纸牌，直到一52开始，翻转到最后一张</li><li>输出正面向上的纸牌</li></ol><h2 id="程序代码"><a href="#程序代码" class="headerlink" title="程序代码"></a>程序代码</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">game</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token keyword">int</span> i<span class="token punctuation">,</span>j<span class="token punctuation">;</span> Sqlist <span class="token operator">*</span>L<span class="token punctuation">;</span> L <span class="token operator">=</span> <span class="token keyword">new</span><span class="token punctuation">(</span>Sqlist<span class="token punctuation">)</span><span class="token punctuation">;</span> L<span class="token operator">-></span>lenght <span class="token operator">=</span> <span class="token number">53</span><span class="token punctuation">;</span>  <span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>L<span class="token operator">-></span>lenght<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>   L<span class="token operator">-></span>data<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">//所有的牌赋为1表示正面向上 </span> <span class="token punctuation">&#125;</span>  <span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>L<span class="token operator">-></span>lenght<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">for</span><span class="token punctuation">(</span>j<span class="token operator">=</span>i<span class="token punctuation">;</span>j<span class="token operator">&lt;</span>L<span class="token operator">-></span>lenght<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span>   <span class="token punctuation">&#123;</span>   <span class="token keyword">if</span><span class="token punctuation">(</span>j<span class="token operator">%</span>i <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>   <span class="token punctuation">&#123;</span>    L<span class="token operator">-></span>data<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">swap</span><span class="token punctuation">(</span>L<span class="token operator">-></span>data<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//把牌翻一次 </span>   <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span> <span class="token punctuation">&#125;</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>   cout<span class="token operator">&lt;&lt;</span>endl<span class="token operator">&lt;&lt;</span><span class="token string">" 正面向上的牌有："</span><span class="token punctuation">;</span> <span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>L<span class="token operator">-></span>lenght<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token comment">//输出正面向上的牌 </span> <span class="token punctuation">&#123;</span>   <span class="token keyword">if</span><span class="token punctuation">(</span>L<span class="token operator">-></span>data<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span>  <span class="token punctuation">&#123;</span>    cout<span class="token operator">&lt;&lt;</span>i<span class="token operator">&lt;&lt;</span><span class="token string">" "</span><span class="token punctuation">;</span>   j <span class="token operator">++</span><span class="token punctuation">;</span>   <span class="token punctuation">&#125;</span> <span class="token punctuation">&#125;</span> cout<span class="token operator">&lt;&lt;</span>endl<span class="token operator">&lt;&lt;</span>endl<span class="token operator">&lt;&lt;</span><span class="token string">"     一共有 "</span><span class="token operator">&lt;&lt;</span>j<span class="token operator">&lt;&lt;</span><span class="token string">" 张正面向上的牌"</span><span class="token operator">&lt;&lt;</span>endl<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="测试结果-1"><a href="#测试结果-1" class="headerlink" title="测试结果"></a>测试结果</h2><p><img src="https://img-blog.csdnimg.cn/20200704222415802.png" alt="在这里插入图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>直接插入排序和冒泡排序改进算法</title>
      <link href="/posts/51280.html"/>
      <url>/posts/51280.html</url>
      
        <content type="html"><![CDATA[<h1 id="直接插入排序"><a href="#直接插入排序" class="headerlink" title="直接插入排序"></a>直接插入排序</h1><ol><li><p>插入排序的基本方法是：每一步都将待排序的元素，插入到前面已经排好序的一组元素的适当位置上去，直到元素全部插入为止。        </p></li><li><p>直接插入排序基本思想：将一个元素插入到已排好序的序列中，从而得到一个新的有序序列（将序列的第一个数据看成是一个有序的子序列，然后从第二个记录逐个向该有序的子序列进行有序的插入，直至整个序列有序）</p></li><li><p>直接插入排序是由两层嵌套循环组成的。外层循环标识并决定待比较的数值。内层循环为待比较数值确定其最终位置。直接插入排序是将待比较的数值与它的前一个数值进行比较，所以外层循环是从第二个数值开始的。当前一数值比待比较数值大的情况下继续循环比较，直到找到比待比较数值小的并将待比较数值置入其后一位置，结束该次循环。      </p></li></ol><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">if</span><span class="token punctuation">(</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">&lt;</span>s<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>  <span class="token punctuation">&#123;</span>   temp <span class="token operator">=</span> s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>   j <span class="token operator">=</span> i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>       <span class="token keyword">while</span><span class="token punctuation">(</span>j<span class="token operator">>=</span><span class="token number">0</span> <span class="token operator">&amp;&amp;</span> s<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">></span>temp<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>    s<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">=</span>s<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>    j<span class="token operator">--</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>   s<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span>   <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="复杂的分析"><a href="#复杂的分析" class="headerlink" title="复杂的分析"></a>复杂的分析</h2><p>时间复杂度：O(n^)<br>空间复杂度：O(1)</p><h1 id="改进冒泡排序"><a href="#改进冒泡排序" class="headerlink" title="改进冒泡排序"></a>改进冒泡排序</h1><ol><li>如果已经是有序的数列，就不要再进行排序，及时终止，进入下一次排序，可以提高冒泡排序的时间复杂度</li><li>用两个循环嵌套进行两两比较，用一个false标记无序，进入一层循环，若标记为true，则表示有序，不用进行比较</li></ol><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">bool</span> flag <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>  <span class="token comment">//用flag标记已经排好的元素 </span> <span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">(</span>i<span class="token operator">&lt;</span>n<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>flag <span class="token operator">==</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  flag <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>  <span class="token keyword">for</span><span class="token punctuation">(</span>j<span class="token operator">=</span>n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>j<span class="token operator">></span>i<span class="token punctuation">;</span>j<span class="token operator">--</span><span class="token punctuation">)</span>  <span class="token punctuation">&#123;</span>   <span class="token keyword">if</span><span class="token punctuation">(</span>s<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;</span> s<span class="token punctuation">[</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>   <span class="token punctuation">&#123;</span>    temp   <span class="token operator">=</span> s<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>    s<span class="token punctuation">[</span>j<span class="token punctuation">]</span>   <span class="token operator">=</span> s<span class="token punctuation">[</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    s<span class="token punctuation">[</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span>     flag   <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>   <span class="token punctuation">&#125;</span>   <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="复杂的分析-1"><a href="#复杂的分析-1" class="headerlink" title="复杂的分析"></a>复杂的分析</h2><p>时间复杂度：最差O(n^2)  最好O(n)<br>空间复杂度：O(1)</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>酒店管理系统程序设计</title>
      <link href="/posts/23140.html"/>
      <url>/posts/23140.html</url>
      
        <content type="html"><![CDATA[<h1 id="酒店管理系统程序设计"><a href="#酒店管理系统程序设计" class="headerlink" title="酒店管理系统程序设计"></a>酒店管理系统程序设计</h1><p>   随着计算机技术的飞速发展，信息时代的到来，信息改变了我们这个社会。各类行业在日常经营管理各个方面也在悄悄地走向规范化和网络化。市场经济的发展，消费者消费意识的提高，酒店行业的竞争越来越激烈。为了提高办事效率，增加、保证酒店的销售额，树立酒店的良好形象，运用科学的管理方法非常必要。客房管理的信息化程度体现在将计算机及网络与信息技术应用于经营与管理，以现代化工具代替传统手工作业。无疑，使用网络信息化管理使客房管理更先进、更高效、更科学，信息交流更迅速。</p><p>   我力求开发一个界面友好，功能强大，使用简单的酒店客房管理系统。它可以完全适用于小型酒店宾馆的客房管理服务。希望通过使用酒店客房管理系统得到所需信息，达到提高客房管理水平的目的。</p><h2 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h2><ol><li>有关客房信息的制定，房间号，所在楼层，价格，以及客房状态。是否有电话，电视，空调，网络和独立卫生间，以及所提供的服务等级。</li><li>客户信息的录入和存储，包括客户的基本信息和是否为贵宾等信息等。</li><li>客房的预定登记，主要是登记房客的信息，对房客的信息进行维护。入住实际，和预定的离店时间以及已付的押金，将客房的状态标注为预定状态。</li><li>客房的入住登记，对已预定的客房进行入住操作，更新客户的实际入住时间，将客房标注为已入住的状态。</li><li>客房的退房结算，更新客户的实际离店时间，对房客的实际住店的时间进行计算，输出实际产生的消费，与预订时所付的押金进行结算，多还少补。</li><li>客房状态查询，分为四个模块，1查询当前已预定的客房，输出所有已经预定的客房和预定的客户信息，包括预定的入住和离店时间已经预交的押金；2查询当前已入住的客房，输出所有已经入住的客房和客户的信息，包括客户实际入住的时间；3查询当前空置的客房，分类显示所有空置的房间；4排序显示所有非空置的房间，输出这些客户的信息和房间信息。</li><li>系统退出时，以二进制文件将当前系统的状态和所有的用户信息，客房信息存储到本地。在启动程序时，读取存储的二进制文件，将上一次的系统状态恢复。若第一次启动，则创建二进制文件。 </li><li>系统的异常处理，对错误的输入进行处理，防止系统出现异常</li></ol><h2 id="系统功能结构"><a href="#系统功能结构" class="headerlink" title="系统功能结构"></a>系统功能结构</h2><p><img src="https://img-blog.csdnimg.cn/20200704124042764.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Vwc3RyZWFtNDgw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="简要的流程图"><a href="#简要的流程图" class="headerlink" title="简要的流程图"></a>简要的流程图</h2><p><img src="https://img-blog.csdnimg.cn/20200704125733855.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Vwc3RyZWFtNDgw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="类的定义和设计"><a href="#类的定义和设计" class="headerlink" title="类的定义和设计"></a>类的定义和设计</h2><ol><li>定义一个存储房间信息和客户信息的基类，包扩这个房间的预定，入住，结算和显示信息的方法。<br>其中预定，和显示的方法定义为虚函数，用于实现多态性。</li></ol><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Room</span><span class="token punctuation">&#123;</span>  <span class="token keyword">public</span><span class="token operator">:</span>  <span class="token function">Room</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token operator">~</span><span class="token function">Room</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">booking</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">//预定登记 </span>  <span class="token keyword">void</span> <span class="token function">checkin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//入住登记 </span>  <span class="token keyword">void</span> <span class="token function">checkout</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">//退房结算 </span>  <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">display</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>  <span class="token comment">//状态查询 </span>  <span class="token keyword">int</span> room_num<span class="token punctuation">;</span>     <span class="token comment">//房间编号</span>  <span class="token keyword">int</span> status<span class="token punctuation">;</span>         <span class="token comment">//房间状态：0.空房 1.预定 2.入住  </span>   <span class="token keyword">protected</span><span class="token operator">:</span>   <span class="token keyword">char</span> name<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment">//房客姓名 </span>  <span class="token keyword">char</span> contact<span class="token punctuation">[</span><span class="token number">11</span><span class="token punctuation">]</span><span class="token punctuation">;</span>   <span class="token comment">//联系方式</span>  <span class="token keyword">int</span> start<span class="token punctuation">;</span>   <span class="token comment">//入住时间</span>  <span class="token keyword">int</span> dead<span class="token punctuation">;</span>   <span class="token comment">//离店时间 </span>  <span class="token keyword">int</span> deposit<span class="token punctuation">;</span>  <span class="token comment">//押    金 </span>  <span class="token keyword">int</span> price<span class="token punctuation">;</span>          <span class="token comment">//价    格  </span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="2"><li>用房间的基类派生出一个标准间的派生类，加上安装电话，和安装空调两个属性，并且重载预定登记和状态查询两个方法。</li></ol><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">TwinRoom</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">Room</span>    <span class="token comment">//标准间</span></span> <span class="token punctuation">&#123;</span> <span class="token keyword">public</span><span class="token operator">:</span>  <span class="token function">TwinRoom</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token operator">~</span><span class="token function">TwinRoom</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token keyword">void</span> <span class="token function">booking</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//预定登记</span>  <span class="token keyword">void</span> <span class="token function">display</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//状态查询 </span>   <span class="token keyword">private</span><span class="token operator">:</span>   <span class="token keyword">int</span>  tel<span class="token punctuation">;</span> <span class="token comment">// 安装电话 </span>  <span class="token keyword">char</span> air<span class="token punctuation">;</span> <span class="token comment">// 安装空调</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="3"><li>用房间的基类派生出一个高级标准间的派生类，加上VIP编号，安装电话，和安装空调，电视，和无线网络属性，并且重载预定登记和状态查询两个方法。</li></ol><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//#################################################</span><span class="token keyword">class</span> <span class="token class-name">HTwinRoom</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">Room</span> <span class="token comment">//高级标间</span></span> <span class="token punctuation">&#123;</span> <span class="token keyword">public</span><span class="token operator">:</span>  <span class="token function">HTwinRoom</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token operator">~</span><span class="token function">HTwinRoom</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token keyword">void</span> <span class="token function">booking</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//预定登记 </span>  <span class="token keyword">void</span> <span class="token function">display</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//状态查询</span>   <span class="token keyword">private</span><span class="token operator">:</span>  <span class="token keyword">int</span> VIPnum<span class="token punctuation">;</span> <span class="token comment">// VIP编号 </span>  <span class="token keyword">int</span>  tel<span class="token punctuation">;</span> <span class="token comment">// 安装电话 </span>  <span class="token keyword">char</span> air<span class="token punctuation">;</span> <span class="token comment">// 安装空调 </span>  <span class="token keyword">int</span>  TV<span class="token punctuation">;</span>  <span class="token comment">// 安装电视 </span>  <span class="token keyword">int</span> wifi<span class="token punctuation">;</span>  <span class="token comment">// 无线网络 </span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="4"><li>用房间的基类派生出一个豪华套间的派生类，加上SVIP编号，安装电话，和安装空调，电视，无线网络和独立卫生间属性，并且重载预定登记和状态查询两个方法。</li></ol><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//##############################</span><span class="token keyword">class</span> <span class="token class-name">SuiteRoom</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">Room</span>   <span class="token comment">//豪华套间</span></span> <span class="token punctuation">&#123;</span> <span class="token keyword">public</span><span class="token operator">:</span>  <span class="token function">SuiteRoom</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token operator">~</span><span class="token function">SuiteRoom</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token keyword">void</span> <span class="token function">booking</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//预定登记</span>  <span class="token keyword">void</span> <span class="token function">display</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//状态查询 </span>   <span class="token keyword">private</span><span class="token operator">:</span>  <span class="token keyword">int</span> SVIPnum<span class="token punctuation">;</span><span class="token comment">// SVIP编号 </span>  <span class="token keyword">int</span>  tel<span class="token punctuation">;</span> <span class="token comment">// 安装电话 </span>  <span class="token keyword">char</span> air<span class="token punctuation">;</span> <span class="token comment">// 安装空调 </span>  <span class="token keyword">char</span> TV<span class="token punctuation">;</span>  <span class="token comment">// 安装电视 </span>  <span class="token keyword">char</span> wifi<span class="token punctuation">;</span>  <span class="token comment">// 无线网络</span>  <span class="token keyword">char</span> bath<span class="token punctuation">;</span> <span class="token comment">// 独立卫生间 </span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="其他模块设计"><a href="#其他模块设计" class="headerlink" title="其他模块设计"></a>其他模块设计</h2><ol><li><p>查询预定客房信息：用一个函数，遍历所有的的对象，把房间状态为预定的用对象的display（）方法显示出来。<br><img src="https://img-blog.csdnimg.cn/20200704131451434.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Vwc3RyZWFtNDgw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p></li><li><p>查询入住客房信息：用一个函数，遍历所有类型的的对象，把房间状态为入住的用对象的display（）方法显示出来。<br><img src="https://img-blog.csdnimg.cn/20200704131431262.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Vwc3RyZWFtNDgw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p></li><li><p>查询空置的房间：用一个函数，遍历所有类型的的对象，把房间状态为空置的，另一个函数分类显示各种类型的房间的编号。<br><img src="https://img-blog.csdnimg.cn/20200704131531290.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Vwc3RyZWFtNDgw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p></li><li><p>排序显示客房信息：用冒泡排序，以房间的编号为关键字，按递增输出所有不少空置的房间。 </p></li></ol><p>  <img src="https://img-blog.csdnimg.cn/202007041311228.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Vwc3RyZWFtNDgw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>文件存储模块中，用三个二进制的文件分别存储三种类型的客房信息，读取文件时，把文件的指针指到文件的末尾，计算出需要读取的对象的个数，用一个循环将文件中的数据读取到内存中。 存储文件时，用函数确定对象数组中的对象个数，用一个for循环将对象以二进制的方法保存到文件中。</p><p><img src="https://img-blog.csdnimg.cn/20200704131142117.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Vwc3RyZWFtNDgw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>存储文件时，用函数确定对象数组中的对象个数，用一个for循环将对象以二进制的方法保存到文件中。</p><h2 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h2><p><img src="https://img-blog.csdnimg.cn/20200704131243335.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Vwc3RyZWFtNDgw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>城市公交站点及换乘方案设计</title>
      <link href="/posts/9821.html"/>
      <url>/posts/9821.html</url>
      
        <content type="html"><![CDATA[<h1 id="城市公交站点及换乘方案设计"><a href="#城市公交站点及换乘方案设计" class="headerlink" title="城市公交站点及换乘方案设计"></a>城市公交站点及换乘方案设计</h1><h2 id="设计要求"><a href="#设计要求" class="headerlink" title="设计要求"></a>设计要求</h2><p>   城市公共交通站点，站点之间的道路，及道路长度实际构成数学意义上的无向加权图。现请设计实现一个算法，求任意两站点间最短路径距离且输出该最短路径上的每个站点，然后给一个乘车换乘方案。</p><h2 id="站点要求"><a href="#站点要求" class="headerlink" title="站点要求"></a>站点要求</h2><p><img src="https://img-blog.csdnimg.cn/20200703221859635.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Vwc3RyZWFtNDgw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="数据结构设计"><a href="#数据结构设计" class="headerlink" title="数据结构设计"></a>数据结构设计</h2><p>使用五个数组存放每条路线途径的站点</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> L1<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">11</span><span class="token punctuation">,</span><span class="token number">14</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>  <span class="token comment">// 公交1路：9个站 </span><span class="token keyword">int</span> L2<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token number">13</span><span class="token punctuation">,</span><span class="token number">17</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>  <span class="token comment">// 公交2路：7个站</span><span class="token keyword">int</span> L3<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token number">12</span><span class="token punctuation">,</span><span class="token number">15</span><span class="token punctuation">,</span><span class="token number">19</span><span class="token punctuation">,</span><span class="token number">22</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>  <span class="token comment">// 公交3路：6个站</span><span class="token keyword">int</span> L4<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token number">18</span><span class="token punctuation">,</span><span class="token number">19</span><span class="token punctuation">,</span><span class="token number">23</span><span class="token punctuation">,</span><span class="token number">24</span><span class="token punctuation">,</span><span class="token number">25</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>  <span class="token comment">// 公交4路：5个站</span><span class="token keyword">int</span> L5<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token number">13</span><span class="token punctuation">,</span><span class="token number">16</span><span class="token punctuation">,</span><span class="token number">20</span><span class="token punctuation">,</span><span class="token number">21</span><span class="token punctuation">,</span><span class="token number">25</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>  <span class="token comment">// 公交5路：5个站</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>设计两个二维数组，用于后面的Floyd算法。<br>P存放各个站点之间的最短路径，D存放各个站点之间的最短路径的权值</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//P[][]存放各个站点之间的最短路径，D[][]存放各个站点之间的最短路径的权值 </span><span class="token keyword">int</span> P<span class="token punctuation">[</span>MAXVEX<span class="token punctuation">]</span><span class="token punctuation">[</span>MAXVEX<span class="token punctuation">]</span><span class="token punctuation">,</span>D<span class="token punctuation">[</span>MAXVEX<span class="token punctuation">]</span><span class="token punctuation">[</span>MAXVEX<span class="token punctuation">]</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>图的数据结构设计，顶点设计一个数组，用于存放此顶点途径的路线。<br>如果该顶点途径路线1和路线三，则再数组下标1和3上赋值1，3，不途径的赋值为零，如下图。</p><p><img src="https://img-blog.csdnimg.cn/20200703223952538.png" alt="在这里插入图片描述"></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">typedef</span> <span class="token keyword">struct</span><span class="token punctuation">&#123;</span> <span class="token keyword">int</span> name<span class="token punctuation">;</span>  <span class="token comment">//站点名称 </span> <span class="token keyword">int</span> lines<span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">//途径路线 </span><span class="token punctuation">&#125;</span>Vertex<span class="token punctuation">;</span> <span class="token keyword">typedef</span> <span class="token keyword">struct</span><span class="token punctuation">&#123;</span>    Vertex vexs<span class="token punctuation">[</span>MAXVEX<span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment">//站点 </span>    <span class="token keyword">int</span> arc<span class="token punctuation">[</span>MAXVEX<span class="token punctuation">]</span><span class="token punctuation">[</span>MAXVEX<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">//邻接矩阵 </span>    <span class="token keyword">int</span> numVertexes<span class="token punctuation">,</span> numEdges<span class="token punctuation">;</span> <span class="token comment">//顶点数和边数 </span><span class="token punctuation">&#125;</span>MGraph<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="图的创建和初始化"><a href="#图的创建和初始化" class="headerlink" title="图的创建和初始化"></a>图的创建和初始化</h2><p>创建图，把带权的邻接矩阵赋值进去，把每个顶点路径的路线也存放在顶点的lines数组中</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">/* 构造图 */</span><span class="token keyword">void</span> <span class="token function">CreateMGraph</span><span class="token punctuation">(</span>MGraph <span class="token operator">*</span>G<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> i<span class="token punctuation">,</span> j<span class="token punctuation">;</span>        <span class="token comment">//请输入边数和顶点数</span>    G<span class="token operator">-></span>numEdges<span class="token operator">=</span><span class="token number">52</span><span class="token punctuation">;</span>    G<span class="token operator">-></span>numVertexes<span class="token operator">=</span><span class="token number">26</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> G<span class="token operator">-></span>numVertexes<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token comment">/* 初始化图的顶点编号 */</span>    <span class="token punctuation">&#123;</span>        G<span class="token operator">-></span>vexs<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>name<span class="token operator">=</span>i<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span><span class="token number">26</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token comment">//初始化每个站点通过路线的数组，设为零 </span>    <span class="token punctuation">&#123;</span>     <span class="token keyword">for</span><span class="token punctuation">(</span>j<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>j<span class="token operator">&lt;</span><span class="token number">6</span><span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span>     <span class="token punctuation">&#123;</span>      G<span class="token operator">-></span>vexs<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>lines<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>     <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>        G<span class="token operator">-></span>vexs<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>lines<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>    G<span class="token operator">-></span>vexs<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">.</span>lines<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span> G<span class="token operator">-></span>vexs<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">.</span>lines<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">;</span>    G<span class="token operator">-></span>vexs<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">.</span>lines<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>    G<span class="token operator">-></span>vexs<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">.</span>lines<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>    G<span class="token operator">-></span>vexs<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">.</span>lines<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">;</span>    G<span class="token operator">-></span>vexs<span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">.</span>lines<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>    G<span class="token operator">-></span>vexs<span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">]</span><span class="token punctuation">.</span>lines<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">;</span>    G<span class="token operator">-></span>vexs<span class="token punctuation">[</span><span class="token number">8</span><span class="token punctuation">]</span><span class="token punctuation">.</span>lines<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span> G<span class="token operator">-></span>vexs<span class="token punctuation">[</span><span class="token number">8</span><span class="token punctuation">]</span><span class="token punctuation">.</span>lines<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">;</span>    G<span class="token operator">-></span>vexs<span class="token punctuation">[</span><span class="token number">9</span><span class="token punctuation">]</span><span class="token punctuation">.</span>lines<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span> G<span class="token operator">-></span>vexs<span class="token punctuation">[</span><span class="token number">9</span><span class="token punctuation">]</span><span class="token punctuation">.</span>lines<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">;</span> G<span class="token operator">-></span>vexs<span class="token punctuation">[</span><span class="token number">9</span><span class="token punctuation">]</span><span class="token punctuation">.</span>lines<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">;</span>    G<span class="token operator">-></span>vexs<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">.</span>lines<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">;</span>    G<span class="token operator">-></span>vexs<span class="token punctuation">[</span><span class="token number">11</span><span class="token punctuation">]</span><span class="token punctuation">.</span>lines<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>    G<span class="token operator">-></span>vexs<span class="token punctuation">[</span><span class="token number">12</span><span class="token punctuation">]</span><span class="token punctuation">.</span>lines<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">;</span>    G<span class="token operator">-></span>vexs<span class="token punctuation">[</span><span class="token number">13</span><span class="token punctuation">]</span><span class="token punctuation">.</span>lines<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">;</span> G<span class="token operator">-></span>vexs<span class="token punctuation">[</span><span class="token number">13</span><span class="token punctuation">]</span><span class="token punctuation">.</span>lines<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">5</span><span class="token punctuation">;</span>    G<span class="token operator">-></span>vexs<span class="token punctuation">[</span><span class="token number">14</span><span class="token punctuation">]</span><span class="token punctuation">.</span>lines<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>    G<span class="token operator">-></span>vexs<span class="token punctuation">[</span><span class="token number">15</span><span class="token punctuation">]</span><span class="token punctuation">.</span>lines<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">;</span>    G<span class="token operator">-></span>vexs<span class="token punctuation">[</span><span class="token number">16</span><span class="token punctuation">]</span><span class="token punctuation">.</span>lines<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">5</span><span class="token punctuation">;</span>    G<span class="token operator">-></span>vexs<span class="token punctuation">[</span><span class="token number">17</span><span class="token punctuation">]</span><span class="token punctuation">.</span>lines<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">;</span>    G<span class="token operator">-></span>vexs<span class="token punctuation">[</span><span class="token number">18</span><span class="token punctuation">]</span><span class="token punctuation">.</span>lines<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">4</span><span class="token punctuation">;</span>    G<span class="token operator">-></span>vexs<span class="token punctuation">[</span><span class="token number">19</span><span class="token punctuation">]</span><span class="token punctuation">.</span>lines<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">;</span> G<span class="token operator">-></span>vexs<span class="token punctuation">[</span><span class="token number">19</span><span class="token punctuation">]</span><span class="token punctuation">.</span>lines<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">4</span><span class="token punctuation">;</span>    G<span class="token operator">-></span>vexs<span class="token punctuation">[</span><span class="token number">20</span><span class="token punctuation">]</span><span class="token punctuation">.</span>lines<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">5</span><span class="token punctuation">;</span>    G<span class="token operator">-></span>vexs<span class="token punctuation">[</span><span class="token number">21</span><span class="token punctuation">]</span><span class="token punctuation">.</span>lines<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">5</span><span class="token punctuation">;</span>    G<span class="token operator">-></span>vexs<span class="token punctuation">[</span><span class="token number">22</span><span class="token punctuation">]</span><span class="token punctuation">.</span>lines<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">;</span>    G<span class="token operator">-></span>vexs<span class="token punctuation">[</span><span class="token number">23</span><span class="token punctuation">]</span><span class="token punctuation">.</span>lines<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">4</span><span class="token punctuation">;</span>    G<span class="token operator">-></span>vexs<span class="token punctuation">[</span><span class="token number">24</span><span class="token punctuation">]</span><span class="token punctuation">.</span>lines<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">4</span><span class="token punctuation">;</span>    G<span class="token operator">-></span>vexs<span class="token punctuation">[</span><span class="token number">25</span><span class="token punctuation">]</span><span class="token punctuation">.</span>lines<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">4</span><span class="token punctuation">;</span> G<span class="token operator">-></span>vexs<span class="token punctuation">[</span><span class="token number">25</span><span class="token punctuation">]</span><span class="token punctuation">.</span>lines<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">5</span><span class="token punctuation">;</span>   <span class="token keyword">int</span> t<span class="token punctuation">[</span>MAXVEX<span class="token punctuation">]</span><span class="token punctuation">[</span>MAXVEX<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token number">0</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span> <span class="token comment">//构造无向带权图的邻接矩阵 </span> t<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span>  <span class="token operator">=</span>  t<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>  t<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span>  <span class="token operator">=</span>  t<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span> t<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span>  <span class="token operator">=</span>  t<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">7</span><span class="token punctuation">;</span> t<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span>  <span class="token operator">=</span>  t<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>  t<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">]</span>  <span class="token operator">=</span>  t<span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">9</span><span class="token punctuation">;</span> t<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">]</span>  <span class="token operator">=</span>  t<span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">7</span><span class="token punctuation">;</span>   t<span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">9</span><span class="token punctuation">]</span>  <span class="token operator">=</span>  t<span class="token punctuation">[</span><span class="token number">9</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> t<span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">8</span><span class="token punctuation">]</span>  <span class="token operator">=</span>  t<span class="token punctuation">[</span><span class="token number">8</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span>  t<span class="token punctuation">[</span><span class="token number">8</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">9</span><span class="token punctuation">]</span>  <span class="token operator">=</span>  t<span class="token punctuation">[</span><span class="token number">9</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">8</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">6</span><span class="token punctuation">;</span> t<span class="token punctuation">[</span><span class="token number">8</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">11</span><span class="token punctuation">]</span>  <span class="token operator">=</span>  t<span class="token punctuation">[</span><span class="token number">11</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">8</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>   t<span class="token punctuation">[</span><span class="token number">9</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span>  <span class="token operator">=</span>  t<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">9</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span> t<span class="token punctuation">[</span><span class="token number">9</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">12</span><span class="token punctuation">]</span>  <span class="token operator">=</span>  t<span class="token punctuation">[</span><span class="token number">12</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">9</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">7</span><span class="token punctuation">;</span>   t<span class="token punctuation">[</span><span class="token number">11</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">14</span><span class="token punctuation">]</span>  <span class="token operator">=</span>  t<span class="token punctuation">[</span><span class="token number">14</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">11</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">8</span><span class="token punctuation">;</span> t<span class="token punctuation">[</span><span class="token number">12</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">15</span><span class="token punctuation">]</span>  <span class="token operator">=</span>  t<span class="token punctuation">[</span><span class="token number">15</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">12</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">8</span><span class="token punctuation">;</span> t<span class="token punctuation">[</span><span class="token number">13</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">9</span><span class="token punctuation">]</span>  <span class="token operator">=</span>  t<span class="token punctuation">[</span><span class="token number">9</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">13</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> t<span class="token punctuation">[</span><span class="token number">13</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">16</span><span class="token punctuation">]</span>  <span class="token operator">=</span>  t<span class="token punctuation">[</span><span class="token number">16</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">13</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span> t<span class="token punctuation">[</span><span class="token number">13</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">17</span><span class="token punctuation">]</span>  <span class="token operator">=</span>  t<span class="token punctuation">[</span><span class="token number">17</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">13</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>   t<span class="token punctuation">[</span><span class="token number">15</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">19</span><span class="token punctuation">]</span>  <span class="token operator">=</span>  t<span class="token punctuation">[</span><span class="token number">19</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">15</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">6</span><span class="token punctuation">;</span> t<span class="token punctuation">[</span><span class="token number">16</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">20</span><span class="token punctuation">]</span>  <span class="token operator">=</span>  t<span class="token punctuation">[</span><span class="token number">20</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">16</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">7</span><span class="token punctuation">;</span> t<span class="token punctuation">[</span><span class="token number">18</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">19</span><span class="token punctuation">]</span>  <span class="token operator">=</span>  t<span class="token punctuation">[</span><span class="token number">19</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">18</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> t<span class="token punctuation">[</span><span class="token number">19</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">22</span><span class="token punctuation">]</span>  <span class="token operator">=</span>  t<span class="token punctuation">[</span><span class="token number">22</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">19</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span>  t<span class="token punctuation">[</span><span class="token number">19</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">23</span><span class="token punctuation">]</span>  <span class="token operator">=</span>  t<span class="token punctuation">[</span><span class="token number">23</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">19</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span> t<span class="token punctuation">[</span><span class="token number">20</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">21</span><span class="token punctuation">]</span>  <span class="token operator">=</span>  t<span class="token punctuation">[</span><span class="token number">21</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">20</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>  t<span class="token punctuation">[</span><span class="token number">21</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">25</span><span class="token punctuation">]</span>  <span class="token operator">=</span>  t<span class="token punctuation">[</span><span class="token number">25</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">21</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span> t<span class="token punctuation">[</span><span class="token number">23</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">24</span><span class="token punctuation">]</span>  <span class="token operator">=</span>  t<span class="token punctuation">[</span><span class="token number">24</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">23</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>  t<span class="token punctuation">[</span><span class="token number">24</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">25</span><span class="token punctuation">]</span>  <span class="token operator">=</span>  t<span class="token punctuation">[</span><span class="token number">25</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">24</span><span class="token punctuation">]</span> <span class="token operator">=</span>       <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> G<span class="token operator">-></span>numVertexes<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token comment">//* 初始化图 </span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> G<span class="token operator">-></span>numVertexes<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>i<span class="token operator">==</span>j<span class="token punctuation">)</span>                G<span class="token operator">-></span>arc<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>            <span class="token keyword">else</span>                G<span class="token operator">-></span>arc<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> G<span class="token operator">-></span>arc<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> INFINITY<span class="token punctuation">;</span>             <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> G<span class="token operator">-></span>numVertexes<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token comment">//* 复制邻接矩阵 </span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> G<span class="token operator">-></span>numVertexes<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>t<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span>            <span class="token punctuation">&#123;</span>             G<span class="token operator">-></span>arc<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> t<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>           <span class="token punctuation">&#125;</span>     <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Floyd算法求多源最短路径"><a href="#Floyd算法求多源最短路径" class="headerlink" title="Floyd算法求多源最短路径"></a>Floyd算法求多源最短路径</h2><p>Floyd算法又称为插点法，是一种利用动态规划的思想寻找给定的加权图中多源点之间最短路径的算法，算法讲多源最短路径存放再P数组，最短路径的权值存放在D数组</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token operator">/</span> Floyd算法，求网图G中各顶点v到其余顶点w的最短路径P<span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token punctuation">[</span>w<span class="token punctuation">]</span>及带权长度D<span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token punctuation">[</span>w<span class="token punctuation">]</span>。  <span class="token keyword">void</span> <span class="token function">Floyd</span><span class="token punctuation">(</span>MGraph G<span class="token punctuation">,</span> <span class="token keyword">int</span> P<span class="token punctuation">[</span>MAXVEX<span class="token punctuation">]</span><span class="token punctuation">[</span>MAXVEX<span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token keyword">int</span> D<span class="token punctuation">[</span>MAXVEX<span class="token punctuation">]</span><span class="token punctuation">[</span>MAXVEX<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>     <span class="token keyword">int</span> v<span class="token punctuation">,</span>w<span class="token punctuation">,</span>k<span class="token punctuation">;</span>         <span class="token keyword">for</span><span class="token punctuation">(</span>v<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> v<span class="token operator">&lt;</span>G<span class="token punctuation">.</span>numVertexes<span class="token punctuation">;</span> <span class="token operator">++</span>v<span class="token punctuation">)</span>   <span class="token comment">/* 初始化D与P */</span>     <span class="token punctuation">&#123;</span>         <span class="token keyword">for</span><span class="token punctuation">(</span>w<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> w<span class="token operator">&lt;</span>G<span class="token punctuation">.</span>numVertexes<span class="token punctuation">;</span> <span class="token operator">++</span>w<span class="token punctuation">)</span>         <span class="token punctuation">&#123;</span>            D<span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token punctuation">[</span>w<span class="token punctuation">]</span><span class="token operator">=</span>G<span class="token punctuation">.</span>arc<span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token punctuation">[</span>w<span class="token punctuation">]</span><span class="token punctuation">;</span>     <span class="token comment">/* D[v][w]值即为对应点间的权值 */</span>            P<span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token punctuation">[</span>w<span class="token punctuation">]</span><span class="token operator">=</span>w<span class="token punctuation">;</span>                 <span class="token comment">/* 初始化P */</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span>k<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> k<span class="token operator">&lt;</span>G<span class="token punctuation">.</span>numVertexes<span class="token punctuation">;</span> <span class="token operator">++</span>k<span class="token punctuation">)</span>     <span class="token punctuation">&#123;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span>v<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> v<span class="token operator">&lt;</span>G<span class="token punctuation">.</span>numVertexes<span class="token punctuation">;</span> <span class="token operator">++</span>v<span class="token punctuation">)</span>         <span class="token punctuation">&#123;</span>             <span class="token keyword">for</span><span class="token punctuation">(</span>w<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> w<span class="token operator">&lt;</span>G<span class="token punctuation">.</span>numVertexes<span class="token punctuation">;</span> <span class="token operator">++</span>w<span class="token punctuation">)</span>             <span class="token punctuation">&#123;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>D<span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token punctuation">[</span>w<span class="token punctuation">]</span><span class="token operator">></span>D<span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token operator">+</span>D<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">[</span>w<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token comment">/* 如果经过下标为k顶点路径比原两点间路径更短 */</span>                <span class="token punctuation">&#123;</span>                    D<span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token punctuation">[</span>w<span class="token punctuation">]</span><span class="token operator">=</span>D<span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token operator">+</span>D<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">[</span>w<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">/* 将当前两点间权值设为更小的一个 */</span>                                        P<span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token punctuation">[</span>w<span class="token punctuation">]</span><span class="token operator">=</span>P<span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">/* 路径设置为经过下标为k的顶点 */</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="规划最短路径中的换乘方案，并输出"><a href="#规划最短路径中的换乘方案，并输出" class="headerlink" title="规划最短路径中的换乘方案，并输出"></a>规划最短路径中的换乘方案，并输出</h2><p>把两站的最短路径途径站站点，以及需要乘坐的公交路线规划出来，并输出。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">Transfer</span><span class="token punctuation">(</span>MGraph <span class="token operator">*</span>G<span class="token punctuation">,</span><span class="token keyword">int</span> L<span class="token punctuation">[</span>MAXVEX<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span> <span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span>j<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span>k<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>  <span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span><span class="token number">25</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">for</span><span class="token punctuation">(</span>j<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>j<span class="token operator">&lt;</span><span class="token number">6</span><span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span>  <span class="token punctuation">&#123;</span>   <span class="token keyword">if</span><span class="token punctuation">(</span>G<span class="token operator">-></span>vexs<span class="token punctuation">[</span>L<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">.</span>lines<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> G<span class="token operator">-></span>vexs<span class="token punctuation">[</span>L<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">.</span>lines<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span>   <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>G<span class="token operator">-></span>vexs<span class="token punctuation">[</span>L<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">.</span>lines<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>     cout<span class="token operator">&lt;&lt;</span><span class="token string">" 站点"</span><span class="token operator">&lt;&lt;</span>L<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token operator">&lt;&lt;</span><span class="token string">" --(公交"</span><span class="token operator">&lt;&lt;</span>G<span class="token operator">-></span>vexs<span class="token punctuation">[</span>L<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">.</span>lines<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">&lt;&lt;</span><span class="token string">"路)->"</span><span class="token punctuation">;</span>     k<span class="token operator">++</span><span class="token punctuation">;</span>     <span class="token keyword">break</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>         <span class="token punctuation">&#125;</span>     <span class="token punctuation">&#125;</span> <span class="token punctuation">&#125;</span> cout<span class="token operator">&lt;&lt;</span><span class="token string">" 站点"</span><span class="token operator">&lt;&lt;</span>L<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">;</span> cout<span class="token operator">&lt;&lt;</span>endl<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="输出最短路径"><a href="#输出最短路径" class="headerlink" title="输出最短路径"></a>输出最短路径</h2><p>从P数组中输出两点的最短路径和距离，以及途径的站点的情况和数量。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">Dispath</span><span class="token punctuation">(</span>MGraph <span class="token operator">*</span>G<span class="token punctuation">,</span><span class="token keyword">int</span> P<span class="token punctuation">[</span>MAXVEX<span class="token punctuation">]</span><span class="token punctuation">[</span>MAXVEX<span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token keyword">int</span> D<span class="token punctuation">[</span>MAXVEX<span class="token punctuation">]</span><span class="token punctuation">[</span>MAXVEX<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token keyword">int</span> v<span class="token punctuation">,</span>w<span class="token punctuation">,</span>k<span class="token punctuation">;</span> <span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> <span class="token keyword">int</span> L<span class="token punctuation">[</span>MAXVEX<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token number">0</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>    <span class="token comment">//存放两站之间的最短路径 </span>  cout<span class="token operator">&lt;&lt;</span><span class="token string">" 输入出发站：站点"</span><span class="token punctuation">;</span> cin<span class="token operator">>></span>v<span class="token punctuation">;</span> cout<span class="token operator">&lt;&lt;</span><span class="token string">" 输入终点站：站点"</span><span class="token punctuation">;</span> cin<span class="token operator">>></span>w<span class="token punctuation">;</span>   cout<span class="token operator">&lt;&lt;</span>endl<span class="token operator">&lt;&lt;</span><span class="token string">" 站点"</span><span class="token operator">&lt;&lt;</span>v<span class="token operator">&lt;&lt;</span><span class="token string">" --> 站点"</span><span class="token operator">&lt;&lt;</span>w<span class="token operator">&lt;&lt;</span><span class="token string">" 距离："</span><span class="token operator">&lt;&lt;</span>D<span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token punctuation">[</span>w<span class="token punctuation">]</span><span class="token operator">&lt;&lt;</span><span class="token string">"千米"</span><span class="token punctuation">;</span>     k<span class="token operator">=</span>P<span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token punctuation">[</span>w<span class="token punctuation">]</span><span class="token punctuation">;</span>      <span class="token comment">/* 获得第一个路径顶点下标 */</span>    cout<span class="token operator">&lt;&lt;</span><span class="token string">" 路线: "</span><span class="token operator">&lt;&lt;</span>v<span class="token punctuation">;</span>   <span class="token comment">/* 打印源点 */</span>    L<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> v<span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>k<span class="token operator">!=</span>w<span class="token punctuation">)</span>                <span class="token comment">/* 如果路径顶点下标不是终点 */</span>    <span class="token punctuation">&#123;</span>     cout<span class="token operator">&lt;&lt;</span><span class="token string">" -> "</span><span class="token operator">&lt;&lt;</span>k<span class="token punctuation">;</span>    <span class="token comment">/* 打印路径顶点 */</span>        i<span class="token operator">++</span><span class="token punctuation">;</span>         L<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> k<span class="token punctuation">;</span>        k<span class="token operator">=</span>P<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">[</span>w<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token comment">/* 获得下一个路径顶点下标 */</span>    <span class="token punctuation">&#125;</span>    L<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">=</span>w<span class="token punctuation">;</span>    cout<span class="token operator">&lt;&lt;</span><span class="token string">" -> "</span><span class="token operator">&lt;&lt;</span>w<span class="token operator">&lt;&lt;</span><span class="token string">"  共 "</span><span class="token operator">&lt;&lt;</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token operator">&lt;&lt;</span><span class="token string">" 站"</span><span class="token operator">&lt;&lt;</span>endl<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>        <span class="token function">Transfer</span><span class="token punctuation">(</span>G<span class="token punctuation">,</span>L<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="主函数"><a href="#主函数" class="headerlink" title="主函数"></a>主函数</h2><p>创建图，调用Floyd算法最短路径，输出最短路径和换乘的路线</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    MGraph G<span class="token punctuation">;</span>         <span class="token function">CreateMGraph</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>G<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">Floyd</span><span class="token punctuation">(</span>G<span class="token punctuation">,</span>P<span class="token punctuation">,</span>D<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">Dispath</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>G<span class="token punctuation">,</span>P<span class="token punctuation">,</span>D<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="输出结果"><a href="#输出结果" class="headerlink" title="输出结果"></a>输出结果<img src="https://img-blog.csdnimg.cn/20200703230528148.png" alt="在这里插入图片描述"></h2><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>1.数据结构设计不够完美，路线的数据结构用链表可能会更好<br>2.功能不够丰富，没有规划最少换乘的路线，途径站点最少的路线</p>]]></content>
      
      
      <categories>
          
          <category> 项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>用正则表达式提取信息</title>
      <link href="/posts/18151.html"/>
      <url>/posts/18151.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://img-blog.csdnimg.cn/img_convert/78a6b7ec5103ec617b301e4334bb32d8.png" alt="这里写图片描述"></p><p>正则表达式，说白了就是用来匹配字符的，正则表达式是用来简洁表达一组字符串的表达式.<br>正则表通常被用来检索、替换那些符合某个模式(规则)的文本。<br>很多编程语言都支持正则表达式进行字符串操作。在代码中常简写为regex、regexp或RE。<br>比如Pythonz中就有一个叫：re　的正则表达式库，这是Python的标准库，安装Python后自带，使用时只需要</p><pre class="line-numbers language-none"><code class="language-none">import re<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>我们可以通过requests获取网页的页面信息，但是其中的信息太过于杂乱，我们需要从中提取我们需要的信息，那么我们可以用Python的正则表达式库来提取我们需要的信息，比如说，我们想要从中提取”百度一下，你就知道”的中文字符，我们这样操作</p><p><img src="https://img-blog.csdnimg.cn/img_convert/76c3a793876bcf5eaa409b3ea4e741f6.png" alt="这里写图片描述"></p><p>这样我们就可以把html页面中的”百度一下，你就知道”的标签从复杂凌乱的信息中提取出来了，再经过一些处理就可以拿出来了</p><p><strong>语法</strong></p><p>那我们开始学习正则表达式的语法了　　以下是正则表达式的常用操作符：</p><pre class="line-numbers language-none"><code class="language-none">. 　　　　表示任何单个字符[ ] 　　　字符集,对单个字符给出取值范围 　　　　　[abc]表示a、b、c,[a‐z]表示a到z单个字符[^ ] 　　非字符集,对单个字符给出排除范围 　　　　[^abc]表示非a或b或c的单个字符* 　　　　前一个字符0次或无限次扩展 　　　　　　　abc* 表示 ab、abc、abcc、abccc等+ 　　　　前一个字符1次或无限次扩展 　　　　　　　abc+ 表示 abc、abcc、abccc等? 　　　　前一个字符0次或1次扩展 　　　　　　　　abc? 表示 ab、abc| 　　　　左右表达式任意一个 　　　　　　　　　　　abc|def 表示 abc、def&#123;m&#125; 　　　扩展前一个字符m次 　　　　　　　　　　　ab&#123;2&#125;c表示abbc&#123;m,n&#125; 　　扩展前一个字符m至n次(含n) 　　　　　　ab&#123;1,2&#125;c表示abc、abbc^ 　　　　匹配字符串开头 　　　　　　　　　　　　^abc表示abc且在一个字符串的开头$　　　　 匹配字符串结尾 　　　　　　　　　　　　　abc$表示abc且在一个字符串的结尾( ) 　　　分组标记,内部只能使用 | 操作符 　　　　(abc)表示abc,(abc|def)表示abc、def\d 　　　数字,等价于[0‐9] \w 　　　单词字符,等价于[A‐Za‐z0‐9_]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这些都是非常常见的正则表达式操作符，记住了，大部分都能用了。</p><p>我们接下来看一下经典的正则表达式匹配实例</p><pre class="line-numbers language-none"><code class="language-none">^[A‐Za‐z]+$ 　　　　　　　　　由26个字母组成的字符串^[A‐Za‐z0‐9]+$ 　　　　　　　由26个字母和数字组成的字符串^‐?\d+$ 　　　　　　　　　　　整数形式的字符串^[0‐9]*[1‐9][0‐9]*$ 　　　　正整数形式的字符串[1‐9]\d&#123;5&#125; 　　　　　　　　　中国境内邮政编码,6位[\u4e00‐\u9fa5] 　　　　　　匹配中文字符\d&#123;3&#125;‐\d&#123;8&#125;|\d&#123;4&#125;‐\d&#123;7&#125;　 　国内电话号码,010‐68913536<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>正则表达式库</strong></p><p>上面我们说过，re是Python的内置库，不需要安装，直接导入即可</p><p>raw string类型(原生字符串类型)，也就是不包含对转义符再次转义的字符串<br>re库采用raw string类型表示正则表达式,表示为:　　　　　r’text’</p><p>re库的主要函数共有6个，分别是</p><pre class="line-numbers language-none"><code class="language-none">re.search() 　　　　在一个字符串中搜索匹配正则表达式的第一个位置,返回match对象re.match() 　　　　　从一个字符串的开始位置起匹配正则表达式,返回match对象re.findall() 　　　　搜索字符串,以列表类型返回全部能匹配的子串re.split() 　　　　　将一个字符串按照正则表达式匹配结果进行分割,返回列表类型re.finditer() 　　　搜索字符串,返回一个匹配结果的迭代类型,每个迭代元素是match对象re.sub() 　　　　　　在一个字符串中替换所有匹配正则表达式的子串,返回替换后的字符串<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>re.findall( )这个比较简单常用，用法如下：<br>这个函数共有三个参数，pattern, string , flags</p><pre class="line-numbers language-none"><code class="language-none">re.findall(pattern, string, flags&#x3D;0)搜索字符串,以列表类型返回全部能匹配的子串∙ pattern : 正则表达式的字符串或原生字符串表示∙ string  : 待匹配字符串∙ flags 正则表达式使用时的控制标记<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>比如我们要从一堆字符中，把数字提取出来：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/5c7f4d8cce1bc8e69703689340a145ee.png" alt="这里写图片描述"></p><p>其他函数的使用实例</p><p><img src="https://img-blog.csdnimg.cn/img_convert/892343d97a58d23869401796dec7b98f.png" alt="这里写图片描述"></p><p><strong>定向爬虫</strong></p><p>爬取豆瓣电影，上海热映的电影：</p><p>url = <a href="https://movie.douban.com/cinema/nowplaying/shanghai/">https://movie.douban.com/cinema/nowplaying/shanghai/</a></p><p>我们需要定义一个函数，用于获取豆瓣热映的电影信息：</p><pre class="line-numbers language-none"><code class="language-none">import requests   &#x2F;&#x2F;导入需要用到的库import redef getHTMLText(url):    try:        r &#x3D; requests.get(url)        r.raise_for_status()        r.encoding &#x3D; r.apparent_encoding        return r.text    except:        print(&quot;Erro_get&quot;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们还需要定义一个函数，用于提取所需要的电影信息：</p><pre class="line-numbers language-none"><code class="language-none">def parsePage(ilt,html):    tlt &#x3D; re.findall(r&#39;data-title\&#x3D;\&quot;.*?\&quot;&#39;,html)    for i in range(len(tlt)):        plt &#x3D; eval(tlt[i].split(&#39;&#x3D;&#39;)[1])        if plt in ilt:            pass        else:            ilt.append(plt)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后第三个函数用于输出电影列表：</p><pre class="line-numbers language-none"><code class="language-none">def printInfo(ilt):    print(&quot;上　海　热　映&quot;)    for i in ilt:        print(i)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>再定义一个主函数去调用这些功能函数：</p><pre class="line-numbers language-none"><code class="language-none">def main():    url &#x3D; &#39;https:&#x2F;&#x2F;movie.douban.com&#x2F;cinema&#x2F;nowplaying&#x2F;shanghai&#x2F;&#39;    kv &#x3D; &#123;&#39;User-Agent&#39; : &#39;Mozilla&#x2F;5.0&#39;&#125;    list &#x3D; []    html &#x3D; getHTMLText(url)    parsePage(list,html)    printInfo(list)    main()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行即可看到以下画面：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/e9c276396256480e18cbf9fc866638eb.png" alt="这里写图片描述"></p><p><strong>总结</strong></p><p>re库的功能非常强大，这些只是一些非常浅显的内容。<br>大家可以多实战，掌握正则表达式的用法。</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 正则表达式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>用Python写网络爬虫</title>
      <link href="/posts/59924.html"/>
      <url>/posts/59924.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://img-blog.csdnimg.cn/img_convert/1755e387b948ffbcc7284362c01b4ba5.png" alt="这里写图片描述"></p><p><strong>网络爬虫（又被称为网页蜘蛛，网络机器人，是一种按照一定</strong><br><strong>的规则，自动地抓取万维网信息的程序或者脚本。</strong></p><p><em><strong>前言</strong></em></p><p>在讲爬虫之前，我们需要知道我们是如何从网络上获取信息的，有人说，百度啊，谷歌啊！！！！！<br>没错，大多时候，我们都是利用他们从网络上面获取我们的信息的，其实搜索引擎也是爬虫的一种，他们的爬每天都有成千上万的爬虫在互联网上不断的爬去各种各样的信息，存到他们的数据库，做出索引，通过复杂的算法做成搜索引擎。你可以把互联网想象成一个蜘蛛网，每个节点就是一个网站，一个域名，上面有一个蜘蛛爬来爬去，收集各个网站的信息，这个蜘蛛就是爬虫。</p><p>随着网络的迅速发展，互联网拥有无穷无尽的信息，如何有效地提取并利用这些信息成为一个巨大的挑战。<br>在这个人人都说big-data，信息满天飞的时代，不会点儿爬虫技术都不好意思和别人打招呼，掌握网络爬虫与信息提取技术，你可以快速的从互联网上获取你需要的信息，不用去伪造，发问卷去收集数据。那么如何写网络爬虫呢？</p><p><strong>HTTP协议</strong></p><p>我们是如何访问互联网的？</p><p>打开电脑上了浏览器，在上面的地址栏输入<a href="https://www.jd.com/">https://www.jd.com</a><br>按一下回车，京东的首页就会出现在我们的面前。</p><p>这个过程就是一次访问互联网的过程，京东就是我们的访问目标   我们就是通过<br>这么一个url(<a href="https://www.jd.com)去访问互联网的,这个过程是通过http协议/">https://www.jd.com)去访问互联网的，这个过程是通过HTTP协议</a><br>实现的。那么HTTP协议是什么？</p><p><img src="https://img-blog.csdnimg.cn/img_convert/ddd903cbe48748b36596b9159f34cc70.png" alt="这里写图片描述"></p><p>超文本传输协议（HTTP，HyperText Transfer Protocol)是互联网上应用最为广泛的一种网络协议。所有的WWW文件都必须遵守这个标准。设计HTTP最初的目的是为了提供一种发布和接收HTML页面的方法。1960年美国人Ted Nelson构思了一种通过计算机处理文本信息的方法，并称之为超文本（hypertext）,这成为了HTTP超文本传输协议标准架构的发展根基。Ted Nelson组织协调万维网协会（World Wide Web Consortium）和互联网工程工作小组（Internet Engineering Task Force ）共同合作研究，最终发布了一系列的RFC，其中著名的RFC 2616定义了HTTP 1.1。</p><p>HTTP是一个基于“请求与响应”模式的、无状态的应用层协议<br>HTTP协议采用URL作为定位网络资源的标识,URL格式如下:</p><pre class="line-numbers language-none"><code class="language-none">protocol:&#x2F;&#x2F;hostname[:port]&#x2F;path&#x2F;[parameters][?query]　　　　　&#x2F;&#x2F;带[]的为可选项<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>第一部分(protocol)<br>模式/协议（scheme）：它告诉浏览器如何处理将要打开的文件。最常用的模式是超文本传输协议（Hypertext Transfer Protocol，缩写为HTTP），这个协议可以用来访问网络。<br>还有其他的协议：</p><pre class="line-numbers language-none"><code class="language-none">http　　　　　　　　　超文本传输协议资源https　　　　　　　　用安全套接字层传送的超文本传输协议ftp　　　　　　　　　文件传输协议mailto　　　　　　　电子邮件地址ldap　　　　　　　　轻型目录访问协议搜索file　　　　　　　　当地电脑或网上分享的文件news　　　　　　　　Usenet新闻组gopher　　　　　　　Gopher协议telnet　　　　　　　Telnet协议ed2k             电驴下载协议<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>第二部分<br>文件所在的服务器的名称或IP地址，后面是到达这个文件的路径和文件本身的名称</p><pre class="line-numbers language-none"><code class="language-none">host: 合法的Internet主机域名或IP地址port: 端口号,默认为80和443端口path: 请求资源的路径<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>URL是通过HTTP协议存取资源的Internet路径,一个URL对应一个数据资源。url举例：</p><pre class="line-numbers language-none"><code class="language-none">http:&#x2F;&#x2F;www.baidu.comhttp:&#x2F;&#x2F;192.168.1.1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>HTTP协议对资源的操作方法</p><pre class="line-numbers language-none"><code class="language-none">GET 　　　　　　　　　　请求获取URL位置的资源HEAD 　　　　　　　　　　请求获取URL位置资源的响应消息报告,即获得该资源的头部信息POST 　　　　　　　　　　请求向URL位置的资源后附加新的数据PUT 　　　　　　　　　　请求向URL位置存储一个资源,覆盖原URL位置的资源PATCH 　　　　　　　　　请求局部更新URL位置的资源,即改变该处资源的部分内容DELETE 　　　　　　　　请求删除URL位置存储的资源<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://img-blog.csdnimg.cn/img_convert/c42c137593ec17d54637b93f614c119b.png" alt="这里写图片描述"></p><p><strong>Python的Requests库</strong></p><p>说了这么多，有啥用？<br>上面讲的这些都是我们平时手动访问互联网的方法，我们是要写网络爬虫，程序自动访问互联网。<br>所以，一个很现实的问题出现了，Python如何访问互联网？尴尬。。。</p><p>在Python中，有很多库可以访问互联网，比如urllib , Requests , scrapy等用于获取网页信息的模块<br>在学习的过程中，我们可以先选择一种，其他都差不多的。那么这次我们选用Requests。我认为他<br>更简单，更易用。</p><p>Anaconda工具套装中默认安装了这个库。可以参照以前的文章安装Anaconda套装.<br>或者打开终端，输入安装命令，安装非常简单，没有什么可说的；</p><pre class="line-numbers language-none"><code class="language-none">pip install requests<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>我们测试一下安装的结果，打开jupyter notebook，新建一个Python代码编辑器，输入以下代码：</p><pre class="line-numbers language-none"><code class="language-none">import requests                          &#x2F;&#x2F;引入requests库r &#x3D; requests.get(https:&#x2F;&#x2F;www.baidu.com)　&#x2F;&#x2F;以get的方式访问百度print(r.status_code)　　　　　　　　　　　　　&#x2F;&#x2F;打印连接的状态码，200表示连接成功<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="https://img-blog.csdnimg.cn/img_convert/a10d51c1bbf024b1e0be3c470dc833b5.png" alt="这里写图片描述"></p><pre class="line-numbers language-none"><code class="language-none">200　　　　　　&#x2F;&#x2F;请求成功，返回内容204　　　　　　&#x2F;&#x2F;请求成功，不返回内容301　　　　　　&#x2F;&#x2F;请求的资源永久移动304         　&#x2F;&#x2F;资源重定向403         　&#x2F;&#x2F;请求被拒绝404         　&#x2F;&#x2F;请求的资源不存在503         　&#x2F;&#x2F;服务器故障<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>requests库有７个方法，与HTTP协议一一对应</p><pre class="line-numbers language-none"><code class="language-none">requests.request() 　构造一个请求,支撑以下各方法的基础方法requests.get() 　　　获取HTML网页的主要方法,对应于HTTP的GETrequests.head() 　　　获取HTML网页头信息的方法,对应于HTTP的HEADrequests.post() 　　　向HTML网页提交POST请求的方法,对应于HTTP的POSTrequests.put() 　　　向HTML网页提交PUT请求的方法,对应于HTTP的PUTrequests.patch() 　　向HTML网页提交局部修改请求,对应于HTTP的PATCHrequests.delete() 　　向HTML页面提交删除请求,对应于HTTP的DELETE<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>requests.request() 方法是requests库的基本方法</p><pre class="line-numbers language-none"><code class="language-none">requests.get(url, params&#x3D;None, **kwargs)∙ url : 　　　　　拟获取页面的url链接∙ params : 　　　url中的额外参数,字典或字节流格式,可选∙ **kwargs: 　　　12个控制访问的参数<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://img-blog.csdnimg.cn/img_convert/4d82b2ca9c6ceeddcd0f31eee20cfe61.png" alt="这里写图片描述"></p><p>Requests库两个重要对象是Response和Request<br>Response包含爬虫返回的内容，Responsed对象的属性</p><pre class="line-numbers language-none"><code class="language-none">r.status_code HTTP请求的返回状态,200表示连接成功,404表示失败r.text HTTP响应内容的字符串形式,即,url对应的页面内容r.encoding 从HTTP header中猜测的响应内容编码方式r.apparent_encoding 从内容中分析出的响应内容编码方式(备选编码方式)r.content HTTP响应内容的二进制形式<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://img-blog.csdnimg.cn/img_convert/68f0b7269bec4aa644a60c746c702447.png" alt="这里写图片描述"></p><p>Responsed的编码，内容中的实际编码才是我们需要的，打印text是是按照HTTP header中的编码，所以，<br>如果编码不一致，我们需要让他们一致。输入一行代码即可</p><pre class="line-numbers language-none"><code class="language-none">r.encoding &#x3D; r.apparent_encoding<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">r.encoding 从HTTP header中猜测的响应内容编码方式r.apparent_encoding 从内容中分析出的响应内容编码方式(备选编码方式)r.encoding:如果header中不存在charset,则认为编码为ISO‐8859‐1r.text根据r.encoding显示网页内容r.apparent_encoding:根据网页内容分析出的编码方式可以看作是r.encoding的备选<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>讲完了requests库，我们可以实际试一下，没有实际操作都是瞎逼逼，我们用实例来看看吧！！！</p><p><strong>实例</strong></p><p>爬取京东小米6的商品信息，在代码编辑器输入以下代码：</p><pre class="line-numbers language-none"><code class="language-none">import requestsr &#x3D; requests.get(&#39;https:&#x2F;&#x2F;item.jd.com&#x2F;4957824.html&#39;)print(r.text)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="https://img-blog.csdnimg.cn/img_convert/62ad5604e4eebd3e8aaa16ab5d2ac6d7.png" alt="这里写图片描述"></p><p>可以看到，返回了京东小米6的商品页面信息。是不是非常简单！！！</p><p>那我们也可以去亚马逊看看，把url改成：</p><pre class="line-numbers language-none"><code class="language-none">https:&#x2F;&#x2F;www.amazon.cn&#x2F;Alienware-%E5%A4%96%E6%98%9F%E4%BA%BA-15C-R2738S-15-6%E8%8B%B1%E5%AF%B8%E6%B8%B8%E6%88%8F%E7%AC%94%E8%AE%B0%E6%9C%AC%E7%94%B5%E8%84%91&#x2F;dp&#x2F;B06WVM5SQX&#x2F;ref&#x3D;sr_1_1?ie&#x3D;UTF8&amp;qid&#x3D;1505224864&amp;sr&#x3D;8-1&amp;keywords&#x3D;%E5%A4%96%E6%98%9F%E4%BA%BA<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://img-blog.csdnimg.cn/img_convert/8faaa2d05ba7c9a3401e1bc0acce38a8.png" alt="这里写图片描述"></p><p>我们看到返回的东西，完全不知道是什么，而且长度也非常小，这么复杂的页面。<br>一开始我们可以怀疑是编码问题，看一下编码，果然不一致</p><pre class="line-numbers language-none"><code class="language-none">r.encoding                       &#x2F;&#x2F;HTTP响应头中的编码r.apparent_encoding　　　　　　　　 &#x2F;&#x2F;根据文本内容猜测的编码<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>打印r.text的时候是按照HTTP响应中的编码打印的，完全不一致啊！！！！<br>在编辑器里面输入以下代码，让他们一致就好</p><p><img src="https://img-blog.csdnimg.cn/img_convert/6355918d82a5a59f332f20f0a1d6ab05.png" alt="这里写图片描述"></p><p>我们发现了不友好的内容，看一下HTTP的状态码，然而返回的是503 , 而不是我们喜欢的200</p><p> 原因是，亚马逊通过HTTP请求头，发现来源并不是浏览器，而是爬虫，所以重定向了错误的页面<br> 当然，我们也可以修改HTTP请求头，让亚马逊以为我是流量器，是正常的用户访问</p><p><img src="https://img-blog.csdnimg.cn/img_convert/11ea4df0bbb2566d572d72290090f610.png" alt="这里写图片描述"></p><p>这样看起来就比较舒服的了，那么平时我们经常会看到这种的错误，那么我们可以使用异常处理</p><pre class="line-numbers language-none"><code class="language-none">try:r &#x3D; requests.get(url)r.raise_for_status()r.encoding &#x3D; r.apparent_encoding        print(r.text)except:        print(&quot;Error_get&quot;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>总结</strong></p><p>requests在小规模爬虫的应用非常广泛，可以继续挖掘他的应用！！！</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 爬虫 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何做中文词云</title>
      <link href="/posts/63928.html"/>
      <url>/posts/63928.html</url>
      
        <content type="html"><![CDATA[<p><strong>前言</strong></p><pre><code>在上一篇文章中，我们讲解了在Ubuntu环境下安装Anaconda，并且做出了英文的简易词云。可能会有的同学尝试把文章换成中文的，做出中文词云。我想大家得到的结果肯定是这样的</code></pre><p><img src="https://img-blog.csdnimg.cn/img_convert/fa99bc6e39dd24c546b9248c0b153700.png" alt="这里写图片描述"></p><pre><code>中文与英文在编码上是存在很多区别的，而且我们做英文词云的时候，在一篇文章中，单词之间是通过空格分开的，但是中文并没有使用空格。所有就有了上面的图片。那么中文如何分词呢？我们需要用到一款工具，jieba（结巴）</code></pre><p><strong>准备工作</strong></p><pre><code>１．文本数据，作为分析的对象。这是必须的，这次我选用的是上一次相关的文本数据　　我有一个梦想的中文版本。做成Dream.txt文件，保存在和代码相同的目录下。２．Anaconda工具套装，上一篇文章已经讲过如何安装和使用，这里不在啰嗦。３．worldcloud ,作词云用的Python扩展工具包。４．jieba      中文分词用的扩展包。５．simsum.tty　　中文字体包，用于显示中文。</code></pre><p><strong>第一步</strong></p><p>打开终端输入以下命令，安装jieba扩展包</p><pre class="line-numbers language-none"><code class="language-none">pip install jieba   &#x2F;&#x2F;安装很简单，没什么可说的<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>继续在终端输入</p><pre class="line-numbers language-none"><code class="language-none">jupyter notebook     &#x2F;&#x2F;打开代码编辑器，并切换到存放Dream.txt的目录下<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果你做了上次那个因为词云，那就用上次那个目录就可以了，在代码编辑器输入以下代码</p><pre class="line-numbers language-none"><code class="language-none">file &#x3D; open(&#39;Dream.txt&#39;)text &#x3D; file.read()text<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="https://img-blog.csdnimg.cn/img_convert/7fc942d47aac28ea389446bb7fa185b6.png" alt="这里写图片描述"></p><p>出现这样的字样，说明文本数据没有问题，可以正常打开。</p><p><strong>分词</strong></p><p>在第二和第三行之间，插入以下代码，进行分词操作</p><pre class="line-numbers language-none"><code class="language-none">import jieba　　　　　　　　　　　　　　　　　　　&#x2F;&#x2F;导入jieba分词包text &#x3D; &#39; &#39;.join(jieba.cut(text))　　　　　　 　&#x2F;&#x2F;对中文进行分词<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>你将会看到以下的画面，说明分词成功了</p><p><img src="https://img-blog.csdnimg.cn/img_convert/b8d434e358bf46b9de5819590f46ebfe.png" alt="这里写图片描述"></p><p><strong>词云生成</strong></p><p>注释掉代码最后的text,以防干扰。继续在编辑器里输入</p><pre class="line-numbers language-none"><code class="language-none">from wordcloud import WordCloudwordcloud &#x3D; WordCloud().generate(text)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>此时如果没有报错，也没有任何输出，那是不是词云就已经分析完成了呢？<br>并不是，但这次和上次的英文不一样，因为我们要输出中文的词云，所以我们<br>准备了simsum.tty的字体包，把它放在代码相同的目录下，然后在代码编辑器输入以下代码：</p><pre class="line-numbers language-none"><code class="language-none">from wordcloud import WordCloudwordcloud &#x3D; WordCloud(font_path&#x3D;&quot;simsun.ttf&quot;).generate(mytext)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>依然没有输出，但这次离成功不远了。</p><p><strong>词云输出</strong></p><p>在代码编辑器里面输入以下代码：</p><pre class="line-numbers language-none"><code class="language-none">%pylab inlineimport matplotlib.pyplot as pltplt.imshow(wordcloud, interpolation&#x3D;&#39;bilinear&#39;)plt.axis(&quot;off&quot;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>你将看到以下结果，请无视警告</p><p><img src="https://img-blog.csdnimg.cn/img_convert/ea4d411d831bccdab04a0dffbf57c1c0.png" alt="这里写图片描述"></p><p>　　　　　　　　<strong>一张简易的中文词云就做好啦！！！</strong></p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 中文 </tag>
            
            <tag> 词云 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何用Python做词云</title>
      <link href="/posts/11496.html"/>
      <url>/posts/11496.html</url>
      
        <content type="html"><![CDATA[<p><strong>１．词云是什么?想必大家都见过这种图片，这就是词云啦</strong></p><p><img src="https://img-blog.csdnimg.cn/img_convert/7f8771b93f27a485fe9c4803cdf0e086.png" alt="这里写图片描述"><br><img src="https://img-blog.csdnimg.cn/img_convert/8f6b223da31418d3b91a8c92b4751cd5.png" alt="这里写图片描述"></p><pre class="line-numbers language-none"><code class="language-none">“词云”这个概念由美国西北大学新闻学副教授、新媒体专业主任里奇·戈登（Rich Gordon）于近日提出。戈登做过编辑、记者，曾担任迈阿密先驱报（Miami Herald）新媒体版的主任。他一直很关注网络内容发布的最新形式——即那些只有互联网可以采用而报纸、广播、电视等其它媒体都望尘莫及的传播方式。通常，这些最新的、最适合网络的传播方式，也是最好的传播方式。 因此，“词云”就是对网络文本中出现频率较高的“关键词”予以视觉上的突出，形成“关键词云层”或“关键词渲染”，从而过滤掉大量的文本信息，使浏览网页者只要一眼扫过文本就可以领略文本的主旨。　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　－－－－百度百科<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>２ . 那如何做词云呢，这些词云是怎么生成的呢</strong></p><pre><code>    现在，我们用Python这门非常热门的编程语言来做词云，如果你之前没有编程基础，没关系。从零开始，意味着我会教你如何安装Python运行环境，一步步完成词云图。希望你不要限于浏览，而是亲自动手尝试一番。</code></pre><p><strong>３．环境的安装</strong></p><p>要使用Python，我们就需要安装Python的运行环境，如果你和我一样使用的是Ubuntu系统，那么的你的系统就已经安装了Python2.7和Python3.6的运行环境，在终端下输入python2.7或python3即可启动。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/0d95278fac9eedbea22eca44609a72e7.png" alt="这里写图片描述"></p><p>但这只是一个运行环境，我们知道Python是一门非常强大的语言，拥有非常多的库。所有我们要做词云，也需要安装一些库.那么我们最好是安装一个工具包，这样我们需要的库，或者扩展包都包含了，不需要我们在安装上花费太多的时间。</p><p>那么我推荐，也是业内非常推荐的一款套装，他就是大名鼎鼎的Anaconda<br>官方下载地址：<a href="https://www.anaconda.com/download/">https://www.anaconda.com/download/</a></p><p><img src="https://img-blog.csdnimg.cn/img_convert/377a8b7239907e24075d48b0d674ae18.png" alt="这里写图片描述"></p><p>但是这个地址下载速度实在是慢得让人抓狂，所有我给出这个下载地址<br>清华大学开源软件镜像站：<a href="https://mirrors.tuna.tsinghua.edu.cn/anaconda/archive/">https://mirrors.tuna.tsinghua.edu.cn/anaconda/archive/</a><br>按照对应的系统版本下载即可。</p><p>这里有一个版本选择的问题我们是选择Python2.7还是Python3呢<br>我推荐大家选Python3,也就是Anaconda3毕竟长江后浪推前浪</p><p><img src="https://img-blog.csdnimg.cn/img_convert/327b4c6f3912f6a76fa7ba0c10c45278.png" alt="这里写图片描述"></p><p>我的是Ubuntu，下载好的是一个以.sh结尾的脚步文件。<br>打开终端，输入</p><pre class="line-numbers language-none"><code class="language-none">bash Anaconda3-4.4.0-Linux-x86_64.sh<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>按提示输入回车，所有要求选择yes/no的都选择yes<br>骚等片刻，Anaconda就安装好了。</p><p>接着我们打开终端，输入</p><pre class="line-numbers language-none"><code class="language-none">mkdir ciyun                  &#x2F;&#x2F;创建一个专用的目录（个人喜好）cd ciyunpip install wordcloud　　　　　&#x2F;&#x2F;安装词云wordcloud扩展包，做词云用的&#x2F;&#x2F;过程略 ....pip list                      &#x2F;&#x2F;输出的结果下有wordcloud<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>一路下载安装，完成。如果没有报错，并且在恭喜你环境就配置好了。非常简单是不是.</p><p><strong>４．开始动手做词云</strong></p><p>在开始之前，我们还需要分析的对象，也就是文本。因为中文的构成毕竟复杂，我们先选择英文文本<br>我这次选择的是马丁路德金的我有一个梦想演讲搞，大家可以去搜索一下。把这个txt的文本放在我们创建的ciyun目录下。我取名为dream_En.txt</p><p>在终端输入</p><pre class="line-numbers language-none"><code class="language-none">jupyter notebook      &#x2F;&#x2F;自动打开一个浏览器<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>然后切换到我们创建的ciyun目录，点击右上角的NEW,创建一个编辑器，名字随意，有些不用名字.输入一下代码</p><pre class="line-numbers language-none"><code class="language-none">file &#x3D; open(&#39;dream_En.txt&#39;)　　　&#x2F;&#x2F;打开文本text &#x3D; file.read()              &#x2F;&#x2F;读取文本text　　　　　　　                 &#x2F;&#x2F;输出文本　　　按Shift+Enter执行代码<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="https://img-blog.csdnimg.cn/img_convert/8492ec22c5f6537f687c58733d072ef4.png" alt="这里写图片描述"></p><p>到这里说明我们的数据没有问题，接着我们需要使用wordcloud对文本进行分析</p><pre class="line-numbers language-none"><code class="language-none">from wordcloud import WordCloudwordcloud &#x3D; WordCloud().generate(mytext)　　&#x2F;&#x2F;如果出现警告，忽略，不影响的<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="https://img-blog.csdnimg.cn/img_convert/50058c32bbbaa948ab0ca54dc4459794.png" alt="这里写图片描述"></p><p>把text用＃注释掉，防止干扰。但是到这一步却没有输出，但词云其实已经分析完成了，只是没有输出</p><p>注意：如果你在这一步报了一个错，比如</p><pre class="line-numbers language-none"><code class="language-none">ImportError:cannot import name wordcloud   &#x2F;&#x2F;类似字眼的<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>那么是你的wordcloud没有安装好，回到终端检查一下。</p><pre class="line-numbers language-none"><code class="language-none">pip list   　　　　　　　　　&#x2F;&#x2F;看看输出结果有没有wordcloud,如果没有，请继续pip install wordcloud    　&#x2F;&#x2F;安装<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>接着，</p><pre class="line-numbers language-none"><code class="language-none">%pylab inlineimport matplotlib.pyplot as pltplt.imshow(wordcloud, interpolation&#x3D;&#39;bilinear&#39;)plt.axis(&quot;off&quot;)　　　　　　&#x2F;&#x2F;忽略警告<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://img-blog.csdnimg.cn/img_convert/2e7bcc84f0775791f7e74d352f16b83a.png" alt="这里写图片描述"></p><p>是不是很激动，一张英文词云就这样做好了．简单吧！</p><p><strong>５.总结</strong></p><p>wordcloud这个扩展包的功能非常多，大家发现，做出的词云与本文开头的还是有一些差距的，那么在后续的文章中我会一一讲解。慢慢挖掘wordcloud的高级特性。</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 词云 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
